

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>4. Week 03 - Script Context &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Week 04 - Monads" href="week4.html" />
    <link rel="prev" title="3. Week 02 - Validation" href="week2.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="week1.html">2. Week 01 - Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week2.html">3. Week 02 - Validation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Week 03 - Script Context</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#housekeeping">4.1. Housekeeping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#porting-isdata">4.1.1. Porting IsData</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#code-changes">4.1.1.1. Code Changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#playground-changes">4.1.1.2. Playground Changes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recap">4.2. Recap</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scriptcontext">4.3. ScriptContext</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#txinfovalidrange">4.3.1. txInfoValidRange</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slot">4.3.2. Slot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-vesting">4.4. Example - Vesting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#in-the-playground">4.4.1. In the playground</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-2-parameterized-contract">4.5. Example 2 - Parameterized Contract</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#an-observation">4.5.1. An Observation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#another-way-of-doing-it">4.5.2. Another Way of Doing It</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-lift-class">4.5.2.1. The Lift Class</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#back-to-the-playground">4.5.3. Back to the playground</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="week4.html">5. Week 04 - Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="week5.html">6. Week 05 - Native Tokens</a></li>
<li class="toctree-l1"><a class="reference internal" href="week6.html">7. Week 06 - Oracles</a></li>
<li class="toctree-l1"><a class="reference internal" href="week7.html">8. Week 07 - State Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="week8.html">9. Week 08 - Property Based Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="week9.html">10. Week 09 - Marlowe</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">4. </span>Week 03 - Script Context</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week3.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-03-script-context">
<h1><span class="section-number">4. </span>Week 03 - Script Context<a class="headerlink" href="#week-03-script-context" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://youtu.be/Lk1eIVm_ZTQ">Lecture
#3</a>.</p>
<p>In this lecture we learn about the script context (the third validation
argument), handling time, and parameterized contracts.</p>
</div>
<div class="section" id="housekeeping">
<h2><span class="section-number">4.1. </span>Housekeeping<a class="headerlink" href="#housekeeping" title="Permalink to this headline">¶</a></h2>
<p>For this lecture we will be working with a later commit of Plutus than
in previous lectures. You will find the commit in the cabal.project file
for Week03.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">Plutus</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="mi">3</span><span class="n">aa86304e9bfc425667051a8a94db73fcdc38878</span>
</pre></div>
</div>
<p>It would, of course, be better for everyone if we could keep the Plutus
dependencies stable, but this is not really possible as Plutus is
evolving very quickly while heading towards the Alonzo release, where
Plutus is fully integrated into the Cardano node.</p>
<p>If we wait too long and stay on an outdated version, then when we
finally have to upgrade to use Plutus on the testnet, there will be lots
of changes.</p>
<p>This does mean that some of the code from the first two lectures will
not compile against the new version.</p>
<p>But, luckily, the changes are not that bad.</p>
<p>Let’s take the last example from Week 02 and port it to the new Plutus
version to see what has changed.</p>
<div class="section" id="porting-isdata">
<h3><span class="section-number">4.1.1. </span>Porting IsData<a class="headerlink" href="#porting-isdata" title="Permalink to this headline">¶</a></h3>
<div class="section" id="code-changes">
<h4><span class="section-number">4.1.1.1. </span>Code Changes<a class="headerlink" href="#code-changes" title="Permalink to this headline">¶</a></h4>
<p>The first difference is in the <em>mkValidator</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">MySillyRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">MySillyRedeemer</span> <span class="n">r</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;wrong redeemer&quot;</span> <span class="o">$</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>In the previous version, the third argument was called <em>ValidatorCtx</em>.
Luckily, we have not yet looked at this argument in detail.</p>
<p>The second change is where we create the scrAddress.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="n">validator</span>
</pre></div>
</div>
<p>Previously, <em>scrAddress</em> was created using <em>ScriptAddress</em> (capital S),
passing in a validator hash. This is because the address type has now
changed in order to allow a component of the address relating to a
staking address. But there is still a smart constructor <em>scriptAddress</em>
(small s).</p>
<p>We don’t need the validator hash anymore. It still exists and we could
compute it, but we don’t need it.</p>
</div>
<div class="section" id="playground-changes">
<h4><span class="section-number">4.1.1.2. </span>Playground Changes<a class="headerlink" href="#playground-changes" title="Permalink to this headline">¶</a></h4>
<p>There have also been some changes in the playground.</p>
<p>One is a pleasant surprise. In previous lectures, we needed to remove
the <em>module</em> header in the script after copy-pasting the code into the
playground. We no longer need to do that.</p>
<p>Another interesting change is that fees are now considered in the
playground. They are not yet realistic. The fees are always 10 lovelace,
but in the real system the fees will depend on the memory consumption
and the time it takes to execute the validators.</p>
<p>But, in any case, as there is now a fee of 10 lovelace, it no longer
makes sense to have examples with such small balances in the wallets.
So, instead of starting with 10 lovelace in each wallet, we should
choose a bigger number, for example 1000.</p>
<p>Let’s look at the changes in the playground.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00000.png" />
</div>
<p>The Genesis transaction is the same, with the exception that the wallets
are now given 1000 lovelace each, rather than 10.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00001.png" />
</div>
<p>Now, we see the <em>give</em> transaction, with an addition fee output of 10
lovelace. This 10 lovelace has been deducted from the UTxO that
represents the change of 300 (1000-700) for wallet 1.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00002.png" />
</div>
<p>Now, the <em>grab</em>. Again, 10 lovelace in fees is deducted from the 700
lovelace that Wallet 2 grabbed.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00003.png" />
</div>
</div>
</div>
</div>
<div class="section" id="recap">
<h2><span class="section-number">4.2. </span>Recap<a class="headerlink" href="#recap" title="Permalink to this headline">¶</a></h2>
<p>When we explained the (E)UTxO model in Lecture One, we mentioned that in
order to unlock a script address, the script attached to the address is
run, and that script gets three pieces of information - the <em>Datum</em>, the
<em>Redeemer</em> and the <em>Context</em>.</p>
<p>In the second lecture, we saw examples of that, and we saw how it
actually works in Haskell.</p>
<p>We saw the low-level implementation, where all three arguments are
represented by the <em>Data</em> type. We also saw that in practice this is not
used.</p>
<p>Instead, we use the typed version, where <em>Datum</em> and <em>Redeemer</em> can be
custom types (as long as they implement the <em>IsData</em> type class), and
where the third argument is of type <em>ScriptContext</em> (previously
<em>ValidatorCtx</em>).</p>
<p>In the examples we have seen so far we have looked at the <em>Datum</em> and
the <em>Redeemer</em>, but we have always ignored the <em>Context</em>. But the
<em>Context</em> is, of course, very important. So, in this lecture we will
start looking at the <em>Context</em>.</p>
</div>
<div class="section" id="scriptcontext">
<h2><span class="section-number">4.3. </span>ScriptContext<a class="headerlink" href="#scriptcontext" title="Permalink to this headline">¶</a></h2>
<p>The <em>ScriptContext</em> type is defined in package <em>plutus-ledger-api</em>,
which is a package that, until now, we haven’t needed. But now we do
need it, and it is included in this week’s cabal.project file. It is
defined in module <em>Plutus.V1.Ledger.Contexts</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span><span class="p">{</span><span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span> <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span> <span class="p">}</span>
</pre></div>
</div>
<p>It is a record type (a Haskell type where the fields are given names,
rather than being referred to only by their position and type, although
it can still be treated in such a manner if desired).</p>
<p>The second field is of type <em>ScriptPurpose</em>, which is defined in the
same module. It defines for which purpose a script is being run.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Purpose of the script that is currently running</span>
<span class="kr">data</span> <span class="kt">ScriptPurpose</span>
   <span class="ow">=</span> <span class="kt">Minting</span> <span class="kt">CurrencySymbol</span>
   <span class="o">|</span> <span class="kt">Spending</span> <span class="kt">TxOutRef</span>
   <span class="o">|</span> <span class="kt">Rewarding</span> <span class="kt">StakingCredential</span>
   <span class="o">|</span> <span class="kt">Certifying</span> <span class="kt">DCert</span>
</pre></div>
</div>
<p>For us, the most important is <em>Spending</em>. This is what we have talked
about so far in the context of the (E)UTxO model. This is when a script
is run in order to validate a spending input for a transaction.</p>
<p>The <em>Minting</em> purpose comes into play when you want to define a native
token. Its purpose us to describe under which circumstances the native
token can be minted or burned.</p>
<p>There are also two new brand new purposes - <em>Rewarding</em> - related to
staking and <em>Certifying</em> - related to stake delegation.</p>
<p>The most interesting field is <em>scriptContextTxInfo</em> which is of type
<em>TxInfo</em>, also defined in the same module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | A pending transaction. This is the view as seen by validator scripts, so some details are stripped out.</span>
<span class="kr">data</span> <span class="kt">TxInfo</span> <span class="ow">=</span> <span class="kt">TxInfo</span>
   <span class="p">{</span> <span class="n">txInfoInputs</span>      <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span> <span class="c1">-- ^ Transaction inputs</span>
   <span class="p">,</span> <span class="n">txInfoInputsFees</span>  <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span>     <span class="c1">-- ^ Transaction inputs designated to pay fees</span>
   <span class="p">,</span> <span class="n">txInfoOutputs</span>     <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">]</span> <span class="c1">-- ^ Transaction outputs</span>
   <span class="p">,</span> <span class="n">txInfoFee</span>         <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The fee paid by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoForge</span>       <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The &#39;Value&#39; forged by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoDCert</span>       <span class="ow">::</span> <span class="p">[</span><span class="kt">DCert</span><span class="p">]</span> <span class="c1">-- ^ Digests of certificates included in this transaction</span>
   <span class="p">,</span> <span class="n">txInfoWdrl</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">StakingCredential</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span> <span class="c1">-- ^ Withdrawals</span>
   <span class="p">,</span> <span class="n">txInfoValidRange</span>  <span class="ow">::</span> <span class="kt">SlotRange</span> <span class="c1">-- ^ The valid range for the transaction.</span>
   <span class="p">,</span> <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">]</span> <span class="c1">-- ^ Signatures provided with the transaction, attested that they all signed the tx</span>
   <span class="p">,</span> <span class="n">txInfoData</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)]</span>
   <span class="p">,</span> <span class="n">txInfoId</span>          <span class="ow">::</span> <span class="kt">TxId</span>
   <span class="c1">-- ^ Hash of the pending transaction (excluding witnesses)</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
</pre></div>
</div>
<p>It describes the spending transaction. In the (E)UTxO model, the context
of validation is the spending transaction and its inputs and outputs.
This context is expressed in the <em>TxInfo</em> type.</p>
<p>In particular you will see the list of all the inputs (<em>txInfoInputs</em>)
and the list of all the outputs (<em>txInfoOutputs</em>), whose types provide a
variety of fields to drill into each individual input or output.</p>
<p>We also see fields for fees <em>txFee</em>, the forge value <em>txInfoForge</em>, used
when minting or burning native tokens.</p>
<p>The field <em>txInfoValidRange</em>, which we will come to in a moment, defines
the slot range for which this transaction is valid.</p>
<p>The <em>txInfoData</em> field is a list associating <em>Datums</em> with their
respective hashes. If there is a transaction output to a script address
that carries some <em>Datum</em>, you don’t need to include the <em>Datum</em>, you
can just include the <em>Datum</em> hash. However, you can optionally attach
the <em>Datum</em>, in which case it will be done in the <em>txInfoData</em> list.</p>
<p>The <em>txInfoId</em> field is a hash of the transaction including all its
inputs and outputs.</p>
<div class="section" id="txinfovalidrange">
<h3><span class="section-number">4.3.1. </span>txInfoValidRange<a class="headerlink" href="#txinfovalidrange" title="Permalink to this headline">¶</a></h3>
<p>While there is a lot of information contained in this <em>txInfo</em> type, for
our first example of how to use the third argument to validation, we
will concentrate on the <em>txInfoValidRange</em> field.</p>
<p>This brings us to an interesting dilemma. We have stressed several times
that the big advantage that Cardano has over something like Ethereum is
that validation can happen in the wallet. But we have also noted that a
transaction can still fail on-chain following validation if, when the
transaction arrives on the blockchain, it has been consumed already by
someone else. In this case, the transaction fails without having to pay
fees.</p>
<p>What should never happen under normal circumstances is that a validation
script runs and then fails. This is because you can always run the
validation under exactly the same conditions in the wallet, so it would
fail before you ever submit it.</p>
<p>So that is a very nice feature, but it is not obvious how to manage time
in that context. Time is important, because we want to be able to
express that a certain transaction is only valid before or only valid
after a certain time has been reached.</p>
<p>We saw an example of this in lecture one - the auction example, where
bids are only allowed until the deadline has been reached, and the
<em>close</em> endpoint can only be called after the deadline has passed.</p>
<p>That seems to be a contradiction, because time is obviously flowing. So,
when you try to validate a transaction that you are constructing in your
wallet, the time that you are doing that can, of course, be different
than the time that the transaction arrives at a node for validation. So,
it’s not clear how to bring these two together so that validation is
deterministic, and to guarantee that if, and only if, validation
succeeds in the wallet, it will also succeed at the node.</p>
<p>The way Cardano solves that, is by adding the slot range field
<em>txInfoValidRange</em> to a transaction, which essentially says “This
transaction is valid between <em>this</em> and <em>that</em> slot”.</p>
<p>When a transaction gets submitted to the blockchain and validated by a
node, then before any scripts are run, some general checks are made, for
example that all inputs are present and that the balances add up, that
the fees are included and so on. One of those checks is to check that
the slot range is valid.</p>
<p>This means that we are completely deterministic again because if the
script is run, we know that we are within the valid slot range.</p>
<p>By default, a script will use the infinite slot range, one that covers
all slots until the end of time, but we do have the option to set a
different slot range, and that is what we have to do if we deal with
time-critical smart contracts, like in the auction example.</p>
<p>So, let’s look at this slot range type in more detail.</p>
</div>
<div class="section" id="slot">
<h3><span class="section-number">4.3.2. </span>Slot<a class="headerlink" href="#slot" title="Permalink to this headline">¶</a></h3>
<p>One relevant module, found in package <em>plutus-ledger-api</em> is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span>
</pre></div>
</div>
<p>When we look at the file in which <em>Slot</em> is defined, we see that it is a
type wrapper around <em>Integer</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | The slot number. This is a good proxy for time, since on the Cardano blockchain</span>
<span class="c1">-- slots pass at a constant rate.</span>
<span class="kr">newtype</span> <span class="kt">Slot</span> <span class="ow">=</span> <span class="kt">Slot</span> <span class="p">{</span> <span class="n">getSlot</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="p">}</span>
   <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Haskell</span><span class="o">.</span><span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
   <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">FromJSONKey</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToJSONKey</span><span class="p">,</span> <span class="kt">NFData</span><span class="p">)</span>
   <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="kt">Num</span><span class="p">,</span> <span class="kt">AdditiveSemigroup</span><span class="p">,</span> <span class="kt">AdditiveMonoid</span><span class="p">,</span> <span class="kt">AdditiveGroup</span><span class="p">,</span> <span class="kt">Enum</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Real</span><span class="p">,</span> <span class="kt">Integral</span><span class="p">,</span> <span class="kt">Serialise</span><span class="p">,</span> <span class="kt">Hashable</span><span class="p">,</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to construct a value of type <em>Slot</em>, we can use the <em>Slot</em>
constructor, but it’s even easier if you look at the implemented type
classes, where we can see that it also implements the <em>Num</em> type class,
which means that we can use numeric literals, so we can simply write 17,
for example, rather than “Slot 17”, or “Slot {getSlot=17}”.</p>
<p>The definition of <em>SlotRange</em> is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | An &#39;Interval&#39; of &#39;Slot&#39;s.</span>
<span class="kr">type</span> <span class="kt">SlotRange</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="kt">Slot</span>
</pre></div>
</div>
<p>So <em>SlotRange</em> is an <em>Interval Slot</em> - so what is <em>Interval</em>? That is
defined in a module in the same package - <em>plutus-ledger-api</em>.</p>
<p>This is more general and is not necessarily for <em>Slot</em>s. Here, we are
only concerned with the case where the type variable <em>a</em> is <em>Slot</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">--   The interval can also be unbounded on either side.</span>
<span class="kr">data</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">{</span> <span class="n">ivFrom</span> <span class="ow">::</span> <span class="kt">LowerBound</span> <span class="n">a</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">::</span> <span class="kt">UpperBound</span> <span class="n">a</span> <span class="p">}</span>
   <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Haskell</span><span class="o">.</span><span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
   <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Serialise</span><span class="p">,</span> <span class="kt">Hashable</span><span class="p">,</span> <span class="kt">NFData</span><span class="p">)</span>
</pre></div>
</div>
<p>There are some slight complications. For example, you can specify
whether one or both of the bounds are inclusive, and you have the
special case where the upper bound is infinity and the case where the
lower bound is the beginning of time.</p>
<p>Normally, we don’t have to deal with types directly because we have nice
helper functions. The most general of these helper functions is probably
the <em>interval</em> function, which takes an inclusive lower bound and an
inclusive upper bound and constructs an interval from those values.</p>
<p>The comment on this function in the commit we are working with in this
lecture is incorrect - it claims that the upper bound is not inclusive,
but it actually is.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">interval</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">interval</span> <span class="n">s</span> <span class="n">s&#39;</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also the <em>singleton</em> helper, which constructs an interval which
consists of just one slot.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">singleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">singleton</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">interval</span> <span class="n">s</span> <span class="n">s</span>
</pre></div>
</div>
<p>We have <em>from</em> which constructs an <em>Interval</em> starting from a given slot
and extending to the end of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">from</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">from</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have <em>to</em>, which is the opposite. It constructs an <em>Interval</em>
starting from the genesis block up to, and including, the given slot.
Again, the comments in the code for the commit we are working with
claims that it is not inclusive, but it is.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">to</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">to</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>We have <em>always</em> which contains all slots from the beginning of time
until the end of eternity. This is the default.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">always</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">always</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have the opposite, <em>never</em>, which contains no slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">never</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">never</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to these helper functions for constructing values of type
<em>Interval</em>, we have various helpers for working with <em>Interval</em>s.</p>
<p>The <em>member</em> function checks whether a value is contained within an
<em>Interval</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">member</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">member</span> <span class="n">a</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">i</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">singleton</span> <span class="n">a</span>
</pre></div>
</div>
<p>The <em>overlaps</em> function checks whether two intervals overlap, that is,
whether there is a value that is a member of both intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">overlaps</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">overlaps</span> <span class="n">l</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">isEmpty</span> <span class="p">(</span><span class="n">l</span> <span class="p">`</span><span class="n">intersection</span><span class="p">`</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>intersection</em> function determines the largest interval that is
contained in both the given intervals. This is an <em>Interval</em> that starts
from the largest lower bound of the two intervals and extends until the
smallest upper bound.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">intersection</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">intersection</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <em>hull</em> gives the smallest interval containing both the
given intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hull</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">hull</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">min</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">max</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>contains</em> function takes two intervals and determines if the second
interval is completely contained within the first one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">contains</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">contains</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">l2</span> <span class="o">&amp;&amp;</span> <span class="n">h2</span> <span class="o">&lt;=</span> <span class="n">h1</span>
</pre></div>
</div>
<p>And we have the <em>before</em> and <em>after</em> functions to determine if a given
<em>Slot</em> is before or after a given <em>Interval</em>, respectively.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">before</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">before</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">f</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lowerBound</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">f</span>

<span class="nf">after</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">after</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="kr">_</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">upperBound</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">t</span>
</pre></div>
</div>
<p>Let’s have a play in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Slot</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Interval</span>
</pre></div>
</div>
<p>There are two ways to define a slot. First, you can use the <em>Slot</em>
constructor.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<p>Secondly, you can just write it as an <em>Integer</em>, but in this case you
need to tell the compiler what type it is.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">::</span> <span class="kt">Slot</span>
<span class="kt">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<p>Let’s use some of the helper functions for constructing intervals. This
will give us slots 3,4,5,6,7,8,9,10:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">interval</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="p">(</span><span class="kt">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">}))</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="p">(</span><span class="kt">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="ow">=</span> <span class="mi">10</span><span class="p">}))</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>You see that there are two finite slots defined as the lower and upper
bounds, and that they both have the value <em>True</em>, which indicates that
they are both inclusive bounds.</p>
<p>We can check whether a slot is a member of an interval:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">5</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">11</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>We can use the <em>from</em> constructor. Here we see that the lower bound is
again a finite slot, but that the upper bound is positive infinity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">20</span><span class="p">)</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="p">(</span><span class="kt">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="ow">=</span> <span class="mi">20</span><span class="p">}))</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>And we can check slots for membership of this interval:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">20</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">20</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">19</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">20</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">1000000</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">20</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>And the <em>to</em> constructor. Here we see that now the lower bound is
negative infinity, while the upper bound is a finite slot number.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">to</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="p">(</span><span class="kt">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="ow">=</span> <span class="mi">100</span><span class="p">}))</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>And let’s check various slots for membership:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">7</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">100</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">101</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>Now, let’s try the <em>contains</em> function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">50</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">110</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>And <em>overlaps</em>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">110</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Slot</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="kt">Slot</span> <span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">101</span> <span class="mi">110</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>And now, we can look, for the first time, at a contract that actually
looks at the third validation argument, the <em>Context</em>, and does
something interesting with it.</p>
</div>
</div>
<div class="section" id="example-vesting">
<h2><span class="section-number">4.4. </span>Example - Vesting<a class="headerlink" href="#example-vesting" title="Permalink to this headline">¶</a></h2>
<p>Imagine you want to give a gift of Ada to a child. You want the child to
own the Ada, but you only want the child to have access to it he or she
turns eighteen.</p>
<p>Using Plutus, it is very easy to implement a vesting scheme like that.</p>
<p>We start by copying the IsData function, the one we modified at the
start of the lecture, into a new module called Vesting.</p>
<p>The first step is to think about the <em>Datum</em> and <em>Redeemer</em>.</p>
<p>For <em>Datum</em> it makes sense to have two pieces of information:</p>
<ul class="simple">
<li><p>The beneficiary</p></li>
<li><p>The deadline</p></li>
</ul>
<p>So, let’s define this type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingDatum</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
   <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">Slot</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;VestingDatum</span>
</pre></div>
</div>
<p>In this case, we don’t need any information in the <em>Redeemer</em>, because
all the information we need about the entity that can claim the Ada and
the time is contained in the <em>Context</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingDatum</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>We need to check two conditions.</p>
<ol class="arabic simple">
<li><p>That only the correct beneficiary can unlock a UTxO sitting at this
address. This we can validate by checking that the beneficiary’s
signature is included in the transaction.</p></li>
<li><p>That this transaction is only executed after the deadline is reached.</p></li>
</ol>
<p>We could probably just write this in one go, but we will write it in a
more top-down fashion and delegate to some helper functions.</p>
<p>Let’s start by writing the conditions without implementing them and by
also giving appropriate error messages.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">checkSig</span>      <span class="o">&amp;&amp;</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span>            <span class="n">checkDeadline</span>
<span class="kr">where</span>
   <span class="o">...</span>
   <span class="n">checkSig</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="o">...</span>
   <span class="n">checkDeadline</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>Let’s look back at the <em>ScriptContext</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span><span class="p">{</span><span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span> <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span> <span class="p">}</span>
</pre></div>
</div>
<p>We are not interest in the script purpose, as we know that it is a
spending script. The interesting one for us here is <em>TxInfo</em>, as this
provides both the signatures and the timing information.</p>
<p>So let’s add a helper function that gets this for us from our third
argument - <em>ctx</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">checkSig</span>      <span class="o">&amp;&amp;</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span>            <span class="n">checkDeadline</span>
<span class="kr">where</span>
   <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
   <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>
   <span class="o">...</span>
   <span class="n">checkSig</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="o">...</span>
   <span class="n">checkDeadline</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>For the first helper function, <em>checkSig</em>, we must check that the
beneficiary has signed the transaction.</p>
<p>Here we use the <code class="docutils literal notranslate"><span class="pre">elem</span></code> function here from the Plutus Prelude, which is
a copy of the same function from the standard Prelude. You will recall
that this is because it is not possible to make functions in standard
Prelude INLINABLE, which is required for our validation scripts to
compile.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkSig</span> <span class="ow">=</span> <span class="n">beneficiary</span> <span class="n">dat</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">txInfoSignatories</span> <span class="n">info</span>
</pre></div>
</div>
<p>To check the deadline we need the <em>txInfoValidRange</em> field of <em>TxInfo</em>,
which gives us a value of type <em>SlotRange</em>.</p>
<p>We must check that this transaction is only submitted once the deadline
has been reached.</p>
<p>As we saw before, the way time is handled is that, during validation,
before any script is run, it is checked that this range that the
transaction gives actually includes the current slot.</p>
<p>We don’t know exactly what the current slot is because the interval may
be large, but what we do know is that one of those slots is the current
time.</p>
<p>So, in order to make sure that the deadline has been reached, we must
check that all the slots in the slot range are after the deadline. And
one way to do this, is to ask if the valid slot range is included in the
interval that starts at the deadline and extends to the end of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkDeadline</span> <span class="ow">=</span> <span class="n">from</span> <span class="p">(</span><span class="n">deadline</span> <span class="n">dat</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>Remember that if the current slot was not in the <em>txInfoValidRange</em>,
then the validation script would not even be running.</p>
<p>That completes the validation logic. Let’s take care of some
boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Vesting</span> <span class="kr">where</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">inst</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Vesting</span>
<span class="nf">inst</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Vesting</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
   <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">VestingDatum</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>We will focus more on the wallet part of the script later, but here are
the changes.</p>
<p>We have created a <em>GiveParams</em> type, and modified the <em>grab</em> endpoint to
require no parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GiveParams</span> <span class="ow">=</span> <span class="kt">GiveParams</span>
   <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
   <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">VestingSchema</span> <span class="ow">=</span>
   <span class="kt">BlockchainActions</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">GiveParams</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>For the <em>give</em> endpoint, the <em>Datum</em> is constructed from the
<em>GiveParams</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">HasBlockchainActions</span> <span class="n">s</span><span class="p">,</span> <span class="kt">AsContractError</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">GiveParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">gp</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="kr">let</span> <span class="n">dat</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
               <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span>
               <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">gpDeadline</span> <span class="n">gp</span>
               <span class="p">}</span>
      <span class="n">tx</span>  <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="n">dat</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="n">gpAmount</span> <span class="n">gp</span>
   <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="n">inst</span> <span class="n">tx</span>
   <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
   <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace to %s with deadline %s&quot;</span>
      <span class="p">(</span><span class="n">gpAmount</span> <span class="n">gp</span><span class="p">)</span>
      <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span><span class="p">)</span>
      <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpDeadline</span> <span class="n">gp</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>grab</em> endpoint is a bit more involved. Here, the grabber needs to
find the UTxOs that they can actually consume, which is performed by the
<em>isSuitable</em> helper function.</p>
<p>This looks at the all UTxOs and only keeps those that are suitable. It
first checks that the <em>Datum</em> hash exists, nad, if so, it deserialises
it, and, if that succeeds it checks that the beneficiary of the UTxO is
the public key hash of the grabber. It then checks that the deadline is
not in the future.</p>
<p>We see here that, from the wallet, we have access to the current slot
and to our own public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="p">(</span><span class="kt">HasBlockchainActions</span> <span class="n">s</span><span class="p">,</span> <span class="kt">AsContractError</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">now</span>   <span class="ow">&lt;-</span> <span class="n">currentSlot</span>
   <span class="n">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
   <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="n">scrAddress</span>
   <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="n">utxos</span>
      <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;no gifts available&quot;</span>
      <span class="kr">else</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
               <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>  <span class="o">&lt;&gt;</span>
                        <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">validator</span>
               <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
               <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span> <span class="o">&lt;&gt;</span>
                        <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
<span class="kr">where</span>
   <span class="n">isSuitable</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Slot</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
   <span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span> <span class="n">o</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">txOutDatumHash</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
      <span class="kt">Just</span> <span class="n">h</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">h</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span> <span class="kr">of</span>
            <span class="kt">Nothing</span>        <span class="ow">-&gt;</span> <span class="kt">False</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="kt">Datum</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">e</span> <span class="kr">of</span>
               <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
               <span class="kt">Just</span> <span class="n">d</span>  <span class="ow">-&gt;</span> <span class="n">beneficiary</span> <span class="n">d</span> <span class="o">==</span> <span class="n">pkh</span> <span class="o">&amp;&amp;</span> <span class="n">deadline</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">now</span>
</pre></div>
</div>
<p>Note the call:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
</pre></div>
</div>
<p>If we do not do this, the default would be the infinite slot range, and
this would cause validation to fail in our case.</p>
<p>We could use a singleton slot here, but, if there were any issues, for
example network delays, and the transaction arrived at a node a slot or
two later, then validation would no longer work.</p>
<p>Another thing to note is that, if there is no suitable UTxO available,
we don’t even try to submit the transaction. We want to make sure that
when the grabber submits, they get something in return. Otherwise they
would have to pay fees for a transaction that doesn’t have any outputs.</p>
<div class="section" id="in-the-playground">
<h3><span class="section-number">4.4.1. </span>In the playground<a class="headerlink" href="#in-the-playground" title="Permalink to this headline">¶</a></h3>
<p>First, let’s get Wallet 1 to send some lovelace.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00004.png" />
</div>
<p>Here we run into a technical problem. We need to supply the beneficiary
address, but there is no way in the playground to get the public key
hash of a wallet.</p>
<p>But we can get it from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Wallet.Emulator</span>
<span class="kt">Prelude</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger</span>
<span class="kt">Prelude</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">2</span>
<span class="mi">39</span><span class="n">f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f</span>
</pre></div>
</div>
<p>Let’s create a scenario where validation passes. Wallet 1 gives 500
lovelace with a deadline of slot 15. We wait for 15 slots, and then
Wallet 2 grabs.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00005.png" />
</div>
<p>After evaluation, we see the Genesis transaction, plus the give and the
grab transactions.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00006.png" />
</div>
<div class="figure align-default">
<img alt="" src="_images/week03__00007.png" />
</div>
<div class="figure align-default">
<img alt="" src="_images/week03__00008.png" />
</div>
<p>And the final balances.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00009.png" />
</div>
<p>Now let’s look at the case where the grab happens too early. We’ll
change the wait time to 14 slots.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00010.png" />
</div>
<p>Now we see just two transactions - the Genesis transaction, and the
give.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00012.png" />
</div>
<p>The grab transaction has failed validation.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00013.png" />
</div>
</div>
</div>
<div class="section" id="example-2-parameterized-contract">
<h2><span class="section-number">4.5. </span>Example 2 - Parameterized Contract<a class="headerlink" href="#example-2-parameterized-contract" title="Permalink to this headline">¶</a></h2>
<p>Our next example will be parameterized contracts, but let’s start with
an observation about our existing contract.</p>
<div class="section" id="an-observation">
<h3><span class="section-number">4.5.1. </span>An Observation<a class="headerlink" href="#an-observation" title="Permalink to this headline">¶</a></h3>
<p>We will set up a scenario where both wallets give and both wallets grab.</p>
<p>Again, in this example, the public key hash of Wallet 1’s address was
obtained from the REPL in the same way as with the Wallet 2 example
above.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00014.png" />
</div>
<p>After evaluation…</p>
<p>The Genesis transaction, as always.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00015.png" />
</div>
<p>The give of Wallet 2…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00016.png" />
</div>
<p>The give of Wallet 1…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00017.png" />
</div>
<p>The grab of Wallet 2…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00018.png" />
</div>
<p>And, the grab of Wallet 1…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00019.png" />
</div>
<p>Now, what we want to focus on here is the script addresses for the give
of Wallet 1 and the give of Wallet 2. If you look back at those
screenshots, you will notice that the script address in both cases is
the same.</p>
<p>And this is not surprising. Recall that the address of the script is
calculated by taken the hash of the compiled Plutus code of the
validator. Since the same validator is being used in both those
transactions, the script address is the same.</p>
<p>Keep this in mind for what we are about to cover in the following
section.</p>
</div>
<div class="section" id="another-way-of-doing-it">
<h3><span class="section-number">4.5.2. </span>Another Way of Doing It<a class="headerlink" href="#another-way-of-doing-it" title="Permalink to this headline">¶</a></h3>
<p>In our example, we have put the beneficiary and the deadline into the
datum. But there are other choices.</p>
<p>You could also parameterize the whole script on those two pieces of data
- the beneficiary and the deadline.</p>
<p>A parameterized script is like a family of scripts. You can instantiate
it with different parameters, and you get different scripts. They all
behave the same, but they have these different parameters.</p>
<p>We start by making a copy of Vesting.hs and creating a new module -
Week03.Parameterized.</p>
<p>Now, instead of using the <em>VestedDatum</em>, we are going to parameterize
the script with it. It makes sense to first change its name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingParam</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
   <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">Slot</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>Next, we will return to using Unit as our datum type, but we will add a
new validation argument, before the other arguments, of our new type
<em>VestingParam</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The idea is that mkValidator is now a function that takes a VestingParam
and returns a custom validator based on those params.</p>
<p>We don’t need to change much, just the function header and the parts
that previously accessed the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="n">p</span> <span class="nb">()</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">checkSig</span>      <span class="o">&amp;&amp;</span>
   <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span>            <span class="n">checkDeadline</span>
<span class="kr">where</span>
   <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
   <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

   <span class="n">checkSig</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="n">checkSig</span> <span class="ow">=</span> <span class="n">beneficiary</span> <span class="n">p</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">txInfoSignatories</span> <span class="n">info</span>

   <span class="n">checkDeadline</span> <span class="ow">::</span> <span class="kt">Bool</span>
   <span class="n">checkDeadline</span> <span class="ow">=</span> <span class="n">from</span> <span class="p">(</span><span class="n">deadline</span> <span class="n">p</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>And, we need to change another piece of code that previously referenced
the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Vesting</span> <span class="kr">where</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>And now we come to an interesting question. What do we do here?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inst</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Vesting</span>
<span class="nf">inst</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Vesting</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
   <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">VestingDatum</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>As is, this won’t work because now <em>mkValidator</em> has the wrong type.
Remember that it must be a function that takes three arguments and
returns a boolean. But now, it has four arguments.</p>
<p>Also, we won’t always get the same instance, so this must now become a
function that takes <em>VestingParam</em> as an argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inst</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Vesting</span>
<span class="nf">inst</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Vesting</span>
</pre></div>
</div>
<p>The first idea would be to simply do something like this - adding the
<em>p</em> as a parameter, which would make the type correct again.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- this won&#39;t work</span>
<span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="n">p</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>But the problem is that, as we have seen before, in Template Haskell,
the things inside the Oxford Brackets must be known at compile time, but
the value of <em>p</em> here will not be known until runtime.</p>
<p>Luckily, there is a way around this.</p>
<p>We have something called applyCode, which takes two Plutus scripts, and,
assuming that the first one is a function, it applies this function to
the second argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- partial code</span>
<span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="c1">-- ...</span>
</pre></div>
</div>
<p>So, now, this…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>…is now a Plutus script for a function that takes such a parameter.
So, now, we must write a Plutus script for that parameter. Then
<em>applyCode</em> will apply the function to the script for the parameter, and
we will get a script of the right type out of that.</p>
<p>But this looks like it still doesn’t solve the problem because what do
we write after <em>applyCode</em>? How do we get the parameter there. We can’t
use PlutusTx.compile, as we have already seen.</p>
<p>This is where another important class comes in - the so-called <em>Lift</em>
class.</p>
<div class="section" id="the-lift-class">
<h4><span class="section-number">4.5.2.1. </span>The Lift Class<a class="headerlink" href="#the-lift-class" title="Permalink to this headline">¶</a></h4>
<p>The <em>Lift</em> class is defined in package <em>plutus-tx</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift.Class</span>
</pre></div>
</div>
<p>It only has one function, <em>Lift</em>. However, we won’t use this function
directly.</p>
<p>The importance of the class is that it allows us to, at runtime, lift
Haskell values into corresponding Plutus script values. And this is
exactly what we need to convert our parameter <em>p</em> into code.</p>
<p>We will use a different function, defined in the same package but in a
different module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift</span>
</pre></div>
</div>
<p>The function we will use is called <em>liftCode</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Get a Plutus Core program corresponding to the given value as a &#39;CompiledCodeIn&#39;, throwing any errors that occur as exceptions and ignoring fresh names.</span>
<span class="nf">liftCode</span>
   <span class="ow">::</span> <span class="p">(</span><span class="kt">Lift</span><span class="o">.</span><span class="kt">Lift</span> <span class="n">uni</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Throwable</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">PLC</span><span class="o">.</span><span class="kt">ToBuiltinMeaning</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">)</span>
   <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">CompiledCodeIn</span> <span class="n">uni</span> <span class="n">fun</span> <span class="n">a</span>
<span class="nf">liftCode</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">unsafely</span> <span class="o">$</span> <span class="n">safeLiftCode</span> <span class="n">x</span>
</pre></div>
</div>
<p>It takes a Haskell value of type <em>a</em>, provided <em>a</em> is an instance of the
<em>Lift</em> class, and turns it into a piece of Plutus script code
corresponding to the same type.</p>
<p>So, let’s use that.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>There is still a problem, however. We need a <em>Lift</em> instance for <em>p</em>.</p>
<p>Luckily, similar to how we got an instance for <em>IsData</em> there is also a
Template Haskell function for <em>Lift</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">makeLift</span> <span class="kt">&#39;&#39;VestingParam</span>
</pre></div>
</div>
<p>But, it still won’t compile. We need another GHC extension.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
</pre></div>
</div>
<p>Now we have to some more little modifications.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">validator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">inst</span>

<span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">validator</span>
</pre></div>
</div>
<p>Changes are also necessary in the wallet part.</p>
<p>The <em>GiveParams</em> stay the same, but the endpoints are slightly
different, because in the <em>grab</em> endpoint earlier we only had the Unit
argument, but now we need the slot.</p>
<p>This is because, in order to construct the address that we grab from, we
need the params - the beneficiary and the deadline. We already now the
beneficiary, as it will be the address of the wallet that is doing the
grabbing, but we need to pass in the slot value for the deadline.</p>
<p>In the <em>give</em> endpoint, there are also some differences.</p>
<p>Whenever we need an <em>inst</em> we must pass in the params.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">inst</span> <span class="n">p</span><span class="p">)</span> <span class="n">tx</span>
</pre></div>
</div>
<p>And in the <em>grab</em> endpoint, we have the additional parameter.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="n">d</span> <span class="ow">=</span> <span class="kr">do</span>
</pre></div>
</div>
<p>And we can use that to construct the parameters, along with our own
public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
            <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">d</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>And again, when we use something like <em>scrAddress</em>, we need to pass in
the parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">scrAddress</span> <span class="n">p</span>
</pre></div>
</div>
<p>Now, the good thing with this is that we don’t need the filter helper
function <em>isSuitable</em> anymore. Previously, we got all the UTxOs sitting
at the script address and filtered them based on beneficiary and
deadline. But now, it’s much easier because the script is already
parameterized by beneficiary, so we know that this script will only hold
UTxOs that are for us.</p>
<p>So, all we need to do is to check that <em>now</em> is not earlier than the
deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">d</span>
   <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;too early&quot;</span>
   <span class="kr">else</span> <span class="kr">do</span>
   <span class="o">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="back-to-the-playground">
<h3><span class="section-number">4.5.3. </span>Back to the playground<a class="headerlink" href="#back-to-the-playground" title="Permalink to this headline">¶</a></h3>
<p>If we copy paste this new contract into the playground and setup the
same scenario as before…</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00020.png" />
</div>
<p>We can see that now, one of the disadvantages to doing it this way is
that the wallets now need to know the deadline in order to construct the
script address.</p>
<p>If you evaluate this, you will see that it succeeds.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00021.png" />
</div>
<p>But now, compare the script address that Wallet 1 sends to with the
script address that Wallet 2 sends to.</p>
<div class="figure align-default">
<img alt="" src="_images/week03__00022.png" />
</div>
<p>They are now different. The UTxOs are being held at different addresses.</p>
<p>This is because of the parameters. The same script but with different
parameters will have a different hash.</p>
<p>Whether this is a good thing or a bad thing will depend on the use case.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week4.html" class="btn btn-neutral float-right" title="5. Week 04 - Monads" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="week2.html" class="btn btn-neutral float-left" title="3. Week 02 - Validation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
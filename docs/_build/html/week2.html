

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>3. Week 02 - Validation &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Week 03 - Script Context" href="week3.html" />
    <link rel="prev" title="2. Week 01 - Introduction" href="week1.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="week1.html">2. Week 01 - Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Week 02 - Validation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">3.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plutustx-data">3.2. PlutusTx.Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plutus-validator">3.3. Plutus Validator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-1-the-gift-contract">3.3.1. Example 1 - The Gift Contract</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-2-burn">3.3.2. Example 2 - Burn</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-3-forty-two">3.3.3. Example 3 - Forty Two</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-4-typed">3.3.4. Example 4 - Typed</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-5-custom-isdata-types">3.3.5. Example 5 - Custom IsData types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="week3.html">4. Week 03 - Script Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="week4.html">5. Week 04 - Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="week5.html">6. Week 05 - Native Tokens</a></li>
<li class="toctree-l1"><a class="reference internal" href="week6.html">7. Week 06 - Oracles</a></li>
<li class="toctree-l1"><a class="reference internal" href="week7.html">8. Week 07 - State Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="week8.html">9. Week 08 - Property Based Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="week9.html">10. Week 09 - Marlowe</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">3. </span>Week 02 - Validation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week2.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-02-validation">
<h1><span class="section-number">3. </span>Week 02 - Validation<a class="headerlink" href="#week-02-validation" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://youtu.be/E5KRk5y9KjQ">Lecture
#2</a>.</p>
<p>It covers low-level, untyped on-chain validation scripts and high-level,
typed on-chain validation scripts.</p>
</div>
<div class="section" id="introduction">
<h2><span class="section-number">3.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>We saw in the first lecture that there are two sides to a smart contract
- an on-chain part and an off-chain part.</p>
<p>The on-chain part is about validation. It allows nodes to validate a
given transaction and whether it is allowed to consume a given UTxO.</p>
<p>The off-chain part lives in the user’s wallet. It constructs and submits
suitable transactions.</p>
<p>Both are important topics. We have to master both in order to write
smart contracts, but for now we will concentrate on the on-chain part.</p>
<p>Let’s recall the Extended UTxO model where the idea is that we introduce
a new type of address.</p>
<div class="figure align-default">
<img alt="_images/1.png" src="_images/1.png" />
</div>
<p>In the simple UTxO model are so-called public key addresses, where the
address is given by the hash of the public key. If a UTxO sits at such a
public key address, then a transaction can consume that UTxO as an input
if the signature belonging to that public key is included in the
transaction.</p>
<p>What the (E)UTxO model does is extend this by adding script addresses
that can run arbitrary logic.</p>
<p>When a transaction wants to consume a UTxO sitting at a script address
is validated by a node, the node will run the script and then, depending
on the result of the script, decide whether the transaction is valid or
not.</p>
<p>And recall that there were three more additions:</p>
<ol class="arabic simple">
<li><p>Instead of just having signatures on transactions, we have so-called
Redeemers - arbitrary pieces of data.</p></li>
<li><p>On the UTxO output side, we have an additional arbitrary piece of
data called Datum, which you can think of as a little piece of state
that sits on the UTxO.</p></li>
<li><p>Finally, we have the context. There are various choices of what this
context can be. It can be very restrictive, consisting just of the
Redeemer (as in Bitcoin), or very global, consisting of the whole
state of the blockchain (as in Ethereum). In Cardano, it is the
transaction that is being validated, including all its inputs and
outputs.</p></li>
</ol>
<p>So, there are three pieces of data that a Plutus script gets. The Datum,
sitting at the UTxO, the Redeemer coming from the input and the
validation, and the Context, consisting of the transaction being
validated and its inputs and outputs.</p>
<p>In a concrete implementation like Plutus, these pieces of information
need to be represented by a concrete data type - a Haskell data type. As
it happens, the choice was made to use the same data type for all three
of them. At least at the low-level implementation.</p>
<p>We will look at that first, but in real life nobody would actually use
this low-level. There are more convenient ways to use more suitable data
types for these things, and we will come to that later in this lecture.</p>
</div>
<div class="section" id="plutustx-data">
<h2><span class="section-number">3.2. </span>PlutusTx.Data<a class="headerlink" href="#plutustx-data" title="Permalink to this headline">¶</a></h2>
<p>As mentioned, the Datum, Redeemer and Context share a data type. That
data type is defined in the package <em>plutus-tx</em>, in the module
<a class="reference external" href="https://github.com/input-output-hk/plutus/blob/master/plutus-tx/src/PlutusTx/Data.hs">*PlutusTx.Data*</a>.
It is called, simply, <em>Data</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Data</span> <span class="ow">=</span>
      <span class="kt">Constr</span> <span class="kt">Integer</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
   <span class="o">|</span> <span class="kt">Map</span> <span class="p">[(</span><span class="kt">Data</span><span class="p">,</span> <span class="kt">Data</span><span class="p">)]</span>
   <span class="o">|</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
   <span class="o">|</span> <span class="kt">I</span> <span class="kt">Integer</span>
   <span class="o">|</span> <span class="kt">B</span> <span class="kt">BS</span><span class="o">.</span><span class="kt">ByteString</span>
   <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
   <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">Serialise</span><span class="p">,</span> <span class="kt">NFData</span><span class="p">)</span>
</pre></div>
</div>
<p>It has five constructors.</p>
<ul class="simple">
<li><p><em>Constr</em> takes an Integer and, recursively, a list of <em>Data</em></p></li>
<li><p><em>Map</em> takes a list of pairs of <em>Data</em>. You can think of this as a
lookup table of key-value pairs where both the key and the value are
of type <em>Data</em></p></li>
<li><p><em>List</em> takes a list of <em>Data</em></p></li>
<li><p><em>I</em> takes a single Integer</p></li>
<li><p><em>B</em> takes a Bytestring</p></li>
</ul>
<p>For those familiar with the JSON format, this is very similar. The
constructors are not exactly the same, but, like JSON, you can represent
numbers, strings, lists of data and key-value pairs. It can represent
arbitrary data, which makes it very suitable for our purpose.</p>
<p>We can also explore this type in the REPL.</p>
<p>From the plutus-pioneers-program repository. Remember that you may need
to start a nix-shell from the Plutus repository before changing into the
week02 directory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">code</span><span class="o">/</span><span class="n">week02</span>
<span class="n">cabal</span> <span class="n">repl</span>
</pre></div>
</div>
<p>You should get a response like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ok</span><span class="p">,</span> <span class="mi">9</span> <span class="n">modules</span> <span class="n">loaded</span><span class="o">.</span>
</pre></div>
</div>
<p>You may also see a whole bunch of warning messages regarding unused
imports, which you can ignore.</p>
<p>From with the REPL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">PlutusTx</span>
<span class="p">:</span><span class="n">i</span> <span class="n">Data</span>
</pre></div>
</div>
<p>This will give information about the type <em>Data</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">PlutusTx.Data</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Data</span>
<span class="kr">type</span> <span class="kt">Data</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">Data</span>
   <span class="ow">=</span> <span class="kt">Constr</span> <span class="kt">Integer</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
   <span class="o">|</span> <span class="kt">Map</span> <span class="p">[(</span><span class="kt">Data</span><span class="p">,</span> <span class="kt">Data</span><span class="p">)]</span>
   <span class="o">|</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
   <span class="o">|</span> <span class="kt">I</span> <span class="kt">Integer</span>
   <span class="o">|</span> <span class="kt">B</span> <span class="n">bytestring</span><span class="o">-</span><span class="mf">0.10</span><span class="o">.</span><span class="mf">12.0</span><span class="kt">:Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Internal</span><span class="o">.</span><span class="kt">ByteString</span>
   <span class="c1">-- Defined in ‘PlutusTx.Data’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Data</span> <span class="c1">-- Defined in ‘PlutusTx.Data’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="kt">Data</span> <span class="c1">-- Defined in ‘PlutusTx.Data’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Data</span> <span class="c1">-- Defined in ‘PlutusTx.Data’</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Now we can play with it. We can use the <em>I</em> constructor to create a
value of type <em>Data</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">I</span> <span class="mi">7</span>
<span class="kt">I</span> <span class="mi">7</span>
</pre></div>
</div>
<p>We can ask for its type, and confirm that it is indeed of type <em>Data</em>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">I</span> <span class="mi">7</span>
<span class="kt">I</span> <span class="mi">7</span> <span class="ow">::</span> <span class="kt">Data</span>
</pre></div>
</div>
<p>The easiest way to create a value of type <em>Data</em> using the <em>B</em>
constructor is to use the GHC Extension <em>OverloadedStrings</em>. This allows
literal strings to be used in place of string-like data types and the
compiler will interpret them as their intended type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">set</span> <span class="o">-</span><span class="kt">XOverloadedStrings</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span>
<span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">Data</span>
</pre></div>
</div>
<p>We can also use more complicated constructors, like Map and List:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Map</span> <span class="p">[(</span><span class="kt">I</span> <span class="mi">7</span><span class="p">,</span> <span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">I</span> <span class="mi">0</span><span class="p">],</span> <span class="kt">I</span> <span class="mi">1000</span><span class="p">)]</span>
<span class="kt">Map</span> <span class="p">[(</span><span class="kt">I</span> <span class="mi">7</span><span class="p">,</span> <span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">I</span> <span class="mi">0</span><span class="p">],</span> <span class="kt">I</span> <span class="mi">1000</span><span class="p">)]</span> <span class="ow">::</span> <span class="kt">Data</span>
</pre></div>
</div>
</div>
<div class="section" id="plutus-validator">
<h2><span class="section-number">3.3. </span>Plutus Validator<a class="headerlink" href="#plutus-validator" title="Permalink to this headline">¶</a></h2>
<p>Now we are ready to implement our very first Validator.</p>
<p>As we know, a validator is a script that takes three pieces of input -
the Datum, the Redeemer and the Context, which, at the lowest level are
represented by the <em>Data</em> data type.</p>
<div class="section" id="example-1-the-gift-contract">
<h3><span class="section-number">3.3.1. </span>Example 1 - The Gift Contract<a class="headerlink" href="#example-1-the-gift-contract" title="Permalink to this headline">¶</a></h3>
<p>We start the script by copy pasting a list of GHC language extensions,
plus some dependency imports.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE DataKinds           #-}</span>
<span class="cm">{-# LANGUAGE FlexibleContexts    #-}</span>
<span class="o">...</span>

<span class="kr">module</span> <span class="nn">Week02.Gift</span> <span class="kr">where</span>

<span class="kr">import</span>           <span class="nn">Control.Monad</span>       <span class="k">hiding</span> <span class="p">(</span><span class="nf">fmap</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Data.Map</span>            <span class="k">as</span> <span class="n">Map</span>
<span class="o">...</span>
<span class="kr">import</span>           <span class="nn">Text.Printf</span>         <span class="p">(</span><span class="nf">printf</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we write the Validator. It is a Haskell function that takes three
arguments, all of type <em>Data</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Somewhat surprisingly, the result of the function is (). This is the
Haskell Unit type, similar to <em>void</em> in some other languages, like C++
or C# or Java - it’s the type that carries no information.</p>
<p>Unit is a built-in type in Haskell and it has just one value, which is
written in the same way as the type itself, as we can see from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="nb">()</span>
<span class="nb">()</span>
</pre></div>
</div>
<p>A function with a return type of () is quite unusual in Haskell. In more
mainstream languages, it is quite common for functions or procedures to
return no value. In these situations, the functions are only important
for their side-effects, such as a Java function that prints something to
the console.</p>
<p>But Haskell is a pure language. If you want side-effects, this will be
shown by the type system. For example if the mkValidator were to perform
any IO, it would have a type signature of:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>This would indicate a function that performs IO side-effects but has no
interesting return value.</p>
<p>But, as we know that the real mkValidator function performs no
side-effects and returns no value, there is really nothing useful that
it can do.</p>
<p>However, there is something that the function can do as well as
returning (), namely it can throw an exception or have an error. And
that’s what Plutus uses.</p>
<p>The idea is that if the mkValidator function does not run into an error
or throw an exception, then validation succeeds. If it throws an error
then validation fails and the transaction is rejected.</p>
<p>Let’s write the simplest Validator that we can.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>The first argument is the Datum, the second argument is the Redeemer and
the third argument is the Context, and the most simple thing we can do
is to completely ignore all three arguments and immediately return Unit.</p>
<p>What this means is that this script address that corresponds to this
Validator doesn’t care about the Datum, it doesn’t care about the
Redeemer, and it doesn’t care about the Context. It will always succeed,
and this means that any transaction can consume the script at this
address as an input.</p>
<p>This function is not yet Plutus code, it is just a Haskell function. In
order to turn it into a Plutus script, we need to compile it.</p>
<p>The result of our compilation to Plutus will be of type <em>Validator</em>.
Below the function in Gift.hs, we add the following code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">validator</span> <span class="ow">::</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="n">mkValidatorScript</span> <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>The mkValidatorScript function takes the type <em>CompiledCode (Data -&gt;
Data -&gt; Data -&gt; ()) -&gt; Validator</em>. In order to create this type, we must
compile the mkValidator script using something called Template Haskell.</p>
<p>Template Haskell is an advanced feature of Haskell that solves a similar
problem as macro systems in other languages. A macro being something
that gets expanded at compile time. Code generating code.</p>
<p>So, with this code</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>We are asking the compiler to write the code for the <em>validator</em>
function at compile time based on our mkValidator function, and then
proceed with the normal compilation.</p>
<p>You do not need to understand very much about Template Haskell to write
Plutus as it is always the same pattern. Once you have seen a couple of
examples, you can more or less just copy and paste.</p>
<p>Template Haskell expects all the code to be available within the Oxford
Brackets - [[ ]]. With more complicated Validators you will likely be
relying on multiple helper functions, and you do not want to have to add
them within the Oxford Brackets.</p>
<p>To avoid this, there is one thing we need to do to the mkValidator
function, and that is to make it inlinable by adding the INLINABLE
pragma.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>You will see this often in Plutus scripts, and it is usually an
indication that a function is meant to be used within a validation
script. All the functions on which the Validator depends must be
inlinable.</p>
<p>Let’s go back to the REPL and take a look at the Validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>:l src/Week02/Gift.hs
Ok, one module loaded.
Prelude Week02.Gift&gt; validator
Validator { &lt;script&gt; }
Prelude Week02.Gift&gt; :t validator
validator
   :: plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts.Validator
</pre></div>
</div>
<p>Back to the code, there are two more types that we want the value of -
the validator hash and the address. These are easy to define now that we
have our validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">valHash</span> <span class="ow">::</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">ValidatorHash</span>
<span class="nf">valHash</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorHash</span> <span class="n">validator</span>

<span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="kt">ScriptAddress</span> <span class="n">valHash</span>
</pre></div>
</div>
<p>Now we have a script address represented as <em>scrAddress</em>.</p>
<p>With the exception of the <em>mkValidator</em> function logic (in our case, one
line), the rest of the code we have written so far is boilerplate and
will be very similar for all Plutus scripts.</p>
<p>In order to actually try this script, we need wallet code. The focus of
this lecture is validation and not wallet code, but briefly, here is the
rest of the code.</p>
<p>Two endpoints are defined. The <em>give</em> endpoint will take an Integer
argument to specify the number of Lovelace that will be deposited to the
contract. The <em>grab</em> endpoint will take no argument and will simply look
for UTxOs at this script address and consume them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">GiftSchema</span> <span class="ow">=</span>
   <span class="kt">BlockchainActions</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">Integer</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="nb">()</span>
</pre></div>
</div>
<p><em>Give</em> takes the Integer argument and uses the helper function
<em>mustPayToOtherScript</em> which takes the <em>valHash</em> and a Datum that, in
this example, is completely ignored. It uses the <em>Datum</em> constructor to
turn a <em>Data</em> into a <em>Datum</em>. In this case the <em>Data</em> is created using
the <em>Constr</em> constructor taking a 0 and an empty list. Finally the
amount to send to the address is specified using the helper function
<em>Ada.lovelaceValueOf</em>.</p>
<p>The transaction is then submitted, the script waits for it to be
confirmed and then prints a log message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">HasBlockchainActions</span> <span class="n">s</span><span class="p">,</span> <span class="kt">AsContractError</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">amount</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="n">mustPayToOtherScript</span> <span class="n">valHash</span> <span class="p">(</span><span class="kt">Datum</span> <span class="o">$</span> <span class="kt">Constr</span> <span class="mi">0</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">amount</span>
   <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTx</span> <span class="n">tx</span>
   <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
   <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace&quot;</span> <span class="n">amount</span>
</pre></div>
</div>
<p>The <em>grab</em> endpoint is a little bit more complicated. We use <em>utxoAt</em>
with our shiny new Plutus script address <em>scrAddress</em> to lookup all the
UTxOs sitting at that address. We then need lookups which will be
explained in a later lecture.</p>
<p>We then define the transaction by using <em>mustSpendScriptOutput</em> for each
UTxO found. We also pass a Redeemer which is completely ignored in our
example, so we can put anything there - in this case a Redeemer created
using the <em>I</em> constructor of type <em>Data</em> will a value of 17.</p>
<p>Again, we submit, wait for confirmation, and then write a log message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="p">(</span><span class="kt">HasBlockchainActions</span> <span class="n">s</span><span class="p">,</span> <span class="kt">AsContractError</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="n">scrAddress</span>
   <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
      <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>      <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">validator</span>
      <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
      <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">I</span> <span class="mi">17</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span>
   <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
   <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
   <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
</pre></div>
</div>
<p>We then have some boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">GiftSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">give&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">grab&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
   <span class="kr">where</span>
   <span class="n">give&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">give</span>
   <span class="n">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;</span>  <span class="n">grab</span>
</pre></div>
</div>
<p>And these last two lines are just for the playground. As we saw in
lecture 1, for example, the <em>mkKnownCurrencies</em> list is used to define
tokens for the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSchemaDefinitions</span> <span class="kt">&#39;&#39;GiftSchema</span>

<span class="nf">mkKnownCurrencies</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>We will now test the Validator in the playground.</p>
<p>Again we are using commit 3746610e53654a1167aeb4c6294c6096d16b0502 of
the Plutus repository. This requires us to remove the <em>module</em> part of
the code before pasting it into the playground editor.</p>
<p>Remove this line</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week02.Gift</span> <span class="kr">where</span>
</pre></div>
</div>
<p>Then, compile the script in the playground and press the <em>Simulate</em>
button.</p>
<div class="figure align-default" id="id1">
<img alt="alt text" src="_images/playground_week2_1.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>And let’s add a third wallet.</p>
<div class="figure align-default" id="id2">
<img alt="alt text" src="_images/playground_week2_2.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>We will create a scenario where wallets 1 and 2 give Lovelace, and
wallet 3 grabs all of it.</p>
<div class="figure align-default" id="id3">
<img alt="alt text" src="_images/playground_week2_3.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>And now click <em>Evaluate</em>. We see that there have been four transactions.
The first one is the Genesis transaction that distributes the initial
funds to the wallets.</p>
<div class="figure align-default" id="id4">
<img alt="alt text" src="_images/playground_week2_4.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>And there are two transactions which occur at Slot 1. They are the two
<em>give</em> transactions.</p>
<p>The first one, Tx 0, is from Wallet 2. We see the two outputs - one
putting 6 Lovelace into the script address (the script address is a hash
of the script), and the other returning the 4 Lovelace change to Wallet
2.</p>
<div class="figure align-default" id="id5">
<img alt="alt text" src="_images/playground_week2_5.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>And the second, Tx 1, is from Wallet 1. Again, with similar output
UTxOs.</p>
<div class="figure align-default" id="id6">
<img alt="alt text" src="_images/playground_week2_6.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>We now have two UTxOs sitting at the script address.</p>
<p>Then we have the <em>grab</em> at Slot 2 triggered by Wallet 3. We see the two
UTxOs from the script as inputs, and the single output of 10 Lovelace to
Wallet 3.</p>
<div class="figure align-default" id="id7">
<img alt="alt text" src="_images/playground_week2_7.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p>And, by scrolling down, we see the final wallet balances.</p>
<div class="figure align-default" id="id8">
<img alt="alt text" src="_images/playground_week2_8.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>As mentioned, this script uses the simplest validator possible, one that
always succeeds. But this stupid little validator may be useful in a
situation where someone wants to donate some Lovelace to the community
and leave it up for grabs!</p>
</div>
<div class="section" id="example-2-burn">
<h3><span class="section-number">3.3.2. </span>Example 2 - Burn<a class="headerlink" href="#example-2-burn" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at the second example of validation, using the Burn module.
We will start with the Burn.hs code being identical to the Gift.hs
script.</p>
<p>Recall that the way a validator indicates failure is by throwing an
error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="nb">()</span>
</pre></div>
</div>
<p>If we load the module in the REPL and look at <em>error</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="ne">error</span>
<span class="ne">error</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>We see the definition for the standard Haskell error function. However,
the one in scope in our code is in fact the following <em>error</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Prelude</span><span class="o">.</span><span class="ne">error</span>
<span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Prelude</span><span class="o">.</span><span class="ne">error</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>In regular Haskell, you have the <em>error</em> function which takes an error
message string and triggers an error.</p>
<p>In Plutus, the <em>error</em> function does not take a string - it just takes
Unit. And that takes us to an important point.</p>
<p>We mentioned earlier that we use the INLINABLE pragma on the
<em>mkValidator</em> function in order to allow it to be used by the Template
Haskell code. In Haskell there are many functions available via the
<em>Prelude</em> module, but these will not be usable in Plutus as they are not
inlinable. So, the Plutus team have provided an alternative <em>Prelude</em>
that can be used in validation.</p>
<p>The way that the Plutus Prelude is able to take precedence over the
Haskell Prelude, which is normally in scope by default, is by using the
following LANGUAGE pragma in the code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE NoImplicitPrelude   #-}</span>
</pre></div>
</div>
<p>Then, by importing PlutusTx.Prelude, its functions are used in place of
the standard Prelude functions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">PlutusTx.Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">Semigroup</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="nf">unless</span><span class="p">)</span>
</pre></div>
</div>
<p>You may also notice that the standard Prelude is also imported. However,
it is only in order to bring in <em>Semigroup</em>, which we explicitly hid in
the PlutusTx.Prelude import. But this is not important right now.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Semigroup</span> <span class="p">(</span><span class="o">..</span><span class="p">))</span>
</pre></div>
</div>
<p>Just remember that when you are using something in a Plutus script that
looks like a function from the standard Prelude, what you are actually
using is a function from the Plutus Prelude. Often they will have the
same signature, but, as we can see in the case of <em>error</em>, they are not
always identical.</p>
<p>Looking again at our new validator, we now have a validator that will
always fail.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="nb">()</span>
</pre></div>
</div>
<p>We will leave everything else as it was and check the effect in the
playground.</p>
<div class="figure align-default">
<img alt="_images/playground_week2_10.png" src="_images/playground_week2_10.png" />
</div>
<p>Here, the script address is different. The script is different an so has
a different hash.</p>
<p>We also notice that the <em>grab</em> transaction did not work, and if we
scroll down to look at the logs, we see that it was not validated.</p>
<div class="figure align-default">
<img alt="_images/playground_week2_9.png" src="_images/playground_week2_9.png" />
</div>
<p>So, in our first example we had a validator that would always succeed
and would allow anyone to grab the UTxOs from it. In the second example,
we have a validator that always fails and any UTxOs sent to this script
address can never be retrieved. This is basically a way to burn funds,
which may be useful under some circumstances.</p>
<p>When we look at the logs, we see that validation fails, but we have no
clue why it fails. here’s a way to change that by using a variant of
error - <em>traceError</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">traceError</span> <span class="s">&quot;NO WAY!&quot;</span>
</pre></div>
</div>
<p>The function takes a string, but not a Haskell string. It is a Plutus
string. In order for this to compile, we need to use the
OverloadedStrings GHC extension.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE OverloadedStrings   #-}</span>
</pre></div>
</div>
<p>If we now run the same scenario in the playground with the new code, we
will see the custom error message that we added.</p>
<div class="figure align-default">
<img alt="_images/playground_week2_11.png" src="_images/playground_week2_11.png" />
</div>
</div>
<div class="section" id="example-3-forty-two">
<h3><span class="section-number">3.3.3. </span>Example 3 - Forty Two<a class="headerlink" href="#example-3-forty-two" title="Permalink to this headline">¶</a></h3>
<p>Now let’s write a validator that looks at at least one of the arguments.
Let’s write a simple one that expects a simple Redeemer.</p>
<p>Now that we care about the redeemer, we need to be able to reference it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="n">r</span> <span class="kr">_</span>
</pre></div>
</div>
<p>We can now reference the redeemer as <em>r</em> in the code.</p>
<p>Let’s say that we expect the redeemer to be I 42. If so, validation
passes. If not, we fail with an error message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="n">r</span> <span class="kr">_</span>
   <span class="o">|</span> <span class="n">r</span> <span class="o">==</span> <span class="kt">I</span> <span class="mi">42</span> <span class="ow">=</span> <span class="nb">()</span>
   <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">traceError</span> <span class="s">&quot;wrong redeemer&quot;</span>
</pre></div>
</div>
<p>If we were to run this now in the playground, validation would always
fail. We need to add an input to the <em>grab</em> endpoint so that Wallet 3
can pass in the redeemer which will be used by the <em>mkValidator</em>
function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">GiftSchema</span> <span class="ow">=</span>
   <span class="kt">BlockchainActions</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">Integer</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="kt">Integer</span>
</pre></div>
</div>
<p>And now, the redeemer is no longer to be ignored in the <em>grab</em> part of
the code. Instead we will pass in the value of the redeemer given to the
endpoint.</p>
<p>We add the redeemer argument to the <em>grab</em> declaration. Note the
addition of the Integer in the function signature, as well as the new
<em>r</em> parameter which is used to reference it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="p">(</span><span class="kt">HasBlockchainActions</span> <span class="n">s</span><span class="p">,</span> <span class="kt">AsContractError</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">do</span>
</pre></div>
</div>
<p>And then pass it to the <em>mustSpendScriptOutput</em> instead of the
throw-away value we used earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">I</span> <span class="n">r</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span>
</pre></div>
</div>
<p>One more change, we need to change the “&gt;&gt;” to “&gt;&gt;=” in the following
code, now that <em>grab</em> has an argument. You can use the REPL to look at
the types “&gt;&gt;” and “&gt;&gt;=” to see why the second one is now needed.
Basically, they both sequence actions, but &gt;&gt; ignores any wrapped
values, whereas &gt;&gt;= accesses the wrapped value and passes it to the next
action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">grab</span>
</pre></div>
</div>
<p>Now we can try it out in the playground. After adding the new code and
clicking <em>Simulate</em> you will notice that the old scenario has gone. That
is because the schema has changed and the old scenario is no longer
valid.</p>
<p>Let’s set up a scenario that doesn’t require a third wallet.</p>
<div class="figure align-default" id="id9">
<img alt="alt text" src="_images/playground_week2_12.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>Here wallet one is going to put 3 lovelace into the contract, and wallet
two is going to try to grab them, but this time, wallet 2 will need to
pass in a value which will be used to construct the redeemer.</p>
<p>If we pass in 100 as the value for the grab endpoint, and click
<em>Evaluate</em>, we see in the logs that validation has failed.</p>
<div class="figure align-default" id="id10">
<img alt="alt text" src="_images/playground_week2_13.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>If we go back to scenario and change the value to 42, we should see that
validation succeeds.</p>
<div class="figure align-default" id="id11">
<img alt="alt text" src="_images/playground_week2_14.png" />
<p class="caption"><span class="caption-text">alt text</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</div>
<p>And indeed, wallet 2 now manages to unlock the UTxO held at the script
address and grab it.</p>
<p>We see that the final balances are as we expect, and also the logs show
that validation did not throw an error, which means that validation
succeeded.</p>
</div>
<div class="section" id="example-4-typed">
<h3><span class="section-number">3.3.4. </span>Example 4 - Typed<a class="headerlink" href="#example-4-typed" title="Permalink to this headline">¶</a></h3>
<p>It was mentioned at the beginning of the lecture, this is low-level
Plutus and in reality, no-one will write validation functions like this.</p>
<p>Now we will see how it is actually done.</p>
<p>Even though the <em>Data</em> type is powerful and you can encode all sorts of
data into it, it doesn’t really feel like Haskell. It is almost like you
are writing in an untyped language like Javascript or Python. It is just
a like a blob of data, it can contain anything so you don’t really have
any type safety. You will always need to check, for example, if you are
expecting an integer that you are indeed given an integer.</p>
<p>We would rather use more specific data types that are tailored to the
business logic.</p>
<p>This is indeed possible with so-called Typed Validators. What this means
is that we can replace the occurrences of <em>Data</em> in the mkValidator
signature with more suitable types.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>In our silly little example, we completely ignore the Datum, so a more
suitable type would be just the Unit type - ().</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>For the redeemer, in this example, we are only dealing with integers, so
it would probably make more sense to use Integer instead.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>We haven’t talked yet about what the Context actually looks like, but
you can imagine that its translation into the <em>Data</em> type is quite
awkward and it wouldn’t be pleasant to work with.</p>
<p>There is a much nicer type called <em>ValidatorCtx</em> that’s made exactly for
this purpose.</p>
<p>Note: this type gets replaced with ScriptContext in later Plutus builds
and will be used from Lecture 3 onwards.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ValidatorCtx</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Finally, we have already mentioned that it is a bit unusual to use Unit
as a return type. Much more natural would be to use Bool to indicate
successful or failed validation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ValidatorCtx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>So, this is a better way to write validation code. The last two types
<em>ValidatorCtx</em> and <em>Bool</em> will always be the same (but see note above),
but the first two types can be different depending on the situation.</p>
<p>In this case, let’s now rewrite the function accordingly using these new
types. The parameter <em>r</em> is now no longer of type <em>Data</em> - it is an
<em>Integer</em>, so we can simply check that it is equal to 42 rather than
against a constructed <em>Data</em> type.</p>
<p>And, we no longer want to return Unit - we will return True or False.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ValidatorCtx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="nb">()</span> <span class="n">r</span> <span class="kr">_</span>
   <span class="o">|</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>   <span class="ow">=</span> <span class="kt">True</span>
   <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>This will not yet compile as other parts of the code are not yet type
correct.</p>
<p>Remember that the mkValidatorScript expected code of type <em>Data -&gt; Data
-&gt; Data -&gt; ()</em> but we now have something of type <em>() -&gt; Integer -&gt;
ValidatorCtx -&gt; Bool</em>.</p>
<p>In order for this to work we first need one more import.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Ledger.Typed.Scripts</span> <span class="k">as</span> <span class="n">Scripts</span>
</pre></div>
</div>
<p>In this example, it is being imported qualified and using the Scripts
prefix, but this is arbitrary and you could pick some other way of
referencing the module.</p>
<p>Now we need some boilerplate, the purpose of which is to tell the
compiler which types we have picked for Datum and Redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Typed</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Typed</span> <span class="kr">where</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Typed</span> <span class="ow">=</span> <span class="nb">()</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Typed</span> <span class="ow">=</span> <span class="kt">Integer</span>
</pre></div>
</div>
<p>This is quite advanced Haskell, so-called type-level programming, but
just like the Template Haskell we have already encountered, you don’t
really need a deep understanding of it as all scripts will follow the
same schema.</p>
<p>We these changes, the Haskell code will compile, and we now need to
change the Template Haskell boilerplate that creates the <em>validator</em>
function from the <em>mkValidator</em> function.</p>
<p>Again, this pattern will be the same for all scripts that use typed
validators.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inst</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Typed</span>
<span class="nf">inst</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Typed</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
   <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
   <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="kt">Integer</span>

<span class="nf">validator</span> <span class="ow">::</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="n">inst</span>
</pre></div>
</div>
<p>We have now turned our untyped version into a typed version.</p>
<p>In this extremely simply example, it probably doesn’t seem worth the
effort, but for realistic contracts, it is much nicer to do it like
this.</p>
<p>At this point the code will run as before in the simulator. However, we
can make the <em>give</em> endpoint slightly simpler.</p>
<p>Although we have not yet gone over this part of the code in detail, the
following changes can be made.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="nb">()</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">amount</span>
<span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="n">inst</span> <span class="n">tx</span>
</pre></div>
</div>
<p>The <em>mustPayToOtherScript</em> function has been replaced with
<em>mustPayToTheScript</em>. We can pass in just () as we longer need to
construct a value of type <em>Data</em>. And we also no longer need to pass in
the script hash.</p>
<p>Also, <em>submitTx</em> has been replaced with <em>submitTxConstraints</em> and takes
the <em>inst</em> as one of its arguments.</p>
<p>Now we will explain how that actually works. How does Plutus convert
these custom data types to the actual low-lever implementation - the
<em>Data</em> type.</p>
<p>We can look at the code in the <em>PlutusTx.IsData.Class</em> module.</p>
<p>Here we see that there is a quite simple type class defined, called
<em>IsData</em>. The code here is taken directly from the Plutus code at commit
3746610e53654a1167aeb4c6294c6096d16b0502.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | A typeclass for types that can be converted to and from &#39;Data&#39;.</span>
<span class="kr">class</span> <span class="kt">IsData</span> <span class="p">(</span><span class="n">a</span> <span class="ow">::</span> <span class="kt">Type</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">toData</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Data</span>
   <span class="c1">-- TODO: this should probably provide some kind of diagnostics</span>
   <span class="n">fromData</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>This class allows us to translate between the <em>Data</em> type and types that
are instances of the class.</p>
<p>It provides two functions</p>
<ul class="simple">
<li><p>toData - takes a value and converts it to <em>Data</em></p></li>
<li><p>fromData - takes a value of type <em>Data</em> and attempts to convert it to
an instance of type <em>IsData</em>. This can fail because not all values of
type <em>Data</em> will be convertible to the target type.</p></li>
</ul>
<p>Let’s try this out in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude Week02.Burn&gt; :l src/Week02/Typed.hs
Ok, one module loaded.
Prelude Week02.Typed&gt; import PlutusTx.IsData
Prelude PlutusTx.IsData Week02.Typed&gt;
</pre></div>
</div>
<p>We know that <em>Unit</em> and <em>Integer</em> are both instances of <em>IsData</em> because
they worked in our example.</p>
<p>Let’s convert an <em>Integer</em> to <em>Data</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="n">toData</span> <span class="p">(</span><span class="mi">42</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">I</span> <span class="mi">42</span>
</pre></div>
</div>
<p>We see that this has been converted to an instance of type <em>Data</em> using
the <em>I</em> constructor, which we did manually before we used typed
validation.</p>
<p>Now let’s do it the other way around</p>
<p>First we need to import PlutusTx to make the <em>Data</em> type available to
us.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">PlutusTx</span>
</pre></div>
</div>
<p>Then we will convert from <em>Data</em> to <em>Integer</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">PlutusTx</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="n">fromData</span> <span class="p">(</span><span class="kt">I</span> <span class="mi">42</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="kt">Just</span> <span class="mi">42</span>
</pre></div>
</div>
<p>We get a <em>Just 42</em> back - <em>Just</em> being the Maybe constructor when Maybe
is not Nothing.</p>
<p>And when it fails, when it can’t convert to the target type, we will get
back Nothing.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">PlutusTx</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="n">fromData</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>If we examine <em>IsData</em> we can see all the types that this pattern will
work for - all the types that have an <em>IsData</em> instance defined.</p>
<p>If we examine <em>IsData</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">IsData</span>
<span class="kr">type</span> <span class="kt">IsData</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">IsData</span> <span class="n">a</span> <span class="kr">where</span>
<span class="nf">toData</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Data</span>
<span class="nf">fromData</span> <span class="ow">::</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL toData, fromData #-}</span>
   <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
<span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="kt">Bool</span>
<span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">c</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=&gt;</span>
      <span class="kt">IsData</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="nb">()</span>
<span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="kt">Integer</span> <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
</pre></div>
</div>
<p>This is still quite a short list of possible types. We would like to use
many more types than this for our Datum and Redeemer.</p>
<p>In order to do this, we would normally need to define an <em>IsData</em>
instance for any type that we wish to use. This will allow us to tell
the compiler how to do the back and forth conversions.</p>
<p>However, this again would be tedious as it is such a mechanical process.
So, there is a mechanism in Plutus that does this for us.</p>
</div>
<div class="section" id="example-5-custom-isdata-types">
<h3><span class="section-number">3.3.5. </span>Example 5 - Custom IsData types<a class="headerlink" href="#example-5-custom-isdata-types" title="Permalink to this headline">¶</a></h3>
<p>Before we look at that mechanism, let’s rewrite the validation function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ValidatorCtx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="nb">()</span> <span class="n">r</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>This does the same job, but is now a one-liner. However, we no longer
have our error message. To solve this, there is a function called
<em>traceIfFalse</em> that takes a <em>String</em> and a <em>Bool</em>. If the <em>Bool</em> is
true, the string will be ignored, otherwise it will be logged. The
result of the function will be the value of the <em>Bool</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ValidatorCtx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="nb">()</span> <span class="n">r_</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;wrong redeemer&quot;</span> <span class="o">$</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>Now let’s talk about custom data types. Let’s define a silly one and use
it in our validator function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">MySillyRedeemer</span> <span class="ow">=</span> <span class="kt">MySillyRedeemer</span> <span class="kt">Integer</span>
   <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">MySillyRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ValidatorCtx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">MySillyRedeemer</span> <span class="n">r</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;wrong redeemer&quot;</span> <span class="o">$</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>And we need to change some of the boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Typed</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Typed</span> <span class="kr">where</span>
<span class="o">...</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Typed</span> <span class="ow">=</span> <span class="kt">MySillyRedeemer</span>

<span class="nf">inst</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Typed</span>
<span class="o">...</span>
<span class="kr">where</span>
   <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="kt">MySillyRedeemer</span>
</pre></div>
</div>
<p>If we try to compile the code now, either on the command line or in the
playground, we will get an error because Plutus doesn’t know how to
convert back and forth between <em>IsData</em> and <em>MySillyRedeemer</em>.</p>
<p>We could write an instance of <em>IsData</em> for <em>MySillyRedeemer</em> by hand.
But, we don’t need to.</p>
<p>Instead we can use another bit of Template Haskell magic.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;MySillyRedeemer</span>
</pre></div>
</div>
<p>At compile time, the compiler will use the Template Haskell to write an
<em>IsData</em> instance for us. And now, it will compile.</p>
<p>Let’s check it in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude PlutusTx.IsData PlutusTx&gt; :l src/Week02/IsData.hs
Ok, one module loaded.
</pre></div>
</div>
<p>Converting to <em>IsData</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">PlutusTx</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">toData</span> <span class="p">(</span><span class="kt">MySillyRedeemer</span> <span class="mi">17</span><span class="p">)</span>
<span class="kt">Constr</span> <span class="mi">0</span> <span class="p">[</span><span class="kt">I</span> <span class="mi">17</span><span class="p">]</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">PlutusTx</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>And converting back again.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span> <span class="kt">PlutusTx</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">IsData</span><span class="o">&gt;</span> <span class="n">fromData</span> <span class="p">(</span><span class="kt">Constr</span> <span class="mi">0</span> <span class="p">[</span><span class="kt">I</span> <span class="mi">3</span><span class="p">])</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">MySillyRedeemer</span>
<span class="kt">Just</span> <span class="p">(</span><span class="kt">MySillyRedeemer</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that in order to run this conversion back to Maybe MySillyRedeemer
in the REPL, it relies on MySillyRedeemer deriving Show, so that the
REPL knows how to display the result.</p>
<p>So far, so good.</p>
<p>That is the on-chain part and now we need to do something in the
off-chain part where we produce the Redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="o">...</span>
   <span class="n">tx</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">MySillyRedeemer</span> <span class="n">r</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span>
</pre></div>
</div>
<p>If you try this code (in IsData.hs) in the playground, you should see
that it behaves in the same way as before.</p>
<p>We have seen a couple of examples of simple validators and we have seen
both the low-level approach and the higher-level typed approach where we
can use custom type.</p>
<p>We completely ignore the third argument, the validation context, which
allows us to inspect the spending transaction which we haven’t done so
far.</p>
<p>We will look at that in the next lecture.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week3.html" class="btn btn-neutral float-right" title="4. Week 03 - Script Context" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="week1.html" class="btn btn-neutral float-left" title="2. Week 01 - Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Week 03 - Script Context &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="plutus_pioneer_program.html">1. Plutus Pioneer Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="alonzo_white.html">1. Alonzo White Walkthrough</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Week 03 - Script Context</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week3.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-03-script-context">
<h1>Week 03 - Script Context<a class="headerlink" href="#week-03-script-context" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=6_rfCCY9_gY">Lecture
#3, Iteration #2</a>.</p>
<p>In this lecture we learn about the script context (the third validation
argument), handling time, and parameterized contracts.</p>
<p>The code in this lecture uses Plutus commit <code class="docutils literal notranslate"><span class="pre">81ba78edb1d634a13371397d8c8b19829345ce0d</span></code>.</p>
</div>
<div class="section" id="before-we-start">
<h2>Before We Start<a class="headerlink" href="#before-we-start" title="Permalink to this headline">¶</a></h2>
<p>Since the last lecture there has been an update to the playground, which is present in the Plutus commit we are using for this lecture (see note above).</p>
<p>There was an issue whereby the timeout, which was hardcoded into the playground was too short. This would cause simulations to fail if they took longer than the
hardcoded timeout.</p>
<p>There is now an option when you start the Plutus Playground Server which allows you to specify the timeout. The following example sets the timeout to 120 seconds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plutus</span><span class="o">-</span><span class="n">playground</span><span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">i</span> <span class="mi">120</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="recap">
<h2>Recap<a class="headerlink" href="#recap" title="Permalink to this headline">¶</a></h2>
<p>When we explained the (E)UTxO model in the first lecture, we mentioned that in
order to unlock a script address, the script attached to the address is
run, and that script gets three pieces of information - the <em>datum</em>, the
<em>redeemer</em> and the <em>context</em>.</p>
<p>In the second lecture, we saw examples of that, and we saw how it
actually works in Haskell.</p>
<p>We saw the low-level implementation, where all three arguments are
represented by the <code class="docutils literal notranslate"><span class="pre">Data</span></code> type. We also saw that in practice this is not
used.</p>
<p>Instead, we use the typed version, where the datum and redeemer can be
custom types (as long as they implement the <code class="docutils literal notranslate"><span class="pre">IsData</span></code> type class), and
where the third argument is of type <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code>.</p>
<p>In the examples we have seen so far we have looked at the datum and
the redeemer, but we have always ignored the context. But the
context is, of course, very important. So, in this lecture we will
start looking at the context.</p>
</div>
<div class="section" id="scriptcontext">
<h2>ScriptContext<a class="headerlink" href="#scriptcontext" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code> type is defined in package <code class="docutils literal notranslate"><span class="pre">plutus-ledger-api</span></code>,
which is a package that, until now, we haven’t needed. But now we do
need it, and it is included in this week’s <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> file. It is
defined in module <code class="docutils literal notranslate"><span class="pre">Plutus.V1.Ledger.Contexts</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span> <span class="p">{</span>
            <span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span>
            <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span>
      <span class="p">}</span>
</pre></div>
</div>
<p>It is a record type with two fields.</p>
<p>The second field is of type <code class="docutils literal notranslate"><span class="pre">ScriptPurpose</span></code>, which is defined in the same module. It defines for which purpose a script is being run.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptPurpose</span>
   <span class="ow">=</span> <span class="kt">Minting</span> <span class="kt">CurrencySymbol</span>
   <span class="o">|</span> <span class="kt">Spending</span> <span class="kt">TxOutRef</span>
   <span class="o">|</span> <span class="kt">Rewarding</span> <span class="kt">StakingCredential</span>
   <span class="o">|</span> <span class="kt">Certifying</span> <span class="kt">DCert</span>
</pre></div>
</div>
<p>For us, the most important is <code class="docutils literal notranslate"><span class="pre">Spending</span></code>. This is what we have talked
about so far in the context of the (E)UTxO model. This is when a script
is run in order to validate a spending input for a transaction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Minting</span></code> purpose comes into play when you want to define a native
token. Its purpose us to describe under which circumstances the native
token can be minted or burned.</p>
<p>There are also two new brand new purposes - <code class="docutils literal notranslate"><span class="pre">Rewarding</span></code> - related to
staking and <code class="docutils literal notranslate"><span class="pre">Certifying</span></code> - related to stake delegation.</p>
<p>The most interesting field, the one that contains the actual context, is <code class="docutils literal notranslate"><span class="pre">scriptContextTxInfo</span></code>, which is of type
<code class="docutils literal notranslate"><span class="pre">TxInfo</span></code>, also defined in the same module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TxInfo</span> <span class="ow">=</span> <span class="kt">TxInfo</span>
   <span class="p">{</span> <span class="n">txInfoInputs</span>      <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span> <span class="c1">-- ^ Transaction inputs</span>
   <span class="p">,</span> <span class="n">txInfoOutputs</span>     <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">]</span> <span class="c1">-- ^ Transaction outputs</span>
   <span class="p">,</span> <span class="n">txInfoFee</span>         <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The fee paid by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoForge</span>       <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The &#39;Value&#39; forged by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoDCert</span>       <span class="ow">::</span> <span class="p">[</span><span class="kt">DCert</span><span class="p">]</span> <span class="c1">-- ^ Digests of certificates included in this transaction</span>
   <span class="p">,</span> <span class="n">txInfoWdrl</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">StakingCredential</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span> <span class="c1">-- ^ Withdrawals</span>
   <span class="p">,</span> <span class="n">txInfoValidRange</span>  <span class="ow">::</span> <span class="kt">SlotRange</span> <span class="c1">-- ^ The valid range for the transaction.</span>
   <span class="p">,</span> <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">]</span> <span class="c1">-- ^ Signatures provided with the transaction, attested that they all signed the tx</span>
   <span class="p">,</span> <span class="n">txInfoData</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)]</span>
   <span class="p">,</span> <span class="n">txInfoId</span>          <span class="ow">::</span> <span class="kt">TxId</span>
   <span class="c1">-- ^ Hash of the pending transaction (excluding witnesses)</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
</pre></div>
</div>
<p>It describes the spending transaction. In the (E)UTxO model, the context of validation is the spending transaction and its
inputs and outputs. This context is expressed in the <code class="docutils literal notranslate"><span class="pre">TxInfo</span></code> type.</p>
<p>There are a couple of fields that are global to the whole transaction and in particular we have the list of all the inputs <code class="docutils literal notranslate"><span class="pre">txInfoInputs</span></code>
and the list of all the outputs <code class="docutils literal notranslate"><span class="pre">txInfoOutputs</span></code>. Each of those has a variety of fields to drill into each individual input or output.</p>
<p>We also see fields for fees <code class="docutils literal notranslate"><span class="pre">txFee</span></code>, the forge value <code class="docutils literal notranslate"><span class="pre">txInfoForge</span></code>, used when minting or burning native tokens.</p>
<p>Then we have a list of delegation certificates in <code class="docutils literal notranslate"><span class="pre">txInfoDCert</span></code> and a field <code class="docutils literal notranslate"><span class="pre">txInfoWdrl</span></code> to hold information about staking withdrawals.</p>
<p>The field <code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code>, which we will look at in much more detail in a moment, defines the slot range for which this transaction is valid.</p>
<p><code class="docutils literal notranslate"><span class="pre">txInfoSignatories</span></code> is the list of public keys that have signed this transaction.</p>
<p>Transactions that spend a script output need to include the datum of the script output.
The <code class="docutils literal notranslate"><span class="pre">txInfoData</span></code> field is a list associating datums with their respective hashes. If there is a transaction output to a script address
that carries some datum, you don’t need to include the datum, you can just include the datum hash. However, scripts that spend an output do need to include the datum, in which case it will be included in the <code class="docutils literal notranslate"><span class="pre">txInfoData</span></code> list.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">txInfoId</span></code> field is the ID of this transaction.</p>
<div class="section" id="txinfovalidrange">
<h3>txInfoValidRange<a class="headerlink" href="#txinfovalidrange" title="Permalink to this headline">¶</a></h3>
<p>While there is a lot of information contained in this <code class="docutils literal notranslate"><span class="pre">txInfo</span></code> type, for
our first example of how to use the third argument to validation, we
will concentrate on the <code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code> field.</p>
<p>This brings us to an interesting dilemma. We have stressed several times
that the big advantage that Cardano has over something like Ethereum is
that validation can happen in the wallet. But we have also noted that a
transaction can still fail on-chain following validation if, when the
transaction arrives on the blockchain, it has been consumed already by
someone else. In this case, the transaction fails without having to pay
fees.</p>
<p>What should never happen under normal circumstances is that a validation
script runs and then fails. This is because you can always run the
validation under exactly the same conditions in the wallet, so it would
fail before you ever submit it.</p>
<p>So that is a very nice feature, but it is not obvious how to manage time
in that context. Time is important, because we want to be able to
express that a certain transaction is only valid before or only valid
after a certain time has been reached.</p>
<p>We saw an example of this in lecture one - the auction example, where
bids are only allowed until the deadline has been reached, and the
<code class="docutils literal notranslate"><span class="pre">close</span></code> endpoint can only be called after the deadline has passed.</p>
<p>That seems to be a contradiction, because time is obviously flowing. So,
when you try to validate a transaction that you are constructing in your
wallet, the time that you are doing that can, of course, be different
than the time that the transaction arrives at a node for validation. So,
it’s not clear how to bring these two together so that validation is
deterministic, and to guarantee that if, and only if, validation
succeeds in the wallet, it will also succeed in the node.</p>
<p>The way Cardano solves that, is by adding the slot range field
<code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code> to a transaction, which essentially says “This
transaction is valid between <em>this</em> and <em>that</em> slot”.</p>
<p>When a transaction gets submitted to the blockchain and validated by a
node, then before any scripts are run, some general checks are made, for
example that all inputs are present and that the balances add up, that
the fees are included and so on.</p>
<p>One of those checks that happens before validation is to check that the slot range is valid. The
node will look at the current time and check that it falls into the valid slot range of the transaction. If it does not, then validation fails immediately without
ever running the validator scripts.</p>
<p>So, if the pre-checks succeed, then this means that the current time does fall into the valid slot range.
This, in turn, means that we are completely deterministic again. The validation script can simply assume that it is being run at a valid slot.</p>
<p>By default, a script will use the infinite slot range, one that covers all slots starting from the genesis block and running until the end of time.</p>
<p>There is one slight complication with this, and that is that Ouroboros, the consensus protocol powering Cardano doesn’t use POSIX time, it uses slots. But Plutus
uses real time, so we need to be able to convert back and forth between real time and slots. This is no problem so long as the slot time is fixed. Right now it is
one second, so right now it is easy.</p>
<p>However, this could change in the future. There could be a hard fork with some parameter change that would change the slot time. We can’t know that in advance.
We don’t know what the slot length will be in ten years, for example.</p>
<p>That means that slot intervals that are defined for transactions mustn’t have a definite upper bound that is too far in the future. It must only be as far in the
future as it is possible to know what the slot length will be. This happens to be something like 36 hours. We know that if there is going to be a hard fork, we would
know about it at least 36 hours in advance.</p>
</div>
<div class="section" id="posixtimerange">
<h3>POSIXTimeRange<a class="headerlink" href="#posixtimerange" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at this <code class="docutils literal notranslate"><span class="pre">POSIXTimeRange</span></code> type, which is defined in <code class="docutils literal notranslate"><span class="pre">Plutus.V1.Ledger.Time</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">POSIXTimeRange</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="kt">POSIXTime</span><span class="o">.</span>
</pre></div>
</div>
<p>It is a type synonym for <code class="docutils literal notranslate"><span class="pre">Interval</span> <span class="pre">POSIXTime</span></code> and we see that <code class="docutils literal notranslate"><span class="pre">Interval</span></code> is defined by a <code class="docutils literal notranslate"><span class="pre">LowerBound</span></code> and an <code class="docutils literal notranslate"><span class="pre">UpperBound</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Interval</span>
      <span class="n">ivFrom</span> <span class="ow">::</span> <span class="kt">LowerBound</span> <span class="n">a</span>
      <span class="n">inTo</span>   <span class="ow">::</span> <span class="kt">UpperBound</span> <span class="n">a</span>
</pre></div>
</div>
<p>If we drill into <code class="docutils literal notranslate"><span class="pre">LowerBound</span></code> we see the constructor</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">LowerBound</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Extended</span> <span class="n">a</span><span class="p">)</span> <span class="kt">Closure</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Closure</span></code> is a synonym for <code class="docutils literal notranslate"><span class="pre">Bool</span></code> and specifies whether a bound is included in the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> or not.</p>
<p><code class="docutils literal notranslate"><span class="pre">Extended</span></code> can be <code class="docutils literal notranslate"><span class="pre">NegInf</span></code> for negative infinity, <code class="docutils literal notranslate"><span class="pre">PosInf</span></code> for positive infinity, or <code class="docutils literal notranslate"><span class="pre">Finite</span> <span class="pre">a</span></code>.</p>
<p>We also find some helper functions including the <code class="docutils literal notranslate"><span class="pre">member</span></code> function which checks if a given <code class="docutils literal notranslate"><span class="pre">a</span></code> is part of a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code>, so long as the type of <code class="docutils literal notranslate"><span class="pre">a</span></code> is a subtype
of <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, which is the case for <code class="docutils literal notranslate"><span class="pre">POSIXTime</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">member</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">member</span> <span class="n">a</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">i</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">singleton</span> <span class="n">a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">interval</span></code> is a smart constructor for the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> type which creates an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> with an inclusive upper and lower bound.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">interval</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">interval</span> <span class="n">s</span> <span class="n">s&#39;</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we have <code class="docutils literal notranslate"><span class="pre">from</span></code> which constructs an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which starts at <code class="docutils literal notranslate"><span class="pre">a</span></code> and lasts until eternity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">from</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">from</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have <code class="docutils literal notranslate"><span class="pre">to</span></code>, which is the opposite. It constructs an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> starting from the genesis block up to, and including <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">to</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">to</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">always</span></code> is the default <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which includes all times.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">always</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">always</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have the opposite, <code class="docutils literal notranslate"><span class="pre">never</span></code>, which contains no slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">never</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">never</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also the <code class="docutils literal notranslate"><span class="pre">singleton</span></code> helper, which constructs an interval which consists of just one slot.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">singleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">singleton</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">interval</span> <span class="n">s</span> <span class="n">s</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">hull</span></code> gives the smallest interval containing both the given intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hull</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">hull</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">min</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">max</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">intersection</span></code> function determines the largest interval that is contained in both the given intervals. This is an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that starts
from the largest lower bound of the two intervals and extends until the smallest upper bound.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">intersection</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">intersection</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">overlaps</span></code> function checks whether two intervals overlap, that is, whether there is a value that is a member of both intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">overlaps</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">overlaps</span> <span class="n">l</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">isEmpty</span> <span class="p">(</span><span class="n">l</span> <span class="p">`</span><span class="n">intersection</span><span class="p">`</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">contains</span></code> takes two intervals and determines if the second interval is completely contained within the first one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">contains</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">contains</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">l2</span> <span class="o">&amp;&amp;</span> <span class="n">h2</span> <span class="o">&lt;=</span> <span class="n">h1</span>
</pre></div>
</div>
<p>And we have the <code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code> functions to determine, if a given time is, respectively, before or after everything in a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">before</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">before</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">f</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lowerBound</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">f</span>

<span class="nf">after</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">after</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="kr">_</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">upperBound</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">t</span>
</pre></div>
</div>
<p>Let’s have a play in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Interval</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Let’s construct the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> between 10 and 20, inclusive.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">10</span><span class="p">)</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">20</span><span class="p">)</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>We can check whether a value is a member of an interval:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">9</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">12</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">20</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">21</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>We can use the <code class="docutils literal notranslate"><span class="pre">from</span></code> constructor. Here the lower bound is again a finite slot, but the upper bound is positive infinity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">21</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">30</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">300000</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>And the <code class="docutils literal notranslate"><span class="pre">to</span></code> constructor. Here the lower bound is negative infinity, while the upper bound is a finite slot number.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">300000</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">31</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">30</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">7</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>Now, let’s try the <code class="docutils literal notranslate"><span class="pre">intersection</span></code> function on the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> from 10 to 20 and the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> from 18 to 30.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">intersection</span> <span class="p">(</span><span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span><span class="p">)</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">18</span> <span class="mi">30</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">18</span><span class="p">)</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">20</span><span class="p">)</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>As expected, we get the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that runs from 18 to 20, inclusive.</p>
<p>We can check whether one <code class="docutils literal notranslate"><span class="pre">Interval</span></code> contains another.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">80</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">100</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">101</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>We see that as soon as the second <code class="docutils literal notranslate"><span class="pre">Interval</span></code> extends to 101, it is no longer fully contained within the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that runs to 100.</p>
<p>However, if we check with <code class="docutils literal notranslate"><span class="pre">overlaps</span></code>, then it will be true because there are elements, such as 40, that are contained in both intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">101</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">101</span> <span class="mi">110</span>
<span class="kt">False</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-vesting">
<h2>Example - Vesting<a class="headerlink" href="#example-vesting" title="Permalink to this headline">¶</a></h2>
<p>Imagine you want to give a gift of Ada to a child. You want the child to own the Ada, but you only want the child to have access to it he or she
turns eighteen.</p>
<p>Using Plutus, it is very easy to implement. As our first contract that will look at the context argument, we will
implement a contract that implements a vesting scheme. Money will be put into a script and then it can be retrieved by a certain person, but only once
a certain deadline has been reached.</p>
<p>We start by copying the <code class="docutils literal notranslate"><span class="pre">IsData</span></code> contract from lecture two into a new module called <code class="docutils literal notranslate"><span class="pre">Vesting</span></code>.</p>
<p>The first step is to think about the types for the datum and redeemer.</p>
<p>For datum, it makes sense to have two pieces of information, the beneficiary and the deadline. So, let’s define this type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingDatum</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
   <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">POSIXTime</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;VestingDatum</span>
</pre></div>
</div>
<p>In order to know if someone can spend this script output, two pieces information are required, i.e. the beneficiary’s signature and the time of the transaction. In
this case, both those pieces of information are contained in the transaction itself. This means that we don’t need any information in the redeemer, so we can just
use <code class="docutils literal notranslate"><span class="pre">()</span></code> for the redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingDatum</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>We need to check two conditions.</p>
<ol class="arabic simple">
<li><p>That only the correct beneficiary can unlock a UTxO sitting at this
address. This we can validate by checking that the beneficiary’s
signature is included in the transaction.</p></li>
<li><p>That this transaction is only executed after the deadline is reached.</p></li>
</ol>
<p>We could probably just write this in one go, but we will write it in a
more top-down fashion and delegate to some helper functions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
      <span class="n">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">signedByBeneficiary</span> <span class="o">&amp;&amp;</span>
                               <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span> <span class="n">deadlineReached</span>
<span class="kr">where</span>
      <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
      <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>
</pre></div>
</div>
<p>To check that the transaction is signed by the beneficiary, we can get the public key of the beneficiary from the datum and pass it, along with the transaction
information to the <code class="docutils literal notranslate"><span class="pre">txSignedBy</span></code> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signedByBeneficiary</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">signedByBeneficiary</span> <span class="ow">=</span> <span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">beneficiary</span> <span class="n">dat</span>
</pre></div>
</div>
<p>How do we check that the deadline has passed?</p>
<div class="figure align-default">
<img alt="_images/pic__00046.png" src="_images/pic__00046.png" />
</div>
<p>Let’s consider a transaction with a validity that crosses the deadline, which is shown as the uppermost range in the above diagram.</p>
<p>Recall that before the validator script is run, other checks are made, including the time check. The node checks that the current time falls into the valid range of
the transaction and only then is the validator run. So we know that, if we are in the validator, the current time lies somewhere within the validity interval.</p>
<p>In the case of the range that crosses the deadline, the validator code cannot know whether the current time is before or after the deadline. In this case, the
validator must declare that the transaction is invalid.</p>
<p>The second example in the diagram, however, is fine. We still don’t know what the current time is exactly, but we know that whatever the time is, it will be after the
deadline.</p>
<p>So, what we are checking for is that the whole validity interval is to the right of the deadline. One way to do this is to use the <code class="docutils literal notranslate"><span class="pre">contains</span></code> function to check
whether the validity interval is fully contained within the interval that starts from the deadline and extends until the end of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">deadlineReached</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">deadlineReached</span> <span class="ow">=</span> <span class="n">contains</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="n">deadline</span> <span class="n">dat</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>That completes the validation logic. Let’s take care of some boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ValidatorTypes</span> <span class="kt">Vesting</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Vesting</span>
<span class="nf">typedValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Vesting</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">VestingDatum</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>We will focus more on the wallet part of the script later, but here are the changes.</p>
<p>In addition to some new <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragmas and some extra imports, we have created a <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code> type, and modified the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint to
require no parameters.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VestingSchema</span></code> type defines the endpoints that we want to expose to the user. As in our last example, <code class="docutils literal notranslate"><span class="pre">give</span></code> will be used by the user who puts funds into the
contract, then <code class="docutils literal notranslate"><span class="pre">grab</span></code> will be used by the user wanting to claim the funds.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">VestingSchema</span> <span class="ow">=</span>
   <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">GiveParams</span>
   <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>So what parameters do we need for <code class="docutils literal notranslate"><span class="pre">give</span></code>? The endpoint will create a UTxO at the vesting script address with an amount and a datum. If you recall, our datum
contains the beneficiary and the deadline. So, there are three pieces of information that we must pass to the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GiveParams</span> <span class="ow">=</span> <span class="kt">GiveParams</span>
   <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">POSIXTime</span>
   <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint doesn’t require any parameters because the beneficiary will just look for UTxOs sitting at the script address and can then check whether they
are the beneficiary and whether the deadline has passed. If so, they can consume them.</p>
<p>Let’s quickly look at the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">GiveParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">gp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">dat</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
                <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span>
                <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">gpDeadline</span> <span class="n">gp</span>
                <span class="p">}</span>
        <span class="n">tx</span>  <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="n">dat</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="n">gpAmount</span> <span class="n">gp</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="n">typedValidator</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace to %s with deadline %s&quot;</span>
        <span class="p">(</span><span class="n">gpAmount</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpDeadline</span> <span class="n">gp</span><span class="p">)</span>
</pre></div>
</div>
<p>First we compute the datum we want to use, and we can get both pieces of information from the <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code> which is passed into the function.</p>
<p>Then, for the transaction, we add a constraint that there must be an output at this script address with the datum that we just defined and a certain number of
lovelace, which we also get from the <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code>.</p>
<p>The rest of the function is as before, just with a different log message.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint is a bit more involved.</p>
<p>There can be many UTxOs at this script address and some of them might not be suitable for us, either because we are not the beneficiary, or because the deadline has
not yet passed. If we try to submit a transaction when there are no suitable UTxOs, we will pay fees, but get nothing in return.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">now</span>   <span class="ow">&lt;-</span> <span class="n">currentTime</span>
    <span class="n">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="n">scrAddress</span>
    <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="n">utxos</span>
        <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;no gifts available&quot;</span>
        <span class="kr">else</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
                <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>  <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">validator</span>
                <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span> <span class="o">&lt;&gt;</span>
                          <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
  <span class="kr">where</span>
    <span class="n">isSuitable</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">POSIXTime</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span> <span class="n">o</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">txOutDatumHash</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
        <span class="kt">Just</span> <span class="n">h</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">h</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span> <span class="kr">of</span>
            <span class="kt">Nothing</span>        <span class="ow">-&gt;</span> <span class="kt">False</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="kt">Datum</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">e</span> <span class="kr">of</span>
                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
                <span class="kt">Just</span> <span class="n">d</span>  <span class="ow">-&gt;</span> <span class="n">beneficiary</span> <span class="n">d</span> <span class="o">==</span> <span class="n">pkh</span> <span class="o">&amp;&amp;</span> <span class="n">deadline</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">now</span>
</pre></div>
</div>
<p>First, we get the current time and calculate our public key hash. We then look up all the UTxOs at this address and filter them using the <code class="docutils literal notranslate"><span class="pre">isSuitable</span></code> helper function,
which is defined in the <code class="docutils literal notranslate"><span class="pre">where</span></code> clause.</p>
<p>It first checks the datum hash, and, if it finds it, it attempts to look up the corresponding datum. Recall that the producing transaction, in this case <code class="docutils literal notranslate"><span class="pre">give</span></code> doesn’t
have to supply the datum, it need only supply the datum hash. However, in our case we need to have the datum available to the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint, so the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint
does provide the datum.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint finds the datum, it must deserialise it to the <code class="docutils literal notranslate"><span class="pre">Vesting</span></code> type.</p>
<p>If all of this succeeds we can check whether we are the beneficiary and whether the deadline has passed.</p>
<p>At this point, <code class="docutils literal notranslate"><span class="pre">utxos</span></code> contains all the UTxOs that we can consume. If we find none, then we just log a message to that effect. If there is at least one, then we
construct one transaction that consumes all of them as inputs and pays the funds to our wallet.</p>
<p>As <code class="docutils literal notranslate"><span class="pre">lookups</span></code>, we provide the list of UTxOs as well as the validator script. Recall that, in order to consume UTxOs at this address, the spending transaction must
provide the validation script.</p>
<p>We then create a transaction that spends all the suitable UTxOs along with a constraint that it must validate in the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which stretches from now until the end of time.
If we don’t provide the interval here, then validation will fail, because the default interval is from genesis until the end of time. The on-chain validation
would reject this as it needs an interval that is fully contained in the interval stretching from the deadline until the end of time.</p>
<p>We could use the singleton <code class="docutils literal notranslate"><span class="pre">Interval</span></code> <code class="docutils literal notranslate"><span class="pre">now</span></code>, but, if there were any issues, for example network delays, and the transaction arrived at a node a slot or
two later, then validation would no longer work.</p>
<p>The, we just bundle up the endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">VestingSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">give&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">grab&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">give&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">give</span>
    <span class="n">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;</span>  <span class="n">grab</span>
</pre></div>
</div>
<p>Then there is some boilerplate which is just used in the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSchemaDefinitions</span> <span class="kt">&#39;&#39;VestingSchema</span>

<span class="nf">mkKnownCurrencies</span> <span class="kt">[]</span>
</pre></div>
</div>
<div class="section" id="in-the-playground">
<h3>In the playground<a class="headerlink" href="#in-the-playground" title="Permalink to this headline">¶</a></h3>
<p>First, let’s add a third wallet. We are going to create a scenario where Wallet 1 makes two gifts to Wallet 2 with different deadlines and also makes one gift to Wallet 3.</p>
<div class="figure align-default">
<img alt="_images/pic__00043.png" src="_images/pic__00043.png" />
</div>
<p>Normally it would be possible to submit both <code class="docutils literal notranslate"><span class="pre">give</span></code> transactions in the same slot, but the way our code is implemented, we wait for confirmation, which means
we need to add a wait action. This is maybe not the best way to do it, but that’s how it is for the time being.</p>
<div class="figure align-default">
<img alt="_images/pic__00044.png" src="_images/pic__00044.png" />
</div>
<p>Here we run into our first problem. We need to supply the beneficiary address, but there is no way in the playground to get the public key
hash of a wallet.</p>
<p>But we can get it from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude Week03.Homework1&gt; :l src/Week03/Vesting.hs
Ok, one module loaded.
Prelude Week03.Vesting&gt; import Ledger
Prelude Ledger Week03.Vesting&gt; import Wallet.Emulator
Prelude Ledger Wallet.Emulator Week03.Vesting&gt; pubKeyHash $ walletPubKey $ Wallet 2
39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f
Prelude Ledger Wallet.Emulator Week03.Vesting&gt; pubKeyHash $ walletPubKey $ Wallet 3
dac073e0123bdea59dd9b3bda9cf6037f63aca82627d7abcd5c4ac29dd74003e
</pre></div>
</div>
<div class="figure align-default">
<img alt="_images/pic__00047.png" src="_images/pic__00047.png" />
</div>
<p>The next problem is the deadline. In the last lecture we saw how to convert between slots and POSIX times. This has changed. Previously you just needed a slot and out came
a POSIX time. Now there is a second argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger.TimeSlot</span>
<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">slotToBeginPOSIXTime</span>
<span class="nf">slotToBeginPOSIXTime</span> <span class="ow">::</span> <span class="kt">SlotConfig</span> <span class="ow">-&gt;</span> <span class="kt">Slot</span> <span class="ow">-&gt;</span> <span class="kt">POSIXTime</span>
</pre></div>
</div>
<p>There are also versions of <code class="docutils literal notranslate"><span class="pre">slotToBeginPOSIXTime</span></code> that have a begin and an end time. This is because a slot is not just a point in time, it’s a duration in time.</p>
<p>So what is this <code class="docutils literal notranslate"><span class="pre">SlotConfig</span></code>?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">SlotConfig</span>
<span class="kr">type</span> <span class="kt">SlotConfig</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">SlotConfig</span>
  <span class="ow">=</span> <span class="kt">SlotConfig</span> <span class="p">{</span><span class="n">scSlotLength</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">,</span> <span class="n">scZeroSlotTime</span> <span class="ow">::</span> <span class="kt">POSIXTime</span><span class="p">}</span>
        <span class="c1">-- Defined in ‘Ledger.TimeSlot’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">SlotConfig</span> <span class="c1">-- Defined in ‘Ledger.TimeSlot’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">SlotConfig</span> <span class="c1">-- Defined in ‘Ledger.TimeSlot’</span>
</pre></div>
</div>
<p>It takes the slot length and the time at which slot zero starts.</p>
<p>So now we have to find out what <code class="docutils literal notranslate"><span class="pre">SlotConfig</span></code> to use for the playground. Luckily, it’s the default. For that we need to use the <code class="docutils literal notranslate"><span class="pre">Data.Default</span></code> module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Default</span>
<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Default</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="n">def</span> <span class="ow">::</span> <span class="kt">SlotConfig</span>
<span class="kt">SlotConfig</span> <span class="p">{</span><span class="n">scSlotLength</span> <span class="ow">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">scZeroSlotTime</span> <span class="ow">=</span> <span class="kt">POSIXTime</span> <span class="p">{</span><span class="n">getPOSIXTime</span> <span class="ow">=</span> <span class="mi">1596059091000</span><span class="p">}}</span>
</pre></div>
</div>
<p>Now we can use <code class="docutils literal notranslate"><span class="pre">slotToBeginPOSIXTime</span></code> with the default config to get the POSIX time for slot 10 and slot 20.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Default</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="n">slotToBeginPOSIXTime</span> <span class="n">def</span> <span class="mi">10</span>
<span class="kt">POSIXTime</span> <span class="p">{</span><span class="n">getPOSIXTime</span> <span class="ow">=</span> <span class="mi">1596059101000</span><span class="p">}</span>

<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Default</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="n">slotToBeginPOSIXTime</span> <span class="n">def</span> <span class="mi">20</span>
<span class="kt">POSIXTime</span> <span class="p">{</span><span class="n">getPOSIXTime</span> <span class="ow">=</span> <span class="mi">1596059111000</span><span class="p">}</span>
</pre></div>
</div>
<p>And we can use these in the playground. We’ll use slot 10 as the deadline for the first and third <code class="docutils literal notranslate"><span class="pre">give``s</span> <span class="pre">and</span> <span class="pre">slot</span> <span class="pre">20</span> <span class="pre">for</span> <span class="pre">the</span> <span class="pre">second</span> <span class="pre">``give</span></code>. We’ll also give 10 Ada
in each case.</p>
<div class="figure align-default">
<img alt="_images/pic__00048.png" src="_images/pic__00048.png" />
</div>
<p>Let’s create a scenario where everything works. Wallet 3 grabs at slot 10 when the deadline for Wallet 3 has passed, and Wallet 2 grabs at slot 20, when both
the Wallet 2 deadlines have passed. We will use the <code class="docutils literal notranslate"><span class="pre">Wait</span> <span class="pre">Until..</span></code> option for this.</p>
<div class="figure align-default">
<img alt="_images/pic__00049.png" src="_images/pic__00049.png" />
</div>
<p>After evaluation, we first see the Genesis transaction.</p>
<div class="figure align-default">
<img alt="_images/pic__00050.png" src="_images/pic__00050.png" />
</div>
<p>If we look at the next transaction, we see the gift from Wallet 1 to Wallet 2 with the deadline of 10. Here, ten Ada get locked in the script address.</p>
<div class="figure align-default">
<img alt="_images/pic__00051.png" src="_images/pic__00051.png" />
</div>
<p>The next transaction is the gift from Wallet 1 to Wallet 2 with the deadline of 20. A new UTxO is now created at the script address with ten Ada.</p>
<div class="figure align-default">
<img alt="_images/pic__00052.png" src="_images/pic__00052.png" />
</div>
<p>And the third gift, this time to Wallet 3, with a deadline of 10. Wallet 1 now has about 70 Ada, and another UTxO is created with 10 Ada locked at the script address.</p>
<div class="figure align-default">
<img alt="_images/pic__00053.png" src="_images/pic__00053.png" />
</div>
<p>At slot 10, Wallet 3 grabs successfully. The third UTxO is the input, some fees are paid, and then the remainder of the lovelace is sent to Wallet 3.</p>
<div class="figure align-default">
<img alt="_images/pic__00054.png" src="_images/pic__00054.png" />
</div>
<p>Then at slot 20, Wallet 2 successfully grabs both the UTxOs for which they are the beneficiary. This time the fee is higher because two validators have to run.</p>
<div class="figure align-default">
<img alt="_images/pic__00055.png" src="_images/pic__00055.png" />
</div>
<p>The final balances reflect the changes.</p>
<div class="figure align-default">
<img alt="_images/pic__00056.png" src="_images/pic__00056.png" />
</div>
<p>Now let’s look at the case where the grab happens too early. We’ll make Wallet 2 grab at slot 15 instead of slot 20.</p>
<div class="figure align-default">
<img alt="" src="_images/pic__00010.png" />
</div>
<p>Now we see that the first transactions are the same, but that the final transaction at slot 15 has only one input, because the second UTxO is not yet available.</p>
<div class="figure align-default">
<img alt="_images/pic__00057.png" src="_images/pic__00057.png" />
</div>
<p>And we can see that there are 10 Ada still locked at the script address.</p>
<div class="figure align-default">
<img alt="_images/pic__00057.png" src="_images/pic__00057.png" />
</div>
<p>Our off-chain code was written in such a way that it will only submit a transaction if there is a suitable UTxO that can be grabbed. This means that we don’t really
exercise the validator because we are only sending transactions to the blockchain that will pass validation.</p>
<p>If you want to test the validator, you could modify the wallet code so that the grab endpoint attempts to grab everything and then validation will fail if you are not
the beneficiary or the deadline has not been reached.</p>
<p>You need to keep in mind that anybody can write off-chain code. So, even though it works now as long as you use the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint that we wrote ourselves, somebody
could write a different piece of off-chain code that doesn’t filter the UTxOs as we did. In this case, if the validator is not correct something could be horribly wrong.</p>
</div>
</div>
<div class="section" id="example-2-parameterized-contract">
<h2>Example 2 - Parameterized Contract<a class="headerlink" href="#example-2-parameterized-contract" title="Permalink to this headline">¶</a></h2>
<p>We’ll start the next example by copying the code from the vesting example into a new module called <code class="docutils literal notranslate"><span class="pre">Week03.Parameterized</span></code>.</p>
<div class="section" id="on-chain">
<h3>On-Chain<a class="headerlink" href="#on-chain" title="Permalink to this headline">¶</a></h3>
<p>Note that in the vesting example we used the <code class="docutils literal notranslate"><span class="pre">Vesting</span></code> type as the datum, but it was just fixed, it didn’t change. Alternatively, we could have baked it into the contract, so to speak,
so that we have a contract where the script itself already contains the beneficiary and deadline information.</p>
<p>All the examples of contracts we have seen so far were fixed. We used a <code class="docutils literal notranslate"><span class="pre">TypedValidator</span></code> as a compile-time constant. The idea of parameterized scripts is that you can
have a parameter and, depending on the value of the parameter, you get different values of <code class="docutils literal notranslate"><span class="pre">TypedValidator</span></code>.</p>
<p>So, instead of defining one script, with a single script address, with all UTxOs sitting at the same address, you can define a family of
scripts that are parameterized by a given parameter. In our case, this will mean that UTxOs for different beneficiaries and/or deadlines will be a different script addresses, as
they will have parameterized validators specific to their parameters rather than specific to the datum of the UTxO.</p>
<p>We are going to demonstrate how to do this by, instead of using datum for the beneficiary and deadline values, using a parameter.</p>
<p>Let’s start by renaming <code class="docutils literal notranslate"><span class="pre">VestingDatum</span></code> to something more suitable.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingParam</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
      <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
      <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">POSIXTime</span>
      <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>We will also remove the <code class="docutils literal notranslate"><span class="pre">unstableMakeIsData</span></code> call as we don’t need this anymore.</p>
<p>The reason we don’t need it, is because we are just going to use <code class="docutils literal notranslate"><span class="pre">()</span></code> for the datum in the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function. All the information we require will be in a new argument
to <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code>, of type <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>, which we add at the beginning of the list of arguments.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="n">p</span> <span class="nb">()</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">signedByBeneficiary</span> <span class="o">&amp;&amp;</span>
                          <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span> <span class="n">deadlineReached</span>
  <span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">signedByBeneficiary</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">signedByBeneficiary</span> <span class="ow">=</span> <span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">beneficiary</span> <span class="n">p</span>

    <span class="n">deadlineReached</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">deadlineReached</span> <span class="ow">=</span> <span class="n">contains</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="n">deadline</span> <span class="n">p</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>We also change the <code class="docutils literal notranslate"><span class="pre">Vesting</span></code> type to reflect the change to the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ValidatorTypes</span> <span class="kt">Vesting</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Now, the <code class="docutils literal notranslate"><span class="pre">TypedValidator</span></code> will no longer be a constant value. Instead it will take a parameter.</p>
<p>Recall that the function <code class="docutils literal notranslate"><span class="pre">mkTypedValidator</span></code> requires as its first argument the compiled code of a function that takes three arguments and returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. But now, it has four arguments,
so we need to account for that.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Vesting</span>
<span class="nf">typedValidator</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Vesting</span>
</pre></div>
</div>
<p>Now, what we would like to do is something like this, passing in the new parameter <code class="docutils literal notranslate"><span class="pre">p</span></code> to <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> so that the compiled code within the Oxford brackets would have the correct type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>  <span class="c1">-- this won&#39;t work</span>
  <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="n">p</span> <span class="o">||</span><span class="p">])</span>
  <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
  <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>This code will not work, but before we investigate, let’s leave the code as it is for now and make some more changes to the rest of the code.</p>
<p><code class="docutils literal notranslate"><span class="pre">validator</span></code> now will take a <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code> and will return a composed function. The returned function has the effect that any paramater passed to <code class="docutils literal notranslate"><span class="pre">validator</span></code> would now effectively
get passed to the <code class="docutils literal notranslate"><span class="pre">typedValidator</span></code> function, whose return value would in turned get passed to the <code class="docutils literal notranslate"><span class="pre">validatorScript</span></code> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">validator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">typedValidator</span>
</pre></div>
</div>
<p>And the same for <code class="docutils literal notranslate"><span class="pre">valHash</span></code> and <code class="docutils literal notranslate"><span class="pre">scrAddress</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">valHash</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">ValidatorHash</span>
<span class="nf">valHash</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorHash</span> <span class="o">.</span> <span class="n">typedValidator</span>

<span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">validator</span>
</pre></div>
</div>
<p>Now, let’s find out what’s wrong with out <code class="docutils literal notranslate"><span class="pre">typedValidator</span></code> function.</p>
<p>If we try to launch the REPL, we get a compile error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GHC</span> <span class="kt">Core</span> <span class="n">to</span> <span class="kt">PLC</span> <span class="n">plugin</span><span class="kt">:</span> <span class="kt">E043:Error:</span> <span class="kt">Reference</span> <span class="n">to</span> <span class="n">a</span> <span class="n">name</span> <span class="n">which</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">local</span><span class="p">,</span> <span class="n">a</span> <span class="n">builtin</span><span class="p">,</span> <span class="n">or</span> <span class="n">an</span> <span class="n">external</span> <span class="kt">INLINABLE</span> <span class="n">function</span><span class="kt">:</span> <span class="kt">Variable</span> <span class="n">p</span>
<span class="kt">No</span> <span class="n">unfolding</span>
<span class="kt">Context:</span> <span class="kt">Compiling</span> <span class="n">expr</span><span class="kt">:</span> <span class="n">p</span>
<span class="kt">Context:</span> <span class="kt">Compiling</span> <span class="n">expr</span><span class="kt">:</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Parameterized</span><span class="o">.</span><span class="n">mkValidator</span> <span class="n">p</span>
<span class="kt">Context:</span> <span class="kt">Compiling</span> <span class="n">expr</span> <span class="n">at</span> <span class="s">&quot;plutus-pioneer-program-week03-0.1.0.0-inplace:Week03.Parameterized:(67,10)-(67,48)&quot;</span>
</pre></div>
</div>
<p>The problem is this line.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- this won&#39;t work</span>
<span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="n">p</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>Recall that everything inside the Oxford brackets must be explicitly known at compile time. Normally it would even need all the code to be written explicitly, but
by using the <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma on the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function we can reference the function instead. However, it must still be known at compile time, because that’s
how Template Haskell works - it is executed before the main compiler.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">p</span></code> is not known at compile time, because we intend to supply it at runtime. Luckily there is a way around this.</p>
<p>On the Haskell side, we have our <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function and we have <code class="docutils literal notranslate"><span class="pre">p</span></code> of type <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>. We can compile <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> to Plutus, but we can’t compile <code class="docutils literal notranslate"><span class="pre">p</span></code> to Plutus
because we don’t know what it is. But, if we could get our hands on the compiled version of <code class="docutils literal notranslate"><span class="pre">p</span></code>, we could apply this compiled version to the compiled <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code>, and this
would give us what we want.</p>
<p>This seems to solve nothing, because we still need a compiled version of <code class="docutils literal notranslate"><span class="pre">p</span></code> and we have the same problem that <code class="docutils literal notranslate"><span class="pre">p</span></code> is not known at compile time.</p>
<p>However, <code class="docutils literal notranslate"><span class="pre">p</span></code> is not some arbitrary Haskell code, it’s data, so it doesn’t contain any function types. If we make the type of <code class="docutils literal notranslate"><span class="pre">p</span></code> an instance of a type class called <code class="docutils literal notranslate"><span class="pre">Lift</span></code>.
We can use <code class="docutils literal notranslate"><span class="pre">liftCode</span></code> to compile <code class="docutils literal notranslate"><span class="pre">p</span></code> at runtime to Plutus Core and then, using <code class="docutils literal notranslate"><span class="pre">applyCode</span></code> we can apply the Plutus Core <code class="docutils literal notranslate"><span class="pre">p</span></code> to the Plutus Core <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code>.</p>
<div class="section" id="the-lift-class">
<h4>The Lift Class<a class="headerlink" href="#the-lift-class" title="Permalink to this headline">¶</a></h4>
<p>Let’s briefly look at the <code class="docutils literal notranslate"><span class="pre">Lift</span></code> class. It is defined in package <code class="docutils literal notranslate"><span class="pre">plutus-tx</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift.Class</span>
</pre></div>
</div>
<p>It only has one function, <code class="docutils literal notranslate"><span class="pre">Lift</span></code>. However, we won’t use this function directly.</p>
<p>The importance of the class is that it allows us to, at runtime, lift Haskell values into corresponding Plutus script values. And this is
exactly what we need to convert our parameter <code class="docutils literal notranslate"><span class="pre">p</span></code> into code.</p>
<p>We will use a different function, defined in the same package but in a different module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift</span>
</pre></div>
</div>
<p>The function we will use is called <code class="docutils literal notranslate"><span class="pre">liftCode</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Get a Plutus Core program corresponding to the given value as a &#39;CompiledCodeIn&#39;, throwing any errors that occur as exceptions and ignoring fresh names.</span>
<span class="nf">liftCode</span>
   <span class="ow">::</span> <span class="p">(</span><span class="kt">Lift</span><span class="o">.</span><span class="kt">Lift</span> <span class="n">uni</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Throwable</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">PLC</span><span class="o">.</span><span class="kt">ToBuiltinMeaning</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">)</span>
   <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">CompiledCodeIn</span> <span class="n">uni</span> <span class="n">fun</span> <span class="n">a</span>
<span class="nf">liftCode</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">unsafely</span> <span class="o">$</span> <span class="n">safeLiftCode</span> <span class="n">x</span>
</pre></div>
</div>
<p>It takes a Haskell value of type <code class="docutils literal notranslate"><span class="pre">a</span></code>, provided <code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">Lift</span></code> class, and turns it into a piece of Plutus script code corresponding to the same type.</p>
<p>Now we can fix our validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Vesting</span>
<span class="nf">typedValidator</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Vesting</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">p</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>This code is fine, but it won’t yet compile, because <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code> is not an instance of <code class="docutils literal notranslate"><span class="pre">Lift</span></code>. To fix this, we can use <code class="docutils literal notranslate"><span class="pre">makeLift</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">makeLift</span> <span class="kt">&#39;&#39;VestingParam</span>
</pre></div>
</div>
<p>And, we need to enable a GHC extension.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
</pre></div>
</div>
<p>Now it will compile.</p>
</div>
</div>
<div class="section" id="off-chain">
<h3>Off-Chain<a class="headerlink" href="#off-chain" title="Permalink to this headline">¶</a></h3>
<p>The off-chain code hasn’t changed much.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code> are still the same.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GiveParams</span> <span class="ow">=</span> <span class="kt">GiveParams</span>
      <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
      <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">POSIXTime</span>
      <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
      <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VestingSchema</span></code> has slightly changed because the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint now relies on knowing the beneficiary and deadline in order to know
determine the script address. We know the beneficiary because it will be the public key hash of the wallet that calls <code class="docutils literal notranslate"><span class="pre">grab</span></code>, but we don’t know the deadline, so we must
pass it to <code class="docutils literal notranslate"><span class="pre">grab</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">VestingSchema</span> <span class="ow">=</span>
          <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">GiveParams</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="kt">POSIXTime</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint is similar to the vesting example, but there are some differences.</p>
<p>Instead of computing the datum, we will construct something of type <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>. We also change the reference to the datum in <code class="docutils literal notranslate"><span class="pre">mustPayToTheScript</span></code> to become <code class="docutils literal notranslate"><span class="pre">()</span></code>, and
we provide the type <code class="docutils literal notranslate"><span class="pre">p</span></code> to <code class="docutils literal notranslate"><span class="pre">typedValidator</span></code> as it is no longer a constant.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">GiveParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">gp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">p</span>  <span class="ow">=</span> <span class="kt">VestingParam</span>
                <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span>
                <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">gpDeadline</span> <span class="n">gp</span>
                <span class="p">}</span>
        <span class="n">tx</span> <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="nb">()</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="n">gpAmount</span> <span class="n">gp</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">typedValidator</span> <span class="n">p</span><span class="p">)</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace to %s with deadline %s&quot;</span>
        <span class="p">(</span><span class="n">gpAmount</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpDeadline</span> <span class="n">gp</span><span class="p">)</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint, there are also some changes.</p>
<p>Recall that earlier we got all the UTxOs sitting at this one script address and that they could be for arbitrary beneficiaries and for arbitrary deadlines. For this reason, we
had to filter those UTxOs which were for us and where the deadline had been reached.</p>
<p>We now have the additional parameter, which we’ll call <code class="docutils literal notranslate"><span class="pre">d</span></code>, which represents the deadline. So we can immediately see if the deadline has been reached or not.</p>
<p>If it has not been reached, we write a log message and stop, otherwise we continue and construct the <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>.</p>
<p>Then, we look up the UTxOs that are sitting at this address. Address is not a constant anymore, it takes a parameter. So, now, we will only get UTxOs which are for us and that
have a deadline that has been reached. We don’t need to filter anything.</p>
<p>If there are none, we log a message to that effect and stop, otherwise we do more or less what we did before.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="n">d</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">now</span>   <span class="ow">&lt;-</span> <span class="n">currentTime</span>
<span class="nf">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
<span class="kr">if</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">d</span>
    <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;too early&quot;</span>
    <span class="kr">else</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
                    <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">pkh</span>
                    <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">d</span>
                    <span class="p">}</span>
                    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">scrAddress</span> <span class="n">p</span>
                    <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="n">utxos</span>
                        <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;no gifts available&quot;</span>
                        <span class="kr">else</span> <span class="kr">do</span>
                            <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
                                <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>      <span class="o">&lt;&gt;</span>
                                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">validator</span> <span class="n">p</span><span class="p">)</span>
                                <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
                                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span> <span class="o">&lt;&gt;</span>
                                          <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
                            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
                            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
                            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">endpoints</span></code> function is slightly different due to the new parameter for <code class="docutils literal notranslate"><span class="pre">grab</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">VestingSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">give&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">grab&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">give&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">give</span>
    <span class="n">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">grab</span>
</pre></div>
</div>
</div>
<div class="section" id="back-to-the-playground">
<h3>Back to the playground<a class="headerlink" href="#back-to-the-playground" title="Permalink to this headline">¶</a></h3>
<p>We will now copy and paste this new contract into the playground and setup a new scenario.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">give</span></code> transactions are the same.</p>
<div class="figure align-default">
<img alt="_images/pic__00059.png" src="_images/pic__00059.png" />
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> is slightly different. In our earlier implementation, one wallet could grab UTxOs with different deadlines provided that the deadlines had passed. Now the deadline
is part of the script parameter, so we need to specify it in order to get the script address. This means that Wallet 2 cannot grab the gifts for slots 10 and 20 at the same time,
at least not in the way that we have implemented it.</p>
<p>First we can wait until slot 10 and then Wallet 2 should be able to grab its first gift and Wallet 3 should be able to claim its single gift.</p>
<p>We’ll add a <code class="docutils literal notranslate"><span class="pre">grab</span></code> for Wallets 2 and 3. Here, we don’t need to wain in between each transaction because it is two different wallets.</p>
<p>We then wait until slot 20 and perform Wallet 2’s second <code class="docutils literal notranslate"><span class="pre">grab</span></code> and then wait for 1 block, as usual.</p>
<div class="figure align-default">
<img alt="_images/pic__00060.png" src="_images/pic__00060.png" />
</div>
<p>So let’s see if it works by clicking <code class="docutils literal notranslate"><span class="pre">Evaluate</span></code>.</p>
<div class="figure align-default">
<img alt="_images/pic__00061.png" src="_images/pic__00061.png" />
</div>
<p>Take note of the script address for that transaction out at slot 1.</p>
<div class="figure align-default">
<img alt="_images/pic__00062.png" src="_images/pic__00062.png" />
</div>
<p>And compare this with the script address for the transaction output at slot 2.</p>
<div class="figure align-default">
<img alt="_images/pic__00063.png" src="_images/pic__00063.png" />
</div>
<p>Notice that the script address for the UTxOs is different. In our first version of the vesting contract, the script address was a constant. This meant that all our gifts ended up
at the same script address and only the datum in each UTxO was different.</p>
<p>Now, the datum is just <code class="docutils literal notranslate"><span class="pre">()</span></code> and the beneficiary and the deadline are included as part of the script itself, so the addresses are now different depending on the beneficiary and
deadline parameters.</p>
<p>For the gift to Wallet 3 we see yet another address.</p>
<div class="figure align-default">
<img alt="_images/pic__00064.png" src="_images/pic__00064.png" />
</div>
<p>We see two grabs in slot 10, one by Wallets 2 and one by Wallet 3. The order in which they are processed is not deterministic.</p>
<p>Then, finally in slot 20, Wallet 2 grabs its remaining gift.</p>
<p>And the final balances reflect the transactions that have occurred.</p>
<div class="figure align-default">
<img alt="_images/pic__00065.png" src="_images/pic__00065.png" />
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
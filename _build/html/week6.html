

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Week 06 - Oracles &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="plutus_pioneer_program.html">1. Plutus Pioneer Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="alonzo_white.html">1. Alonzo White Walkthrough</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Week 06 - Oracles</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week6.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-06-oracles">
<h1>Week 06 - Oracles<a class="headerlink" href="#week-06-oracles" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=Tr2VBm8vOhw">Lecture
#6</a>.</p>
<p>In this lecture we learn about oracles and using the PAB (Plutus Application Backend).</p>
<p>These notes use Plutus commit 476409eaee94141e2fe076a7821fc2fcdec5dfcb</p>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>In this lecture we are going to look at a case study, to see how what we have learned so far can be turned into an actual application. A collection of executables that even come with a little front end.</p>
<p>It will be a real dApp, apart from the fact that we don’t have a real blockchain available yet. This will run on a
simulated blockchain - a mockchain.</p>
<p>The example we are going to use for this is to implement a very simple oracle.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the blockchain world, an oracle is a way to get real-world information onto the blockchain, in order to
make it usable in smart contracts.</p>
</div>
<p>There are numerous examples of use cases for oracles. We can think of external data sources such as weather data, election
results, stock exchange data or randomness. You may have a betting contract that depends on the outcome of a specific
sports game, for example.</p>
<p>There are various ways to implement oracles, of varying sophistication.</p>
<p>We are going to use a very simple approach, where we have one trusted data provider. And, as an example of data, we
are going to use the ADA/USD exchange rate.</p>
<p>There are lots of problems with this approach, as we have to trust the data source. There are ways to mitigate the risk
that the data source is either untrustworthy or unreliable. For example, we could ask the provider to put down some
collateral that is lost if data is not provided or is inaccurate. Or, you could combine several oracles into one
and only accept the result if they all agree, or take the median, or average value of various sources. You could also
come up with more sophisticated mechanisms.</p>
<p>As we know, for anything to happen on the blockchain, there must be a UTxO, so the obvious thing to do is to represent
the data feed as a UTxO. The UTxO sits at the script address of the oracle, and its datum field it carries the current
value of the oracle data.</p>
<div class="figure align-default">
<img alt="_images/week06__00000.png" src="_images/week06__00000.png" />
</div>
<p>And this is where we find our first problem. As we have noted before, validation only happens when you want to consume
something from a script address, not when you produce an output at a script address. This means that we can’t prevent
anybody producing arbitrary outputs at the script address.</p>
<div class="figure align-default">
<img alt="_images/week06__00001.png" src="_images/week06__00001.png" />
</div>
<p>Somehow we need to distinguish the true oracle output from other outputs that may be sitting at the same script address.
And the way we do this is to put an NFT on the output. Because an NFT can only exist once, there can only be one UTxO
at the script address that holds the NFT.</p>
<div class="figure align-default">
<img alt="_images/week06__00002.png" src="_images/week06__00002.png" />
</div>
<p>How can such an oracle be used?</p>
<p>Here we come to something we haven’t seen before. In all our code writing validators and contracts, we always knew the
full API up front. In the case of an oracle, this is different. At the point that an oracle is created, you don’t know how
people may want to use it. It must be like an open API, able to work with smart contracts that have not yet been
designed.</p>
<p>As an example of a use-case that might make use of this specific oracle, let’s consider a swap contract where, at the swap
address, somebody can deposit ADA, and then somebody else can take those ADA in exchange for USD.</p>
<div class="figure align-default">
<img alt="_images/week06__00003.png" src="_images/week06__00003.png" />
</div>
<p>Of course, we don’t have USD directly on the blockchain, but we can imagine that they are represented by some native token.</p>
<p>In this example, as the value at the oracle is 1.75, then if someone offers 100 ADA, the price for that should be
175 USD.</p>
<p>In addition to this, we need an incentive for the oracle to provide the data, because in additional to other costs for
providing the data, at a minimum they would have to pay fees to create the UTxO.</p>
<p>So, let’s say that the oracle provider determines a fee of 1 ADA that has to be paid each time the oracle is used.</p>
<p>In this example, that would mean that the person wanting to by the ADA would have to pay 175 USD to the seller of the ADA,
and 1 ADA to the oracle.</p>
<p>What will the transaction look like?</p>
<div class="figure align-default">
<img alt="_images/week06__00004.png" src="_images/week06__00004.png" />
</div>
<p>First of all, the swap validation logic will need access to the current oracle value, which means that the oracle UTxO must be an input to the transaction.</p>
<p>Then we have the oracle validation logic. In this case we want to use the oracle. So, let’s say we have a redeemer called <em>use</em>. Now, the oracle validator has
to check several things.</p>
<ol class="arabic simple">
<li><p>Is the NFT present in the consumed input?</p></li>
<li><p>Is there an output from the transaction at the same address containing the same NFT?</p></li>
<li><p>Is the value in the output UTxO the same as the input value?</p></li>
<li><p>Is the fee present?</p></li>
</ol>
<p>Now we can complete the transaction.</p>
<p>We consume two additional inputs - the fee paid by the buyer and the 100 ADA deposited by the seller. Then we have two additional outputs - the 175 USD to the seller, and the 100 ADA to the buyer. And for these new inputs and
outputs, it is the responsibility of the swap validator to make sure that it is correct. Whereas, the oracle validator is only interested with making sure that everything concerning the oracle is correct.</p>
<div class="figure align-default">
<img alt="_images/week06__00005.png" src="_images/week06__00005.png" />
</div>
<p>Just to emphasize, this swap contract is just an example. The oracle should be capable of working with many different smart contracts that want to make use of its data.</p>
<p>If this was all, then we wouldn’t need an oracle. If the value was fixed, so that it was always 1.75 then we could simply hard-code this into our contract. So, the value must be able to change. At least, in an example such
as this one where we have an exchange rate that can, of course, change over time. There may be other examples such as the result of a sports match, where it is a singular event in history, but in this case, it is important
that it be able to change.</p>
<p>This means that the oracle validator, in addition to the <em>use</em> redeemer, must be able to support another operation where the provider of the oracle can actually change the data.</p>
<p>So let’s say the the value changes from 1.75 to 1.77.</p>
<p>We know that on a (E)UTxO blockchain, nothing ever changes, so you can’t change the datum of an existing UTxO. All you can do is consume UTxOs and produce new ones.</p>
<p>We would have a transaction that uses an <em>update</em> redeemer. The validation logic is somewhat different. It is the same as before in that the NFT needs to be present in the consumed oracle input, and also needs to be
present in the new output. In addition to that, the transaction must be signed by the oracle provider. And, we can use this update transaction as an opportunity for the oracle provider to collect the fees.</p>
<p>We insist that the NFT be present in the output, but we don’t say anything about other values. All the fees that got there by other transactions using this oracle data can be collected during the <em>update</em> transaction.</p>
<div class="figure align-default">
<img alt="_images/week06__00006.png" src="_images/week06__00006.png" />
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>To sum up, we represent the oracle by a UTxO and identify the correct UTxO with an NFT. The oracle value is the datum of the UTxO. We support two operations.</p>
<p>One is <em>use</em> which uses the oracle in some arbitrary
transaction. The <em>use</em> validator will make sure that the consumed oracle input carries the NFT, that there is an output that again carries the NFT, doesn’t change the datum, and carries additional fees.</p>
<p>The second operation is <em>update</em> which can only be done by the oracle provider. For an <em>update</em> transaction, the oracle input must again carry the NFT, there must be an oracle output, also carrying the NFT. There are no
further restrictions. The datum can change, and the accumulated fees can be taken out.</p>
</div>
</div>
<div class="section" id="oracle-core">
<h2>Oracle Core<a class="headerlink" href="#oracle-core" title="Permalink to this headline">¶</a></h2>
<p>Now that we know how it is supposed to work, let’s look at some code.</p>
<div class="section" id="on-chain">
<h3>On-chain<a class="headerlink" href="#on-chain" title="Permalink to this headline">¶</a></h3>
<p>First, let’s look at the Plutus code that implements the oracle itself.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week06.Oracle.Core</span>
</pre></div>
</div>
<p>The oracle will be a parameterized contract, and it will depend on four fields.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Oracle</span> <span class="ow">=</span> <span class="kt">Oracle</span>
    <span class="p">{</span> <span class="n">oSymbol</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">oOperator</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">oFee</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">oAsset</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><em>oSymbol</em> is the currencySymbol of the NFT that is used to identify the transaction. We don’t need the token name as we will just use the empty string as the token name.</p></li>
<li><p><em>oOperator</em> is the owner of the oracle - the hash of the public key owner which can make updates</p></li>
<li><p><em>oFee</em> is the fee in lovelace that is due every time the oracle is used</p></li>
<li><p><em>oAsset</em> represents the asset class that we want to exchange rate for against Ada, which in our case will be some kind of USD token</p></li>
</ul>
<p>The redeemer will support two operations.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">OracleRedeemer</span> <span class="ow">=</span> <span class="kt">Update</span> <span class="o">|</span> <span class="kt">Use</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;OracleRedeemer</span>
</pre></div>
</div>
<p>We need to define the NFT asset class. As mentioned, we are going to use the empty string for the token name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE oracleTokenName #-}</span>
<span class="nf">oracleTokenName</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">oracleTokenName</span> <span class="ow">=</span> <span class="kt">TokenName</span> <span class="n">emptyByteString</span>
</pre></div>
</div>
<p>The <em>oracleAsset</em> will be used to identify the NFT - this is not to be confused with <em>oAsset</em>, defined above.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE oracleAsset #-}</span>
<span class="nf">oracleAsset</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">AssetClass</span>
<span class="nf">oracleAsset</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">oSymbol</span> <span class="n">oracle</span><span class="p">,</span> <span class="n">oracleTokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>We create a little helper function called <em>oracleValue</em>. This takes an output transaction and a function which looks up the datum, and then returns an <em>Integer</em>. The <em>Integer</em> represents the exchange rate (e.g. 1.75) multiplied
by a million. This avoids potential complications when using real numbers.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE oracleValue #-}</span>
<span class="nf">oracleValue</span> <span class="ow">::</span> <span class="kt">TxOut</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">DatumHash</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Datum</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="nf">oracleValue</span> <span class="n">o</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">dh</span>      <span class="ow">&lt;-</span> <span class="n">txOutDatum</span> <span class="n">o</span>
    <span class="kt">Datum</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">dh</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">d</span>
</pre></div>
</div>
<p>This function is an example of monadic computation in monad that is not <em>IO</em> or the <em>Contract</em> monad. First we call <em>txOutDatum</em>, which can fail if because not every output has a datum. If it succeeds, we get a datum hash
which we can reference in <em>dh</em>. Next we used the function <em>f</em> which is provided as the second argument to maybe turn this datum hash into a datum. This too can fail. If it succeeds we can reference the result in <em>d</em>. <em>Datum</em>
is just a newtype wrapper around <em>Data</em>, so we can then use <em>PlutusTx.fromData</em> to maybe turn <em>d</em> into an <em>Integer</em>. Again, this can fail, because even if the datum is there, it may not be convertible to an integer value.</p>
<p>We will see in a moment where we use the <em>oracleValue</em> function.</p>
<p>The most important function is <em>mkOracleValidator</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkOracleValidator #-}</span>
<span class="nf">mkOracleValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">OracleRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkOracleValidator</span> <span class="n">oracle</span> <span class="n">x</span> <span class="n">r</span> <span class="n">ctx</span> <span class="ow">=</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span>  <span class="n">inputHasToken</span>  <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span> <span class="n">outputHasToken</span> <span class="o">&amp;&amp;</span>
    <span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
        <span class="kt">Update</span> <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;operator signature missing&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">oOperator</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                  <span class="n">traceIfFalse</span> <span class="s">&quot;invalid output datum&quot;</span>       <span class="n">validOutputDatum</span>
        <span class="kt">Use</span>    <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;oracle value changed&quot;</span>       <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>              <span class="o">&amp;&amp;</span>
                  <span class="n">traceIfFalse</span> <span class="s">&quot;fees not paid&quot;</span>              <span class="n">feesPaid</span>
  <span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">ownInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
    <span class="n">ownInput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;oracle input missing&quot;</span>
        <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>

    <span class="n">inputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">inputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">ownOutput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
    <span class="n">ownOutput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">getContinuingOutputs</span> <span class="n">ctx</span> <span class="kr">of</span>
        <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
        <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one oracle output&quot;</span>

    <span class="n">outputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">outputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">outputDatum</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
    <span class="n">outputDatum</span> <span class="ow">=</span> <span class="n">oracleValue</span> <span class="n">ownOutput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span>

    <span class="n">validOutputDatum</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">validOutputDatum</span> <span class="ow">=</span> <span class="n">isJust</span> <span class="n">outputDatum</span>

    <span class="n">feesPaid</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">feesPaid</span> <span class="ow">=</span>
      <span class="kr">let</span>
        <span class="n">inVal</span>  <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownInput</span>
        <span class="n">outVal</span> <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownOutput</span>
      <span class="kr">in</span>
        <span class="n">outVal</span> <span class="p">`</span><span class="n">geq</span><span class="p">`</span> <span class="p">(</span><span class="n">inVal</span> <span class="o">&lt;&gt;</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">))</span>
</pre></div>
</div>
<p>The function <em>mkOracleValidator</em> takes our parameter <em>Oracle</em>, the datum, which, in this example is an <em>Integer</em>, the redeemer type <em>OracleRedeemer</em> and finally the <em>ScriptContext</em>.</p>
<p>There are two cases for this validator - <em>use</em> and <em>update</em> - but there are similarities. In both cases we want to check that we have the input that holds the NFT and that there is an output that holds the NFT.</p>
<p>As both these checks need to be done regardless of the use case, they are done upfront.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span>  <span class="n">inputHasToken</span>  <span class="o">&amp;&amp;</span>
<span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span> <span class="n">outputHasToken</span> <span class="o">&amp;&amp;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>After this, we consider which use case we are dealing with.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
    <span class="kt">Update</span> <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;operator signature missing&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">oOperator</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="n">traceIfFalse</span> <span class="s">&quot;invalid output datum&quot;</span>       <span class="n">validOutputDatum</span>
    <span class="kt">Use</span>    <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;oracle value changed&quot;</span>       <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>              <span class="o">&amp;&amp;</span>
              <span class="n">traceIfFalse</span> <span class="s">&quot;fees not paid&quot;</span>              <span class="n">feesPaid</span>
</pre></div>
</div>
<p>Before looking at the <em>inputHasToken</em> function there is another help function to look at.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownInput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;oracle input missing&quot;</span>
    <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>
</pre></div>
</div>
<p>The <em>ownInput</em> function returns the <em>TxOut</em> that the script is trying to consume, which in this case is the oracle output. The <em>Nothing</em> case here can happen if we are in a
different context, such as a minting context, so this eventuality will not occur for us. The <em>findOwnInput</em> function is provided by Plutus and will, given the context,
find the relevant input. The <em>txInInfoResolved</em> function gets the <em>TxOut</em> from the <em>TxInInfo</em>.</p>
<p>The <em>inputHashToken</em> function checks that the token is present. It uses the <em>assetClassValueOf</em> function to look for the NFT within the <em>ownInput</em> response.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">inputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The next helper function, <em>ownOutput</em> checks that we have exactly one output and returns that output to us.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownOutput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownOutput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">getContinuingOutputs</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
    <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one oracle output&quot;</span>
</pre></div>
</div>
<p>We can use this for the <em>outputHasToken</em> helper function in the same way as we did for the <em>inputHashToken</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">outputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">outputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>That covers the code for the common cases. Now, let’s let at the code specific to the <em>update</em> case.</p>
<p>There are two conditions to check. The first is that the operator actually signed the transaction. This is so simple that we can do it inline without
a helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;operator signature missing&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">oOperator</span> <span class="n">oracle</span><span class="p">)</span>
</pre></div>
</div>
<p>The next thing to check is that the output datum. We know that the value can change, but we need to check that it is at least of the correct type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;invalid output datum&quot;</span> <span class="n">validOutputDatum</span>
</pre></div>
</div>
<p>And for this we have referenced a new helper function <em>validOutputDatum</em>, which itself makes use of a helper function <em>outputDatum</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">outputDatum</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="nf">outputDatum</span> <span class="ow">=</span> <span class="n">oracleValue</span> <span class="n">ownOutput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span>

<span class="nf">validOutputDatum</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">validOutputDatum</span> <span class="ow">=</span> <span class="n">isJust</span> <span class="n">outputDatum</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you look up <em>findDatum</em> in the REPL, you will see it has a type of <em>DatumHash -&gt; TxInfo -&gt; Maybe Datum</em>. As we are using its infix notation here, we
can pass in <em>info</em> as the only parameter, and this will result in the whole expression having the type <em>DatumHash -&gt; Maybe Datum</em>, which is the type we
need to pass into <em>oracleValue</em>.</p>
</div>
<p>This works by trying to get the datum value from the datum hash and then trying to create the oracle value from it. If it succeeds it will return a <em>Just Integer</em>,
otherwise it will return <em>Nothing</em>, so the <em>validOutputDatum</em> function just needs to check that the return value is not <em>Nothing</em>, in other words, that it
is a <em>Just</em>.</p>
<p>Note that we are not checking anything about the value of the <em>Integer</em>. This could even remain the same as the input value, if the transaction is used
just to collect the fees that have accumulated from the use the oracle.</p>
<p>The second case for <em>mkOracleValidator</em> is the <em>use</em> case. This case can be used by anyone, but it is much more restrictive.</p>
<p>First, we don’t allow the value to change. So this is the first condition.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;oracle value changed&quot;</span> <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>We have already written the <em>outputDatum</em> helper function. Instead of checking only that it is an <em>Integer</em>, here we also check that its output value is the same
as the input value.</p>
<p>And finally, we must check that the fees have been paid. And for this we use a new helper function called <em>feesPaid</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">feesPaid</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">feesPaid</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">inVal</span>  <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownInput</span>
    <span class="n">outVal</span> <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownOutput</span>
  <span class="kr">in</span>
    <span class="n">outVal</span> <span class="p">`</span><span class="n">geq</span><span class="p">`</span> <span class="p">(</span><span class="n">inVal</span> <span class="o">&lt;&gt;</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">))</span>
</pre></div>
</div>
<p>This <em>feesPaid</em> function checks that the output value is at least as much as the input value plus the required fee. We again use the semigroup operator
<em>&lt;&gt;</em> to add the fee value to the input value. We could have used equal (eq) instead of greater than or equal (geq). Using <em>geq</em> allows the user of the
oracle to give the oracle provider a tip, if they so wish.</p>
<p>So this now is basically the core business logic of the oracle as shown in the diagrams.</p>
<div class="figure align-default">
<img alt="_images/week06__00006.png" src="_images/week06__00006.png" />
</div>
<p>Now we have our usual boilerplate. In particular notice that we use the pattern that we need for a parameterized validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Oracling</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Oracling</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Oracling</span> <span class="ow">=</span> <span class="kt">Integer</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Oracling</span> <span class="ow">=</span> <span class="kt">OracleRedeemer</span>

<span class="nf">oracleInst</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Oracling</span>
<span class="nf">oracleInst</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Oracling</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkOracleValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">oracle</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">Integer</span> <span class="o">@</span><span class="kt">OracleRedeemer</span>

<span class="nf">oracleValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">oracleValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">oracleInst</span>

<span class="nf">oracleAddress</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">oracleAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">oracleValidator</span>
</pre></div>
</div>
<p>And this concludes the on-chain part of the oracle code.</p>
</div>
<div class="section" id="off-chain">
<h3>Off-chain<a class="headerlink" href="#off-chain" title="Permalink to this headline">¶</a></h3>
<p>We also create some off-chain code, namely to start the oracle, and to update it. However, we don’t write off-chain code to <em>use</em> the oracle. That is not the
responsibility of the author of this contract. That will be the responsibility of the person that wants to use the oracle - they will write the code to create the
transaction with the <em>use</em> redeemer. This is the first time that we have seen the situation where we have some on-chain code that is not paired with some off-chain code.</p>
<div class="section" id="starting-the-oracle">
<h4>Starting the Oracle<a class="headerlink" href="#starting-the-oracle" title="Permalink to this headline">¶</a></h4>
<p>To start the oracle, we need some parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">OracleParams</span> <span class="ow">=</span> <span class="kt">OracleParams</span>
    <span class="p">{</span> <span class="n">opFees</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">opSymbol</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">opToken</span>  <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>opFees</em> parameter represents the number of lovelace that will be charged to use the oracle.</p>
<p>The <em>opSymbol</em> and <em>opToken</em> parameters represent the token against which we are providing the Ada exchange rate, in this case a USD token.</p>
<p>First we create a <em>startOracle</em> function, whose responsibility is to mint the NFT that will be used to identify the oracle UTxO. The <em>startOracle</em> function will
not provide an initial value for the oracle, this will be handled by the <em>updateOracle</em> function. The reason for this is that, if we provided an initial value, it may
be outdated by the time the NFT is minted.</p>
<p>We could have used the same code for minting the NFT as we used in lecture 5. This would have worked perfectly well.</p>
<p>However, this is a currency module provided in <em>plutus-use-cases</em> that provides a <em>forgeContract</em> function that allows us to mint NFTs.</p>
<p>Here is the type of the <em>forgeContract</em> function shown in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Prelude Week06.Oracle.Core&gt; :t Plutus.Contracts.Currency.forgeContract
Plutus.Contracts.Currency.forgeContract
  :: (row-types-1.0.1.0:Data.Row.Internal.AllUniqueLabels
        (Plutus.Contract.Schema.Input s),
      row-types-1.0.1.0:Data.Row.Internal.AllUniqueLabels
        (Plutus.Contract.Schema.Output s),
      Plutus.Contracts.Currency.AsCurrencyError e,
      (Plutus.Contract.Schema.Input s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx-confirmation&quot;)
      ~ Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed,
      (Plutus.Contract.Schema.Input s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx&quot;)
      ~ Plutus.Contract.Effects.WriteTx.WriteTxResponse,
      (Plutus.Contract.Schema.Output s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx&quot;)
      ~ Ledger.Constraints.OffChain.UnbalancedTx,
      (Plutus.Contract.Schema.Output s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx-confirmation&quot;)
      ~ Plutus.V1.Ledger.TxId.TxId) =&gt;
     Plutus.V1.Ledger.Crypto.PubKeyHash
     -&gt; [(Plutus.V1.Ledger.Value.TokenName, Integer)]
     -&gt; Plutus.Contract.Types.Contract
          w s e Plutus.Contracts.Currency.OneShotCurrency
</pre></div>
</div>
<p>The important part starts towards the end, where the first parameter - of type <em>PubKeyHash</em> - is defined. This is the hash of the public key of the recipient of the NFT.</p>
<p>The <em>forgeContract</em> function provides more general functionality than our previous NFT contract. It allows is to generate multiple NFTs in one go. It will create a currency symbol that can only be used one, similar
to our NFT from last time, so there can only be one minting transaction. But for the one currency symbol, you can mint various tokens in the same transaction, with
various token names and in various quantities. The second parameter allows us to define these token names and quantities.</p>
<p>And it gives us a <em>Contract</em> that returns a value of the <em>OneShotCurrency</em> type. This type is specific to the currency and it doesn’t really matter to us what it is. All that matters
for us is that we can get the currency symbol out of it again.</p>
<p>There is one slight problem. This is not compatible with what we want. We want this types</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">Oracle</span>
</pre></div>
</div>
<p>An arbitrary writer type (because we don’t make use of it), an arbitrary schema (as long as we have <em>BlockChainActions</em> available), <em>Text</em> error messages and a return
type of <em>Oracle</em>.</p>
<p>The problem is that the <em>Contract</em> returned by <em>forgeContract</em> doesn’t allow <em>Text</em> error messages. You can see this in the verbose output from the REPL - there is
a constraint on the <em>e</em> parameter.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contracts</span><span class="o">.</span><span class="kt">Currency</span><span class="o">.</span><span class="kt">AsCurrencyError</span> <span class="n">e</span><span class="p">,</span>
</pre></div>
</div>
<p>Unfortunately <em>Text</em> doesn’t implement <em>AsCurrencyError</em>.</p>
<p>Luckily there is a function that can helper</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="n">mapError</span>
<span class="ow">::</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">e&#39;</span><span class="p">)</span>
   <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Types</span><span class="o">.</span><span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span>
   <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Types</span><span class="o">.</span><span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e&#39;</span> <span class="n">a</span>
</pre></div>
</div>
<p>Given a <em>Contract</em>, it allows us to create a new <em>Contract</em> with a new type of error message. That is provided we give a function that converts from the first error
type to the second error type.</p>
<p>So, let’s look at the <em>startOracle</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startOracle</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">OracleParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">Oracle</span>
<span class="nf">startOracle</span> <span class="n">op</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">osc</span> <span class="ow">&lt;-</span> <span class="n">mapError</span> <span class="p">(</span><span class="n">pack</span> <span class="o">.</span> <span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="n">forgeContract</span> <span class="n">pkh</span> <span class="p">[(</span><span class="n">oracleTokenName</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">CurrencyError</span> <span class="kt">OneShotCurrency</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">cs</span>     <span class="ow">=</span> <span class="kt">Currency</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="n">osc</span>
        <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">Oracle</span>
            <span class="p">{</span> <span class="n">oSymbol</span>   <span class="ow">=</span> <span class="n">cs</span>
            <span class="p">,</span> <span class="n">oOperator</span> <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">oFee</span>      <span class="ow">=</span> <span class="n">opFees</span> <span class="n">op</span>
            <span class="p">,</span> <span class="n">oAsset</span>    <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">opSymbol</span> <span class="n">op</span><span class="p">,</span> <span class="n">opToken</span> <span class="n">op</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;started oracle &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">oracle</span>
    <span class="n">return</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>Here we see the error conversion function is provided as <em>pack . show</em>. The <em>show</em> function converts the error to a <em>String</em> and the <em>pack</em> function converts a <em>String</em>
to a <em>Data.Text</em> type.</p>
<p>At this point, <em>osc</em> holds the <em>OneShotCurrency</em>, and we can then use the <em>currencySymbol</em> function to get the currency symbol as <em>cs</em>.</p>
<p>The <em>currencySymbol</em> function has type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">currencySymbol</span>
      <span class="ow">::</span> <span class="kt">OneShotCurrency</span> <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span><span class="o">.</span><span class="kt">CurrencySymbol</span>
</pre></div>
</div>
<p>And is used accordingly</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">cs</span> <span class="ow">=</span> <span class="kt">Currency</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="n">osc</span>
</pre></div>
</div>
<p>Now we have minted our NFT and it has currency symbol <em>cs</em>. And now we can construct our <em>Oracle</em> parameter value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracle</span> <span class="ow">=</span> <span class="kt">Oracle</span>
    <span class="p">{</span> <span class="n">oSymbol</span>   <span class="ow">=</span> <span class="n">cs</span>
    <span class="p">,</span> <span class="n">oOperator</span> <span class="ow">=</span> <span class="n">pkh</span>
    <span class="p">,</span> <span class="n">oFee</span>      <span class="ow">=</span> <span class="n">opFees</span> <span class="n">op</span>
    <span class="p">,</span> <span class="n">oAsset</span>    <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">opSymbol</span> <span class="n">op</span><span class="p">,</span> <span class="n">opToken</span> <span class="n">op</span><span class="p">)</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>The reason that <em>opSymbol</em> and <em>opToken</em> are defined separately in the <em>OracleParams</em> type <em>op</em> is just that this makes is easier when we are using the playground.</p>
</div>
<div class="section" id="updating-the-oracle">
<h4>Updating the Oracle<a class="headerlink" href="#updating-the-oracle" title="Permalink to this headline">¶</a></h4>
<p>The <em>updateOracle</em> function is more complicated.</p>
<p>This function has to deal with two cases. Namely, the case where we have a value that we wish to update, and the case where we have just started the oracle and we want
to create a value for the very first time.</p>
<p>It takes our oracle parameters and also the <em>Integer</em> value that we wish to have the oracle hold.</p>
<p>First we create a helper function <em>findOracle</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findOracle</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">))</span>
<span class="nf">findOracle</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">oracleAddress</span> <span class="n">oracle</span><span class="p">)</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span> <span class="kr">of</span>
        <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">oracleValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="n">dh</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
            <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="kr">_</span>           <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The purpose of <em>findOracle</em> is to look up the existing oracle UTxO. This can fail because the oracle might not be there. This will happen if we have just started the
oracles and have not yet created a UTxO with the oracle value. But, if we find it, we return a triple containing the UTxO identifer (TxOutRef), the UTxO itself, which
contains all the data (TxOutTx) and the oracle value (the current exchange rate held by the oracle). The <em>Integer</em> containing the oracle value is encoded also in the
TxOutTx value, but we add it to the triple to make it easier to work with.</p>
<p>The first thing we do is to get all the UTxOs sitting at this address. But only one of these will be the one we are looking for - the one that contains the NFT.</p>
<p>We do this by using the <em>Map.filter</em> function which takes a function as a parameter which, in this case, returns True for the UTxO where the NFT is present.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">oracleAddress</span> <span class="n">oracle</span><span class="p">)</span>
<span class="o">...</span>
<span class="kr">where</span>
  <span class="n">f</span> <span class="ow">::</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">f</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We will end up with a map in <em>utxos</em> which is either empty or contains one item. Now, we distinguish between these two cases.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span> <span class="o">$</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span> <span class="kr">of</span>
    <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">oracleValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="n">dh</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="kr">_</span>           <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>We convert the map to a list of tuples representing key value pairs of transaction ids and the transactions themselves.</p>
<p>For the case where there is no element, we use the _ case to represent all other cases. This could only ever be the empty list, but the compiler doesn’t know that.</p>
<p>If, however, we have found the UTxO, then, as we already have its id and transaction, we just need to find its <em>Integer</em> value. This part could still go wrong. Even
though we have found the correct UTxO, there could be some corrupt data in it for whatever reason.</p>
<p>We use the <em>oracleValue</em> function that we used also in validation. This function takes a <em>TxOut</em> parameter followed by a second parameter is a function, which, given a datum hash will return the associated datum.</p>
<p>In the off-chain code, we can use the following function parameter</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">dh</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
</pre></div>
</div>
<p>Here, <em>txData</em> is a field of the transaction and it is a map from datum hashes to datums. We get the transaction from <em>txOutTxTx o</em>.</p>
<p>If this all succeeds, when will return the triple (oref, o, x), where x is the <em>Integer</em> value of the oracle.</p>
<p>Now that we have written the <em>findOracle</em> function we can look at the <em>updateOracle</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">updateOracle</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">updateOracle</span> <span class="n">oracle</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
    <span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="n">x</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="mi">1</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="n">c</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;set initial oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span>  <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>     <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">scriptInstanceLookups</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">c</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Update</span><span class="p">)</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Oracling</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;updated oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>After the <em>findOracle</em> line there is a helper function definition, as we will need this constraint twice.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="n">x</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>After looking for the oracle, there are wo possibilities - either we found it or we did not.</p>
<p>If we didn’t find it, then we have started the oracle but we have not yet provided an initial value. This is the first case. And in this case, all we have to
do is to submit a transaction that produces the first value for the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="n">c</span>
<span class="nf">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;set initial oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>Here is the first usage of the <em>c</em> helper function. It provides the constraint <em>mustPayToTheScript</em> which ensures that the transaction will have an output
that pays to a script address. As arguments it takes the datum <em>x</em> and the NFT. The script that it must pay to is always the script that is in focus - here it is
the first parameter to <em>submitTxConstraints</em> - <em>(oracleInst oracle)</em>.</p>
<p>We then wait for confirmation and write a log message. And this is all we need to do for this case.</p>
<p>In the other case, where we already have a value, we need to reference the UTxO parts, but we don’t care about the current datum, as we are going to update it anyway.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span>  <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
</pre></div>
</div>
<p>Now it gets a bit more complicated, because now we need two conditions.</p>
<p>The first constraint is the same as in the other case - the constraint referenced by the helper function <em>c</em>. But there is now an extra constraint that we must also
consume the existing UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="n">c</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Update</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>mustSpendScriptOutput</em> function is basically the opposite of <em>mustPayToTheScript</em>. It creates an input to this script address. As parameters it takes the reference
to the UTxO we want to consume, and it takes a <em>Redeemer</em>. In this case the <em>Redeemer</em> is <em>Update</em> and it is converted to the Plutus <em>Data</em> type.</p>
<p>In order for this to work we need to provide some lookups.</p>
<p>In order to find the output <em>oref</em> that it wants to spend, we must use the <em>unspentOutputs</em> lookup, and in this case, we just provide the lookup with one UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we must provide the script instances. We need to do this twice, once for the input side, and once for the output side. For this, we provide the oracle instance and
the oracle validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">scriptInstanceLookups</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
<span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
</pre></div>
</div>
<p>We didn’t need to provide the <em>scriptInstanceLookups</em> lookup in the first case, as we were able to pass <em>oracleInst oracle</em> to the <em>submitTxConstraints</em> function. However,
with the <em>submitTxConstraintsWith</em> function, we don’t have that option.</p>
<p>When submitting the transaction, we need to give the compiler a little nudge to let it know the script we are talking about - so that it knows, for example, what The Script is in <em>mustPayToTheScript</em>. For
this we reference the <em>Oracling</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Oracling</span> <span class="n">lookups</span> <span class="n">tx</span>
</pre></div>
</div>
<p>Hopefully now we have a valid transaction that gets submitted, and then we wait for it to be confirmed, and write some logging information.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;updated oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>Remember, we talked about fee collecting earlier. This will happen automatically. The function <em>submitTxConstraintsWith</em> will send the fees to our own wallet. It does
this because there is an imbalance between the value attached to the input, which includes the fees and the NFT, and the value we have said must be paid to the script,
which is just the NFT.</p>
<p>This process will also automatically create an extra input from our own input to pay the transaction fees for executing the transaction.</p>
<p>Lastly, we provide a function that combines these two operations, <em>startOracle</em> and <em>updateOracle</em> into one contract. This will make it possible to use in the playground
and the <em>EmulatorTrace</em> monad, as well as in the PAB.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">OracleSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;update&quot;</span> <span class="kt">Integer</span>

<span class="nf">runOracle</span> <span class="ow">::</span> <span class="kt">OracleParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">runOracle</span> <span class="n">op</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">oracle</span> <span class="ow">&lt;-</span> <span class="n">startOracle</span> <span class="n">op</span>
    <span class="n">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">oracle</span>
    <span class="n">go</span> <span class="n">oracle</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span>
        <span class="n">updateOracle</span> <span class="n">oracle</span> <span class="n">x</span>
        <span class="n">go</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>The function <em>runOracle</em> first starts the oracle. Then, for reasons that will become clear later, we use <em>tell</em> to write the oracle parameter. We need to be able to
communicate the parameter value of the oracle to the outside world, so that people can use the oracle. We will not know until runtime the currency symbol that will be used
for the NFT, so we don’t know the value of the oracle parameter yet.</p>
<p>Remember that <em>tell</em> expects a <em>Monoid</em> type. The typical example is a list of strings that get concatenated to one list of all log messages.</p>
<p>But it doesn’t have to be lists. In <em>Data.Monoid</em> we have this <em>Last</em> Monoid.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Monoid</span> <span class="p">(</span><span class="kt">Last</span> <span class="p">(</span><span class="o">..</span><span class="p">))</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Monoid</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Last</span>
<span class="kr">type</span> <span class="kt">Last</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">newtype</span> <span class="kt">Last</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Last</span> <span class="p">{</span><span class="n">getLast</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span><span class="p">}</span>
      <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Ord</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Read</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Traversable</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Traversable’</span>
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Foldable’</span>
</pre></div>
</div>
<p>We see that it is just a <em>newtype</em> wrapper around <em>Maybe</em>. The point is to provide a specific <em>Monoid</em> instance. The idea, as the name suggests, is that it is
a monoid operation that always remembers the last Just value. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Monoid</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;x&#39;</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;y&#39;</span><span class="p">)</span>
<span class="kt">Last</span> <span class="p">{</span><span class="n">getLast</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="sc">&#39;y&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>However, if the second <em>Last</em> is a nothing, it will return the first one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Monoid</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;x&#39;</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Last</span> <span class="kt">Nothing</span>
<span class="kt">Last</span> <span class="p">{</span><span class="n">getLast</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="sc">&#39;x&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>If both are <em>Nothing</em>, it will be <em>Nothing</em>.</p>
<p><em>Last</em> is very useful because it allows us to keep the current state. The value of the log will basically be the last <em>Just</em> we told.</p>
<p>In this contract we will only do that once. In the beginning it will be <em>Last Nothing</em>. Then we mint the NFT, and then, when we get the oracle value in
<em>runOracle</em>, and then <em>tell</em> it, it will always have that value. If other contracts from the outside query the state, they will always get the <em>Just oracle</em>, so
they will be able to discover the value of the oracle.</p>
<p>So, next in <em>runOracle</em>, we call the helper function <em>go</em>. What this does is to block at the update endpoint. As soon as someone provides an <em>Integer</em> as the new value,
it will call the <em>updateOracle</em> function with the new value, and then just loop to go again.</p>
<p>In summary, <em>runOracle</em> starts the oracle, <em>tell</em>s the oracle, then loops to allow others to update the oracle.</p>
<p>And that concludes the code for the oracle itself. What is now missing is an example, a contract that actually uses the oracle - a swap contract. And also using the
Plutus Application Backend to run this code in the real world or, in our case, in a simulated blockchain.</p>
</div>
</div>
</div>
<div class="section" id="swap-validation">
<h2>Swap Validation<a class="headerlink" href="#swap-validation" title="Permalink to this headline">¶</a></h2>
<p>Our example swap contract can be found in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week06.Oracle.swap</span>
</pre></div>
</div>
<p>The purpose of this contract is for someone to be able to deposit ADA and exchange it for a token, in our case a token that we will call USDT for US Dollar Token.</p>
<p>The idea is that the price, the amount of USDT that will be required to be paid for the ADA, will be determined by the value of the oracle. Remember that we are using
an <em>Integer</em> to reflect the exchange rate, with a value of one million being equal to one USDT.</p>
<p>We’ll start with a helper function called <em>price</em>, which, given a number of lovelace and the exchange rate, returns the USDT price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">price</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">price</span> <span class="n">lovelace</span> <span class="n">exchangeRate</span> <span class="ow">=</span> <span class="p">(</span><span class="n">lovelace</span> <span class="o">*</span> <span class="n">exchangeRate</span><span class="p">)</span> <span class="p">`</span><span class="n">divide</span><span class="p">`</span> <span class="mi">1000000</span>
</pre></div>
</div>
<p>The next helper function, <em>lovelaces</em>, combines to functions from the Plutus libraries to extract a number of lovelace from a <em>Value</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>Now we will write <em>mkSwapValidator</em>. This is a parameterized validator with two parameters.</p>
<p>The first parameter is the oracle that we are using. To use this, we import the oracle module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Week06.Oracle.core</span>
</pre></div>
</div>
<p>The second parameter is the address of the oracle. Normally, given the oracle, we would be able to compute the address from it. In the core module we saw a function
<em>oracleAddress</em> which does this for us. But this is a function that we can’t use in the validator, because it can’t be compiled to Plutus script. So, here, we explicitly
hand the address to the validator.</p>
<p>For the datum, we use the public key hash of the seller. We don’t use a redeemer, so we give it a type of Unit.</p>
<p>We recall from the diagram, the swap transaction should have three inputs and three outputs.</p>
<div class="figure align-default">
<img alt="_images/week06__00006.png" src="_images/week06__00006.png" />
</div>
<table class="colwidths-given docutils align-default" id="id1">
<caption><span class="caption-text">Swap Transaction Inputs and Outputs</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Inputs</p></th>
<th class="head"><p>Outputs</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>The oracle, to check the current exchange rate</p></td>
<td><p>The oracle, which we don’t need to look at in the swap validation</p></td>
</tr>
<tr class="row-odd"><td><p>The swap UTxO that holds the lovelace</p></td>
<td><p>The tokens for the seller</p></td>
</tr>
<tr class="row-even"><td><p>The source of the buyer’s funds</p></td>
<td><p>The lovelace for the buyer</p></td>
</tr>
</tbody>
</table>
<p>Note that we don’t need to worry about the oracle as an output. The oracle validator takes care of ensuring that the value is not changed and that the fees are added.</p>
<p>We also want to support the second use case, the case where the seller can retrieve the ADA tokens in the case that they no longer want to do the swap. If we don’t
support this case, the ADA could be locked there forever, if nobody ever decides to make the swap.</p>
<p>This second case is the condition we check in the validator. If the seller themselves signs the transaction, there are no further constraints - we don’t need to check
the oracle or anything else - the seller can just get back their lovelace.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSwapValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Address</span> <span class="ow">-&gt;</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkSwapValidator</span> <span class="n">oracle</span> <span class="n">addr</span> <span class="n">pkh</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
    <span class="n">txSignedBy</span> <span class="n">info</span> <span class="n">pkh</span> <span class="o">||</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The more interesting case is the second one, where we check two conditions.</p>
<p>Firstly, there must be two inputs - the oracle and the swap UTxO. All additional inputs (the buyer’s funds) must be public key inputs. This is because we don’t want to worry about interference with other smart contracts.</p>
<p>Secondly, we want to check that the seller gets paid.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">traceIfFalse</span> <span class="s">&quot;expected exactly two script inputs&quot;</span> <span class="n">hasTwoScriptInputs</span> <span class="o">&amp;&amp;</span>
 <span class="n">traceIfFalse</span> <span class="s">&quot;price not paid&quot;</span>                     <span class="n">sellerPaid</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we have our helper function definitions.</p>
<p>First, the usual.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
<span class="nf">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>
</pre></div>
</div>
<p>Then, we have <em>oracleInput</em> to get the UTxO from the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracleInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">oracleInput</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">ins</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">o</span>
          <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
          <span class="p">,</span> <span class="kr">let</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>
          <span class="p">,</span> <span class="n">txOutAddress</span> <span class="n">o</span> <span class="o">==</span> <span class="n">addr</span>
          <span class="p">]</span>
  <span class="kr">in</span>
    <span class="kr">case</span> <span class="n">ins</span> <span class="kr">of</span>
        <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
        <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one oracle input&quot;</span>
</pre></div>
</div>
<p>We do this by getting a list of all the inputs. For this we use list comprehension, which allows us to draw from other lists using a filter. In this case we draw
from the list from <em>txInfoInputs info</em>, which is a list of <em>TxInfo</em>. We use the <em>txInInfoResolved</em> function to look at each element as a <em>TxOut</em> type, which we then compare with the
<em>addr</em> parameter. The resulting list will either by empty, or will have the <em>TxOut</em> that matches the oracle UTxO.</p>
<p>We then check that there is exactly one element in the resulting list, and, if there is, we return it. We don’t return the list, just the <em>TxOut</em>.</p>
<p>This has now given us the oracle output that we are consuming as an input.</p>
<p>Now, we want to check the actual exchange rate. For that, we use the <em>oracleValue</em> function that we defined in the core module. Here again, it may succeed, or it may
fail. If it succeeds we return the value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracleValue&#39;</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">oracleValue</span> <span class="n">oracleInput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;oracle value not found&quot;</span>
    <span class="kt">Just</span> <span class="n">x</span>  <span class="ow">-&gt;</span> <span class="n">x</span>
</pre></div>
</div>
<p>We do not need to check whether the oracle contains the NFT. Due to the way validation works for the oracle, we know that it is present.</p>
<p>Now, let’s look at the <em>hasTwoScriptInputs</em> helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hasTwoScriptInputs</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">hasTwoScriptInputs</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">xs</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="n">isJust</span> <span class="o">.</span> <span class="n">toValidatorHash</span> <span class="o">.</span> <span class="n">txOutAddress</span> <span class="o">.</span> <span class="n">txInInfoResolved</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
  <span class="kr">in</span>
    <span class="n">length</span> <span class="n">xs</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
<p>First, we filter, using the composite function</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">isJust</span> <span class="o">.</span> <span class="n">toValidatorHash</span> <span class="o">.</span> <span class="n">txOutAddress</span> <span class="o">.</span> <span class="n">txInInfoResolved</span><span class="p">)</span>
</pre></div>
</div>
<p>Reading right to left, we get the UTxO from the input, then we get the address for this UTxO, then we get the validator hash for that address. Then, finally, we check
if it is a script output, by seeing if it is a <em>Just</em>. If it is a <em>Nothing</em>, then this would show that it is a public key, not a script address.</p>
<p>We then use this composite function as a filter against the list of <em>TxInInfo</em>s. And then we check that the length of the resulting list is exactly two.</p>
<p>Going back to our validation conditions, we now have to deal with checking that the seller is getting paid. So let’s write the <em>sellerPaid</em> helper function that
we referenced.</p>
<p>For this we will use another helper function to determine the required price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">minPrice</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">minPrice</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">lovelaceIn</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;own input not found&quot;</span>
        <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>
  <span class="kr">in</span>
    <span class="n">price</span> <span class="n">lovelaceIn</span> <span class="n">oracleValue&#39;</span>
</pre></div>
</div>
<p>First we check that we have an input, and if so, we extract the number of lovelaces and assign that number to <em>lovelaceIn</em>. Then, we use the <em>price</em> helper function
to determine the price in USD tokens.</p>
<p>Now, we can define the <em>sellerPaid</em> helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sellerPaid</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">sellerPaid</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">pricePaid</span> <span class="ow">::</span> <span class="kt">Integer</span>
    <span class="n">pricePaid</span> <span class="ow">=</span>  <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">valuePaidTo</span> <span class="n">info</span> <span class="n">pkh</span><span class="p">)</span> <span class="p">(</span><span class="n">oAsset</span> <span class="n">oracle</span><span class="p">)</span>
  <span class="kr">in</span>
    <span class="n">pricePaid</span> <span class="o">&gt;=</span> <span class="n">minPrice</span>
</pre></div>
</div>
<p>The function <em>valuePaidTo</em> is from the Plutus libraries. Given <em>info</em> and a public key hash, it will add up all the values of all the public key outputs that go
to this address. We then use the <em>assetClassValueOf</em> function to check the component of the value that is in USD token, and the check that we have at least as many
as we require.</p>
<p>That’s the end of the main part of the code for the swap validator. We just have our normal boiler plate to write.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Swapping</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Swapping</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Swapping</span> <span class="ow">=</span> <span class="kt">PubKeyHash</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Swapping</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">swapInst</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Swapping</span>
<span class="nf">swapInst</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Swapping</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkSwapValidator</span> <span class="o">||</span><span class="p">])</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">oracle</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="p">(</span><span class="n">oracleAddress</span> <span class="n">oracle</span><span class="p">))</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">PubKeyHash</span> <span class="o">@</span><span class="nb">()</span>

<span class="nf">swapValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">swapValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">swapInst</span>

<span class="nf">swapAddress</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">swapAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">swapValidator</span>
</pre></div>
</div>
<p>Note that in the <em>swapInst</em> function, where we use template haskell to generate the Plutus validator from the <em>mkSwapValidator</em> function, we do not need to pass in the
oracle address as a parameter. This is because we will compute this inside the function. Remember that we can’t use the <em>oracleAddress</em> function inside the Plutus validator.</p>
<p>Now to define some contracts.</p>
<div class="section" id="offerswap">
<h3>offerSwap<a class="headerlink" href="#offerswap" title="Permalink to this headline">¶</a></h3>
<p>First <em>offerSwap</em>. This is for a seller who wants to offer a certain number of lovelace for exchange.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">offerSwap</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">offerSwap</span> <span class="n">oracle</span> <span class="n">amt</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="n">pkh</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">amt</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">swapInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="n">tx</span>
    <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;offered &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">amt</span> <span class="o">++</span> <span class="s">&quot; lovelace for swap&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="findswaps">
<h3>findSwaps<a class="headerlink" href="#findswaps" title="Permalink to this headline">¶</a></h3>
<p>Next, a helper function that will find all swaps that satisfy a given predicate. It takes an oracle plus a predicate based on public key hashes, and returns a list
of triples of the UTxOs that satisfy the predicate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findSwaps</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="p">[(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)]</span>
<span class="nf">findSwaps</span> <span class="n">oracle</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">swapAddress</span> <span class="n">oracle</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">mapMaybe</span> <span class="n">g</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">PubKeyHash</span>
    <span class="n">f</span> <span class="n">o</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">dh</span>        <span class="ow">&lt;-</span> <span class="n">txOutDatumHash</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span>
        <span class="p">(</span><span class="kt">Datum</span> <span class="n">d</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
        <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">d</span>

    <span class="n">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span>
    <span class="n">g</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">o</span>
        <span class="n">guard</span> <span class="o">$</span> <span class="n">p</span> <span class="n">pkh</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">pkh</span><span class="p">)</span>
</pre></div>
</div>
<p>First, we get a list of all the UTxOs sitting at the swap contract address. We then apply <em>mapMaybe</em> to this list.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapMaybe</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
<p>This function will apply the <em>(a -&gt; Maybe b)</em> function to each element in a list of <em>a</em>s and creates a list of <em>Maybe b</em>s, which could contain a mixture of <em>Just</em>s
and <em>Nothing</em>s. It then throws away the <em>Nothing</em>s and returns the values contained in the <em>Just</em>s.</p>
<p>To clarify this, imagine we have a function that returns as <em>Just</em> for even numbers and a <em>Nothing</em> for odd numbers.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">even</span> <span class="n">n</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">div</span> <span class="n">n</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>We can use this as the first parameter to map Maybe</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Maybe</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="n">mapMaybe</span> <span class="n">f</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
</pre></div>
</div>
<p>We use the <em>mapMaybe</em> and the function <em>g</em> to filter the list of UTxOs.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span>
<span class="nf">g</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">o</span>
    <span class="n">guard</span> <span class="o">$</span> <span class="n">p</span> <span class="n">pkh</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">pkh</span><span class="p">)</span>
</pre></div>
</div>
<p>This function takes a key value pair representing the UTxO and returns a <em>Maybe</em> triple containing the items from the pair alongside a <em>PubKeyHash</em>.</p>
<p>Function <em>g</em> is inside the <em>Maybe</em> monad and makes use of function <em>f</em>, which is also inside the <em>Maybe</em> monad. Function <em>f</em> gets the public key hash from a UTxO,
if it exists. After this, function <em>g</em> uses the <em>guard</em> function with the predicate function <em>p</em> that we passed in as an argument.</p>
<p>The <em>guard</em> function is available in some monads, and the <em>Maybe</em> monad is one of them. It takes a boolean as a parameter, and, if the boolean is false, the computation
fails. In this case, failure means returning <em>Nothing</em>. If it is true, it just continues. In this case, that means returning the <em>Just</em> of the triple containing the
public key hash.</p>
<p>We will see how we use the <em>findSwaps</em> function in a moment.</p>
</div>
<div class="section" id="retrieveswaps">
<h3>retrieveSwaps<a class="headerlink" href="#retrieveswaps" title="Permalink to this headline">¶</a></h3>
<p>The <em>retrieveSwaps</em> contract is for the seller if they want to change their mind and get their Ada back.</p>
<p>Here is where we use the <em>findSwaps</em> function. We use it with <em>(== pkh)</em> as the predicate, meaning that we want only those UTxOs sitting at the swap address that
belong to the operator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">retrieveSwaps</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">retrieveSwaps</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">findSwaps</span> <span class="n">oracle</span> <span class="p">(</span><span class="o">==</span> <span class="n">pkh</span><span class="p">)</span>
    <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span>
        <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no swaps found&quot;</span>
        <span class="kr">_</span>  <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">])</span> <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">swapValidator</span> <span class="n">oracle</span><span class="p">)</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Swapping</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;retrieved &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot; swap(s)&quot;</span>
</pre></div>
</div>
<p>If there are none, then there is nothing to do. If there are some, we construct a transaction that retrieves all of them.</p>
<p>To do that, we create a list of <em>mustSpendScriptOutput</em> constraints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div>
</div>
<p>The line looks intimidating, but it is just extracting a list of <em>oref</em>s from the <em>xs</em> list and using it to construct a constraint for each of them, using <em>Unit</em> as
the <em>Redeemer</em> type. The function <em>mconcat</em> applies the <em>Semigroup</em> operator <em>&lt;&gt;</em> throughout the list in order to combine them.</p>
<p>As lookups, we must provide all the UTxOs and the swap validator.</p>
<p>We have the list of UTxOs in <em>xs</em> and we use list comprehension to turn this list into a list of pairs, and we then use <em>Map.fromList</em> to turn those pairs into a
map, to which we then apply the <em>unspentOutputs</em> constraint.</p>
</div>
<div class="section" id="useswaps">
<h3>useSwaps<a class="headerlink" href="#useswaps" title="Permalink to this headline">¶</a></h3>
<p>And now the most interesting one, <em>useSwaps</em>. This is where we actually use the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">useSwap</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">useSwap</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">funds</span> <span class="ow">&lt;-</span> <span class="n">ownFunds</span>
    <span class="kr">let</span> <span class="n">amt</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="n">funds</span> <span class="o">$</span> <span class="n">oAsset</span> <span class="n">oracle</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;available assets: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">amt</span>

    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>           <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;oracle not found&quot;</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;found oracle, exchange rate &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
            <span class="n">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
            <span class="n">swaps</span> <span class="ow">&lt;-</span> <span class="n">findSwaps</span> <span class="n">oracle</span> <span class="p">(</span><span class="o">/=</span> <span class="n">pkh</span><span class="p">)</span>
            <span class="kr">case</span> <span class="n">find</span> <span class="p">(</span><span class="n">f</span> <span class="n">amt</span> <span class="n">x</span><span class="p">)</span> <span class="n">swaps</span> <span class="kr">of</span>
                <span class="kt">Nothing</span>                <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no suitable swap found&quot;</span>
                <span class="kt">Just</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">,</span> <span class="n">pkh&#39;</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                    <span class="kr">let</span> <span class="n">v</span>       <span class="ow">=</span> <span class="n">txOutValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">)</span>
                        <span class="n">p</span>       <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">$</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o&#39;</span><span class="p">)</span> <span class="n">x</span>
                        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">swapValidator</span> <span class="n">oracle</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>                   <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">),</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">)])</span>
                        <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span>  <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Use</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref&#39;</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span><span class="p">)</span>  <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToOtherScript</span>
                                    <span class="p">(</span><span class="n">validatorHash</span> <span class="o">$</span> <span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">Datum</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="n">x</span><span class="p">)</span>
                                    <span class="n">v</span>                                                                      <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="n">pkh&#39;</span> <span class="n">p</span>
                    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Swapping</span> <span class="n">lookups</span> <span class="n">tx</span>
                    <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
                    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made swap with price &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="kt">Value</span><span class="o">.</span><span class="n">flattenValue</span> <span class="n">p</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">getPrice</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
    <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="n">x</span>

    <span class="n">f</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="n">amt</span> <span class="n">x</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="o">&lt;=</span> <span class="n">amt</span>
</pre></div>
</div>
<p>First, we use the <em>ownFunds</em> function. This is defined in a separate module that we will get to in a bit. All it does is to add up all the money in our own
wallet and returns a <em>Value</em>. We then find out how many USD Tokens we have.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">funds</span> <span class="ow">&lt;-</span> <span class="n">ownFunds</span>
<span class="kr">let</span> <span class="n">amt</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="n">funds</span> <span class="o">$</span> <span class="n">oAsset</span> <span class="n">oracle</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;available assets: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">amt</span>
</pre></div>
</div>
<p>The <em>findOracle</em> function is defined in the Oracle.Core module from earlier. You will recall that it finds us the oracle UTxO that contains the oracle value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>If we don’t find the oracle, we will just log a message to that effect.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>           <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;oracle not found&quot;</span>
</pre></div>
</div>
<p>If we do find it, we will log a message with the current exchange rate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;found oracle, exchange rate &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>Next, we check our own public key and check for all available swaps where we are <em>not</em> the owner.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
<span class="nf">swaps</span> <span class="ow">&lt;-</span> <span class="n">findSwaps</span> <span class="n">oracle</span> <span class="p">(</span><span class="o">/=</span> <span class="n">pkh</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we use a function <em>find</em> which is from the Haskell prelude, in module <em>Data.List</em>. The <em>find</em> function takes a predicate and a list and <em>Maybe</em> returns one
element of that list that satisfies the predicate.</p>
<p>The function used in the predicate is defined as the helper function <em>f</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">where</span>
    <span class="n">getPrice</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
    <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="n">x</span>

    <span class="n">f</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="n">amt</span> <span class="n">x</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="o">&lt;=</span> <span class="n">amt</span>
</pre></div>
</div>
<p>We give it an amount, the current exchange rate, and a UTxO triple. The function determines if there is a swap that is cheaper to or equal to the amount parameter.</p>
<p>Now, we have searched for a swap that we can afford. If we don’t find one, we log a message saying so.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">find</span> <span class="p">(</span><span class="n">f</span> <span class="n">amt</span> <span class="n">x</span><span class="p">)</span> <span class="n">swaps</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>                <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no suitable swap found&quot;</span>
</pre></div>
</div>
<p>If we <em>do</em> find one, we just take the first one. This isn’t very realistic, of course. In a real-world example we would probably specify the exact amount we want to swap. Here,
we are just keeping it simple as we are focussed on oracles rather than swapping.</p>
<p>So, now we construct a transaction.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">txOutValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">)</span>
</pre></div>
</div>
<p>This is the output for the oracle. It is the same as the input, including any fees that have accumulated there, plus the fee in lovelace that we need to pay.</p>
<p>We then create a <em>Value</em> representing the USD Tokens that we need to pay.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">p</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">$</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o&#39;</span><span class="p">)</span> <span class="n">x</span>
</pre></div>
</div>
<p>Now, let’s look at the constraints.</p>
<p>The first constraint is that we must consume the oracle as an input. And here we see the first use of the <em>Use</em> redeemer. We never used this redeemer in the oracle
core itself, as the oracle provider is only responsible for updating values, which uses the <em>Update</em> redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Use</span><span class="p">)</span>
</pre></div>
</div>
<p>The second constraint is to consume the swap input, which just uses a <em>Unit</em> redeeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref&#39;</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span><span class="p">)</span>
</pre></div>
</div>
<p>The third constraint is to pay the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToOtherScript</span>
    <span class="p">(</span><span class="n">validatorHash</span> <span class="o">$</span> <span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">Datum</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">v</span>
</pre></div>
</div>
<p>Here we use <em>mustPayToOtherScript</em>, specifying the oracle script, because now we have two scripts in play - the oracle script and the swap script. As <em>Datum</em> we use
the exist datum - we mustn’t change it - and as <em>Value</em> we use the value <em>v</em> that we computed earlier.</p>
<p>The final constraint is that we must pay the seller of the lovelace - and the payment is the price <em>p</em> that we calculated before.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="n">pkh&#39;</span> <span class="n">p</span>
</pre></div>
</div>
<p>For lookups, we must provide the validators of the oracle and swap contracts, and we must provide the two UTxOs that we want to consume.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">swapValidator</span> <span class="n">oracle</span><span class="p">)</span>               <span class="o">&lt;&gt;</span>
    <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>                   <span class="o">&lt;&gt;</span>
    <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">),</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">)])</span>
</pre></div>
</div>
<p>Now, the usual - we submit it, wait for confirmation, then log a message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Swapping</span> <span class="n">lookups</span> <span class="n">tx</span>
<span class="nf">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made swap with price &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="kt">Value</span><span class="o">.</span><span class="n">flattenValue</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="contract-bundle">
<h3>Contract bundle<a class="headerlink" href="#contract-bundle" title="Permalink to this headline">¶</a></h3>
<p>That defines the raw contracts. Now, we provide a bundle that contains all of them.</p>
<p>First, we define, as always, a schema, which defines the endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">SwapSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;offer&quot;</span>    <span class="kt">Integer</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;retrieve&quot;</span> <span class="nb">()</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;use&quot;</span>      <span class="nb">()</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;funds&quot;</span>    <span class="nb">()</span>
</pre></div>
</div>
<p>Next, we see the <em>select</em> operator. This use of this operator will cause our code to wait until one of the endpoints is picked, and then executes the
associated code.</p>
<p>The <em>swap</em> function recursively calls itself, offering again and again the same choice of endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">swap</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">swap</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="p">(</span><span class="n">offer</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">retrieve</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">use</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">funds</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">swap</span> <span class="n">oracle</span>
    <span class="kr">where</span>
        <span class="n">offer</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">offer</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">amt</span> <span class="ow">&lt;-</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span>
            <span class="n">offerSwap</span> <span class="n">oracle</span> <span class="n">amt</span>

        <span class="n">retrieve</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">retrieve</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span>
            <span class="n">retrieveSwaps</span> <span class="n">oracle</span>

        <span class="n">use</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">use</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span>
            <span class="n">useSwap</span> <span class="n">oracle</span>

        <span class="n">funds</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">funds</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;funds&quot;</span>
            <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">ownFunds</span>
            <span class="n">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">v</span>

        <span class="n">h</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">h</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span>
</pre></div>
</div>
<p>The code for the four endpoints are wrappers for the code we have already written.</p>
<p>For <em>offer</em>, for example, we block until we are provided with an <em>amt</em> and then we call the <em>offerSwap</em> contract.</p>
<p>It is the same for the <em>retrieve</em> and <em>use</em> endpoints, except that they require no parameters.</p>
<p>For the <em>funds</em> endpoint it is a little different. The <em>ownFunds</em> function comes from the <em>Funds</em> module, which, as we noted earlier, we have not yet looked at. It gives us the <em>Value</em> that we own. We
then <em>tell</em> this value as a way of reporting to the outside world how much we have.</p>
<p>The <em>h</em> in each of the endpoints is an error handler. Each of the endpoints is wrapped inside the error handler, which just logs the error, but does not halt execution.</p>
<p>And that concludes the swap example.</p>
</div>
</div>
<div class="section" id="funds-module">
<h2>Funds Module<a class="headerlink" href="#funds-module" title="Permalink to this headline">¶</a></h2>
<p>Now let’s quickly look at the <em>Funds</em> module. It’s a short module that provides two contracts.</p>
<p>The <em>ownFunds</em> function is tasked with summing up all the <em>Value</em> in our own UTxOs.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownFunds</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">Value</span>
<span class="nf">ownFunds</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pk</span>    <span class="ow">&lt;-</span> <span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">pubKeyAddress</span> <span class="n">pk</span>
    <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">elems</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">.</span> <span class="n">txOutTxOut</span> <span class="o">&lt;$&gt;</span> <span class="n">utxos</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;own funds: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="kt">Value</span><span class="o">.</span><span class="n">flattenValue</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">v</span>
</pre></div>
</div>
<p>It does this by looking up our public key, then getting all the UTxOs at that public key address. The <em>utxos</em> are then a map from UTxO references to UTxOs.</p>
<p>As <em>map</em> implements <em>Functor</em> we can map over the map to change the elements to something else. In this case, we change them to <em>Value</em>s by applying the composite
function <em>txOutValue</em> . <em>txOutTxOut</em>.</p>
<p>The <em>Map.elems</em> function ignores the keys and just gives us the values. And, as we saw before, <em>mconcat</em>, when given a <em>Semigroup</em> or <em>Monoid</em> type, will combine the
list of values into one value.</p>
<p>So <em>v</em> is not the sum of all the values of all the UTxOs that we own. Our <em>ownFunds</em> function is a contract that has a return type of <em>Value</em>, we return <em>v</em>.</p>
<p>The function <em>ownFunds’</em> is a variation that, instead of returning the value, permanently tells it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownFunds&#39;</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">ownFunds&#39;</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">ownFunds</span> <span class="o">&gt;&gt;=</span> <span class="n">tell</span> <span class="o">.</span> <span class="kt">Last</span> <span class="o">.</span> <span class="kt">Just</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
    <span class="n">ownFunds&#39;</span>
</pre></div>
</div>
<p>This calls the <em>ownFunds</em> function, performs a monadic bind to the composite function <em>tell . Last . Just</em> which tells the value, then it waits for a slot, and then
calls itself. So, every block, it writes the value into the log.</p>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>We will now write code, using the <em>EmulatorTrace</em> monad, that tests the contracts we have written.</p>
<p>This code can be found in the following module</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week06.Oracle.Test</span>
</pre></div>
</div>
<p>First, we need to define a token that we can test with. The <em>assetSymbol</em> is an arbitrary hash, which is fine for test purposes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assetSymbol</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
<span class="nf">assetSymbol</span> <span class="ow">=</span> <span class="s">&quot;ff&quot;</span>

<span class="nf">assetToken</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">assetToken</span> <span class="ow">=</span> <span class="s">&quot;USDT&quot;</span>
</pre></div>
</div>
<p>This time we are going to use the primed version of <em>runEmulatorTraceIO</em>, which takes two more arguments and gives more fine-grained over the emulation environment.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">emCfg</span> <span class="n">myTrace</span>
  <span class="kr">where</span>
    <span class="n">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
    <span class="n">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">]]</span>

    <span class="n">v</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>                    <span class="mi">100_000_000</span> <span class="o">&lt;&gt;</span>
        <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">assetSymbol</span> <span class="n">assetToken</span> <span class="mi">100_000_000</span>
</pre></div>
</div>
<p>The first argument to <em>runEmulatorTraceIO’</em> determines how the various log messages are displayed. Using <em>def</em>, we have selected the default, which is the same as
in the unprimed version.</p>
<p>The reason we are using the primed version is that we want to configure the initial distribution, and we can do that with the second argument, which here we have
labelled <em>emCfg</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
<span class="nf">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">]]</span>
</pre></div>
</div>
<p>We use this with the helper function <em>v</em> to give everyone 100 million lovelace (100 Ada) and 100 million USD Tokens to begin with.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">v</span> <span class="ow">::</span> <span class="kt">Value</span>
<span class="nf">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>                    <span class="mi">100_000_000</span> <span class="o">&lt;&gt;</span>
    <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">assetSymbol</span> <span class="n">assetToken</span> <span class="mi">100_000_000</span>
</pre></div>
</div>
<p>We define a helper contract, <em>checkOracle</em>, that will continually check the oracle value and log it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkOracle</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">checkOracle</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>        <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;Oracle value: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
    <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="n">checkOracle</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>And now we can define our trace.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">op</span> <span class="ow">=</span> <span class="kt">OracleParams</span>
                <span class="p">{</span> <span class="n">opFees</span> <span class="ow">=</span> <span class="mi">1_000_000</span>
                <span class="p">,</span> <span class="n">opSymbol</span> <span class="ow">=</span> <span class="n">assetSymbol</span>
                <span class="p">,</span> <span class="n">opToken</span>  <span class="ow">=</span> <span class="n">assetToken</span>
                <span class="p">}</span>

    <span class="n">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">runOracle</span> <span class="n">op</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
    <span class="n">oracle</span> <span class="ow">&lt;-</span> <span class="n">getOracle</span> <span class="n">h1</span>

    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">checkOracle</span> <span class="n">oracle</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_500_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>

    <span class="n">h3</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
    <span class="n">h4</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
    <span class="n">h5</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h3</span> <span class="mi">10_000_000</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h4</span> <span class="mi">20_000_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_700_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_800_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h3</span> <span class="nb">()</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h4</span> <span class="nb">()</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
  <span class="kr">where</span>
    <span class="n">getOracle</span> <span class="ow">::</span> <span class="kt">ContractHandle</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="kt">Oracle</span>
    <span class="n">getOracle</span> <span class="n">h</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
        <span class="kr">case</span> <span class="n">l</span> <span class="kr">of</span>
            <span class="kt">Last</span> <span class="kt">Nothing</span>       <span class="ow">-&gt;</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="n">getOracle</span> <span class="n">h</span>
            <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">oracle</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="p">(</span><span class="n">show</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>This is all stuff that we have already seen. We define our oracle parameters, setting the oracle fee at 1 million lovelace, and our arbitrary asset class defined earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">op</span> <span class="ow">=</span> <span class="kt">OracleParams</span>
    <span class="p">{</span> <span class="n">opFees</span> <span class="ow">=</span> <span class="mi">1_000_000</span>
    <span class="p">,</span> <span class="n">opSymbol</span> <span class="ow">=</span> <span class="n">assetSymbol</span>
    <span class="p">,</span> <span class="n">opToken</span>  <span class="ow">=</span> <span class="n">assetToken</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Then, we start the oracle and wait for one slot.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">runOracle</span> <span class="n">op</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
<span class="nf">oracle</span> <span class="ow">&lt;-</span> <span class="n">getOracle</span> <span class="n">h1</span>
</pre></div>
</div>
<p>We have grabbed a handle to the oracle using the helper function defined in the <em>where</em> clause.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getOracle</span> <span class="ow">::</span> <span class="kt">ContractHandle</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="kt">Oracle</span>
<span class="nf">getOracle</span> <span class="n">h</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kr">case</span> <span class="n">l</span> <span class="kr">of</span>
        <span class="kt">Last</span> <span class="kt">Nothing</span>       <span class="ow">-&gt;</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="n">getOracle</span> <span class="n">h</span>
        <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">oracle</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="p">(</span><span class="n">show</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>We need this because the swap contract is parameterized with the oracle value. And this is why we used <em>tell</em> in the <em>runOracle</em> function.</p>
<p>We use the <em>observableState</em> function to get hold of this information. If it does not exist, we wait for a slot, and try again. Otherwise, we log it for debugging
purposes, and the return it.</p>
<p>Next, we use Wallet 2 to execute the <em>checkOracle</em> function which we saw earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">checkOracle</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>We then initialize the oracle to an exchange rate of 1.5 Ada, and wait for 3 slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_500_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>We now call the <em>ownFunds’</em> function on Wallets 1, 3, 4 and 5 to check the initial balances.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
</pre></div>
</div>
<p>Then we start the swap contract on Wallets 3, 4, and 5.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h3</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
<span class="nf">h4</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
<span class="nf">h5</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>Then we try some scenarios. First, Wallets 3 and 4 offer 10 and 20 Ada for swap respectively.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h3</span> <span class="mi">10_000_000</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h4</span> <span class="mi">20_000_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>And now Wallet 5 uses the swap. It will pick one of the two. It is not obvious which one, whichever it finds first. Remember that we only wrote code that would find
the first affordable slot. It will then pay USD Token for it. The amount paid will depend on the current value of the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Now, Wallet 1 updates the oracle value to 1.7. This also results in the accumulated fees (1 Ada) being paid to Wallet 1.</p>
<blockquote>
<div><p>callEndpoint &#64;”update” h1 1_700_000
void $ Emulator.waitNSlots 3</p>
</div></blockquote>
<p>Then, Wallet 5 tries again, grabbing the remaining swap, but now paying a different USD Token price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>We then set the oracle value to 1.8.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_800_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>This will allow Wallet 1 to collect the fees. The oracle value didn’t actually need to change for this to happen.</p>
<p>Wallets 3 and 4 now issues <em>retrieve</em> requests to get back any funds that have not been bought. This will result in no funds being returned because all the swaps
have been used.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h3</span> <span class="nb">()</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h4</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>And that’s it. So let’s run it in the REPL.</p>
<div class="section" id="test-in-the-repl">
<h3>Test in the REPL<a class="headerlink" href="#test-in-the-repl" title="Permalink to this headline">¶</a></h3>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Week06.Oracle.Test</span>
<span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Test</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="n">test</span>
</pre></div>
</div>
<p>There will be a lot of output.</p>
<p>Let’s look at some key parts. First, slot 3, where the oracle is created. Here we get the <em>oSymbol</em> value that we can use for everything else.</p>
<p>We also see in slot 3 that <em>getOracle</em> is started which will log the value of the oracle, for our information, every slot from now on.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;started oracle Oracle {oSymbol = 6122edd57c938cda24066f434da9aee55120b4eb362d4a1bd37547ef6e4a6cbb, oOperator = 21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9, oFee = 1000000, oAsset = (ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">)}&quot;</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="n">Oracle</span> <span class="p">{</span><span class="n">oSymbol</span> <span class="o">=</span> <span class="mi">6122</span><span class="n">edd57c938cda24066f434da9aee55120b4eb362d4a1bd37547ef6e4a6cbb</span><span class="p">,</span> <span class="n">oOperator</span> <span class="o">=</span> <span class="mi">21</span><span class="n">fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9</span><span class="p">,</span> <span class="n">oFee</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">oAsset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ff</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">)}</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;update&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1500000.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">93</span><span class="n">fab1c0845a5b96863a50d248fa2de68bd6702185e3de92ae0c58b869569909</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">93</span><span class="n">fab1c0845a5b96863a50d248fa2de68bd6702185e3de92ae0c58b869569909</span>
</pre></div>
</div>
<p>And, in slot 4, we see the first value that <em>getOracle</em> finds is 1,500,000.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Oracle value: 1500000&quot;</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;set initial oracle value to 1500000&quot;</span>
</pre></div>
</div>
<p>Slot 6 is the result of all the <em>activateContractWallet</em> calls. These do not necessarily appear in the same order as in the code. Notice that Wallet 1 has slightly
fewer Ada than the other wallets. This is because Wallet 1 started the oracle and needed to pay transaction fees for that.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000003</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000004</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">4</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,99999970),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000005</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">5</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000006</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000007</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">4</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000008</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">5</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Oracle value: 1500000&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000006</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;offer&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1.0e7</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">W3</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">8274315</span><span class="n">b83fb8b4d721146a75772cf39be3f96730557bd6021235864f0f37bc6</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000007</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">4</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;offer&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">2.0e7</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">W4</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">221</span><span class="n">f86cc1d6087a5967793aaf9eb078d8ec0677b2d6aca586f985f6f2c57a100</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">221</span><span class="n">f86cc1d6087a5967793aaf9eb078d8ec0677b2d6aca586f985f6f2c57a100</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">8274315</span><span class="n">b83fb8b4d721146a75772cf39be3f96730557bd6021235864f0f37bc6</span>
</pre></div>
</div>
<p>In slot 7, the offers of 10 Ada and 20 Ada are made.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,99999970),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;offered 10000000 lovelace for swap&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,89999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;offered 20000000 lovelace for swap&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,79999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Oracle value: 1500000&quot;</span>
</pre></div>
</div>
<p>In slot 9, the first <em>use</em> is requested.</p>
<p>And in slot 10, we see the swap happen.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,99999970),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,89999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,79999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,130000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;made swap with price [(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,30000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,118999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,70000000)]&quot;</span>
</pre></div>
</div>
<p>The oracle gets and update request in slot 12.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;update&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1700000.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">ff7e1fbfb51897b100dcfdf551ad9a03886432af0a9fa92ff8dd986a0f7c90fe</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">ff7e1fbfb51897b100dcfdf551ad9a03886432af0a9fa92ff8dd986a0f7c90fe</span>
</pre></div>
</div>
<p>And we see it happen in slot 13.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00013</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;updated oracle value to 1700000&quot;</span>
</pre></div>
</div>
<p>The second <em>use</em> request arrives at slot 15.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000008</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">5</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;use&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[])]))])</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,118999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,70000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;available assets: 70000000&quot;</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;found oracle, exchange rate 1700000&quot;</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">W5</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">84</span><span class="n">bec9a9044eee9c5b40029dca5bbc8346214504e5adb4745bbe6e5d7d96078e</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">84</span><span class="n">bec9a9044eee9c5b40029dca5bbc8346214504e5adb4745bbe6e5d7d96078e</span>
</pre></div>
</div>
<p>And the swap happens at slot 16.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;made swap with price [(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,17000000)]&quot;</span>
</pre></div>
</div>
<p>And at the bottom, we see the final balances.</p>
<p>Wallet 2 still has all its funds. All Wallet 2 has done is the oracle checking, which doesn’t cost anything, as it is purely an off-chain matter.</p>
<p>Wallet 1 paid some transaction fees but ends up with roughly 2 Ada more than it started with. This is because it collected the 2 Ada in fees for the use of the oracle.</p>
<p>Wallets 3 and 4 both made offers, and their balances reflect the exchange rates at which their offers were accepted.</p>
<p>Wallet 5 was the one accepting the offers, and so has the additional Ada, but a reduced USD Token balance. Note that Wallet 5 has also had some fees deducted from its
Ada balance.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">101999950</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">117000000</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">89999990</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">130000000</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">79999990</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">127999980</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">53000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>And finally, as well as the wallets, we see that the oracle is still going, and still owns the NFT. Note that, in this log, we don’t see the datum value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Script</span> <span class="n">cc6a43073dce46eebc7b309223904c7a8033ffab7d9b239cf013342d4c69a5d6</span><span class="p">:</span>
    <span class="p">{</span><span class="mi">6122</span><span class="n">edd57c938cda24066f434da9aee55120b4eb362d4a1bd37547ef6e4a6cbb</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="plutus-application-backend">
<h2>Plutus Application Backend<a class="headerlink" href="#plutus-application-backend" title="Permalink to this headline">¶</a></h2>
<p>Apart from the idea of how to implement an oracle in Plutus, nothing we have done in this lecture so far is new, except for a few library functions and Haskell
techniques. In principle, we are familiar with the way validators are written for off-chain code and how contracts are written for on-chain code, and how we
can test our code with the <em>EmulatorTrace</em> monad.</p>
<p>But now we will talk about something new - the Plutus Application Backend (PAB), which allows us to take all the stuff we have done and turn it into an executable that
runs the contracts.</p>
<p>If the testnet or the mainnet were available with Plutus support, we could deploy such an application, but for now we will need to be happy with a simulated blockchain.
But, the process of turning the code into a dApp is practically the same as it would be on a real blockchain.</p>
<p>We need one more tiny module, which is basically just a type definition. It is so small, we can include the entire file contents here.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE DeriveAnyClass     #-}</span>
<span class="cm">{-# LANGUAGE DeriveGeneric      #-}</span>

<span class="kr">module</span> <span class="nn">Week06.Oracle.PAB</span>
    <span class="p">(</span> <span class="kt">OracleContracts</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span>           <span class="nn">Data.Aeson</span>                <span class="p">(</span><span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Data.Text.Prettyprint.Doc</span> <span class="p">(</span><span class="kt">Pretty</span> <span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="nf">viaShow</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">GHC.Generics</span>              <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Ledger</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Week06.Oracle.Core</span>        <span class="k">as</span> <span class="n">Oracle</span>

<span class="kr">data</span> <span class="kt">OracleContracts</span> <span class="ow">=</span> <span class="kt">Init</span> <span class="o">|</span> <span class="kt">Oracle</span> <span class="kt">CurrencySymbol</span> <span class="o">|</span> <span class="kt">Swap</span> <span class="kt">Oracle</span><span class="o">.</span><span class="kt">Oracle</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Pretty</span> <span class="kt">OracleContracts</span> <span class="kr">where</span>
    <span class="n">pretty</span> <span class="ow">=</span> <span class="n">viaShow</span>
</pre></div>
</div>
<p>The idea is that it reifies the contract instances that we want to run. We have various contracts, and we want to have a data type where each value of the data type
corresponds to a contact that we eventually want to run.</p>
<p>The <em>Init</em> constructor will be used to setup an environment where there is a USD Token available and where the wallets have an initial supply of those.</p>
<p>The <em>Oracle</em> constructor corresponds to the <em>runOracle</em> contract that will start the oracle and provide the <em>update</em> endpoint, and the <em>CurrencySymbol</em> parameter is
going to be used for the USD Token.</p>
<p>Finally, the <em>Swap</em>, parameterized by <em>Oracle</em> will be used to run the swap contract, which provides various endpoints like <em>offer</em>, <em>retrieve</em>, <em>use</em> and <em>funds</em>.</p>
<p>We need to put the <em>OracleContracts</em> definition in a separate module because we will use it both from the PAB and also from the front end.</p>
<p>We are going to look at the Cabal file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week06</span><span class="o">.</span><span class="n">cabal</span>
</pre></div>
</div>
<p>In it we have definitions for various executables.</p>
<p>The <em>oracle-pab</em> executable will set up a simulated wallet, initialize all the contracts and setup a web server that allows the outside world
to interact with these contracts.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">executable</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span><span class="o">.</span><span class="n">hs</span>
<span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="p">:</span>      <span class="n">app</span>
<span class="n">ghc</span><span class="o">-</span><span class="n">options</span><span class="p">:</span>         <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">threaded</span>
<span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="p">:</span>       <span class="n">aeson</span>
                   <span class="p">,</span> <span class="n">base</span> <span class="o">^&gt;=</span> <span class="mf">4.14</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">freer</span><span class="o">-</span><span class="n">extras</span>
                   <span class="p">,</span> <span class="n">freer</span><span class="o">-</span><span class="n">simple</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">contract</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">ledger</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pab</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week06</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">cases</span>
                   <span class="p">,</span> <span class="n">text</span>
</pre></div>
</div>
<p>The <em>oracle-client</em> executable will be run by the oracle provider, so that will interact with the <em>runOracle</em> contract. It will also fetch exchange rates from the
internet and feed them into the system.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">executable</span> <span class="n">oracle</span><span class="o">-</span><span class="n">client</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">oracle</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
<span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="p">:</span>      <span class="n">app</span>
<span class="n">ghc</span><span class="o">-</span><span class="n">options</span><span class="p">:</span>         <span class="o">-</span><span class="n">Wall</span>
<span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="p">:</span>       <span class="n">base</span> <span class="o">^&gt;=</span> <span class="mf">4.14</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">bytestring</span>
                   <span class="p">,</span> <span class="n">regex</span><span class="o">-</span><span class="n">tdfa</span> <span class="o">^&gt;=</span> <span class="mf">1.3</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">req</span> <span class="o">^&gt;=</span> <span class="mf">3.9</span><span class="o">.</span><span class="mi">0</span>
                   <span class="p">,</span> <span class="n">text</span>
                   <span class="p">,</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>Then there is the <em>swap-client</em> executable that will be run by the clients who want to make use of the swap contract.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">executable</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
<span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="p">:</span>      <span class="n">app</span>
<span class="n">ghc</span><span class="o">-</span><span class="n">options</span><span class="p">:</span>         <span class="o">-</span><span class="n">Wall</span>
<span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="p">:</span>       <span class="n">aeson</span>
                   <span class="p">,</span> <span class="n">base</span> <span class="o">^&gt;=</span> <span class="mf">4.14</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">ledger</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pab</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week06</span>
                   <span class="p">,</span> <span class="n">req</span> <span class="o">^&gt;=</span> <span class="mf">3.9</span><span class="o">.</span><span class="mi">0</span>
                   <span class="p">,</span> <span class="n">text</span>
                   <span class="p">,</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>We will look at each of these in turn.</p>
<p>The code for each of these apps can be found in the <em>app</em> directory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">/</span><span class="n">oracle</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
<span class="n">app</span><span class="o">/</span><span class="n">oracle</span><span class="o">-</span><span class="n">pab</span><span class="o">.</span><span class="n">hs</span>
<span class="n">app</span><span class="o">/</span><span class="n">swap</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
</pre></div>
</div>
<div class="section" id="oracle-pab">
<h3>Oracle PAB<a class="headerlink" href="#oracle-pab" title="Permalink to this headline">¶</a></h3>
<p>First some boilerplate to hook up the data type we just defined - the reified contract instances - with the schemas and contracts that we defined earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handleOracleContracts</span> <span class="ow">::</span>
    <span class="p">(</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">Error</span> <span class="kt">PABError</span><span class="p">)</span> <span class="n">effs</span>
    <span class="p">,</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">LogMsg</span> <span class="p">(</span><span class="kt">PABMultiAgentMsg</span> <span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)))</span> <span class="n">effs</span>
    <span class="p">)</span>
    <span class="ow">=&gt;</span> <span class="kt">ContractEffect</span> <span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span>
    <span class="o">~&gt;</span> <span class="kt">Eff</span> <span class="n">effs</span>
<span class="nf">handleOracleContracts</span> <span class="ow">=</span> <span class="n">handleBuiltin</span> <span class="n">getSchema</span> <span class="n">getContract</span> <span class="kr">where</span>
    <span class="n">getSchema</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
        <span class="kt">Init</span>     <span class="ow">-&gt;</span> <span class="n">endpointsToSchemas</span> <span class="o">@</span><span class="kt">Empty</span>
        <span class="kt">Oracle</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">endpointsToSchemas</span> <span class="o">@</span><span class="p">(</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">OracleSchema</span> <span class="o">.\\</span> <span class="kt">BlockchainActions</span><span class="p">)</span>
        <span class="kt">Swap</span> <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">endpointsToSchemas</span> <span class="o">@</span><span class="p">(</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">SwapSchema</span>   <span class="o">.\\</span> <span class="kt">BlockchainActions</span><span class="p">)</span>
    <span class="n">getContract</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
        <span class="kt">Init</span>        <span class="ow">-&gt;</span> <span class="kt">SomeBuiltin</span>   <span class="n">initContract</span>
        <span class="kt">Oracle</span> <span class="n">cs</span>   <span class="ow">-&gt;</span> <span class="kt">SomeBuiltin</span> <span class="o">$</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">runOracle</span> <span class="o">$</span> <span class="n">oracleParams</span> <span class="n">cs</span>
        <span class="kt">Swap</span> <span class="n">oracle</span> <span class="ow">-&gt;</span> <span class="kt">SomeBuiltin</span> <span class="o">$</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">swap</span> <span class="n">oracle</span>
</pre></div>
</div>
<p><em>Init</em> won’t have any schema, so it just has <em>BlockChainActions</em>. <em>Oracle</em> uses the <em>OracleSchema</em> and <em>Swap</em> uses the <em>SwapSchema</em>. No surprise there.</p>
<p><em>Init</em> will run the <em>initContract</em>, which we will see in a moment.</p>
<p><em>Oracle</em> will run the <em>runOracle</em> contract with <em>oracleParams</em> which takes the currency symbol of the USD Token and defines example oracle params.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracleParams</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">Oracle</span><span class="o">.</span><span class="kt">OracleParams</span>
<span class="nf">oracleParams</span> <span class="n">cs</span> <span class="ow">=</span> <span class="kt">Oracle</span><span class="o">.</span><span class="kt">OracleParams</span>
    <span class="p">{</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">opFees</span>   <span class="ow">=</span> <span class="mi">1_000_000</span>
    <span class="p">,</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">opSymbol</span> <span class="ow">=</span> <span class="n">cs</span>
    <span class="p">,</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">opToken</span>  <span class="ow">=</span> <span class="n">usdt</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>And finally <em>Swap</em> will run our swap contract with an oracle value.</p>
<p>Here is some more copy/paste boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handlers</span> <span class="ow">::</span> <span class="kt">SimulatorEffectHandlers</span> <span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span>
<span class="nf">handlers</span> <span class="ow">=</span>
    <span class="kt">Simulator</span><span class="o">.</span><span class="n">mkSimulatorHandlers</span> <span class="o">@</span><span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span> <span class="kt">[]</span>
    <span class="o">$</span> <span class="n">interpret</span> <span class="n">handleOracleContracts</span>
</pre></div>
</div>
<p>And here is the <em>initContract</em> function we mentioned just a moment ago.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">initContract</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">CurrencySymbol</span><span class="p">)</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">initContract</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">ownPK</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="n">cur</span>   <span class="ow">&lt;-</span>
        <span class="n">mapError</span> <span class="p">(</span><span class="n">pack</span> <span class="o">.</span> <span class="n">show</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Currency</span><span class="o">.</span><span class="n">forgeContract</span> <span class="n">ownPK</span> <span class="p">[(</span><span class="n">usdt</span><span class="p">,</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">wallets</span><span class="p">)</span> <span class="o">*</span> <span class="n">amount</span><span class="p">)]</span>
        <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">CurrencySymbol</span><span class="p">)</span> <span class="kt">BlockchainActions</span> <span class="kt">Currency</span><span class="o">.</span><span class="kt">CurrencyError</span> <span class="kt">Currency</span><span class="o">.</span><span class="kt">OneShotCurrency</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">cs</span> <span class="ow">=</span> <span class="kt">Currency</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="n">cur</span>
        <span class="n">v</span>  <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">cs</span> <span class="n">usdt</span> <span class="n">amount</span>
    <span class="n">forM_</span> <span class="n">wallets</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="n">w</span>
        <span class="n">when</span> <span class="p">(</span><span class="n">pkh</span> <span class="o">/=</span> <span class="n">ownPK</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">tx</span> <span class="ow">&lt;-</span> <span class="n">submitTx</span> <span class="o">$</span> <span class="n">mustPayToPubKey</span> <span class="n">pkh</span> <span class="n">v</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">tx</span>
    <span class="n">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">cs</span>
  <span class="kr">where</span>
    <span class="n">amount</span> <span class="ow">::</span> <span class="kt">Integer</span>
    <span class="n">amount</span> <span class="ow">=</span> <span class="mi">100_000_000</span>
</pre></div>
</div>
<p>The <em>initContract</em> function mints USD Tokens and distributes them to the wallets, then it <em>tell</em>s the currency symbol for the USD Token.</p>
<p>The wallets are hardcoded earlier in the code. The number of wallets and the tokens given to them are completely arbitrary.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">wallets</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Wallet</span><span class="p">]</span>
<span class="nf">wallets</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Wallet</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]]</span>
</pre></div>
</div>
<p>Now we can look at the actual PAB code.</p>
<p>For the first time, we see a <em>main</em> function, which is the entry point for the executable.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">runSimulationWith</span> <span class="n">handlers</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="kt">Simulator</span><span class="o">.</span><span class="n">logString</span> <span class="o">@</span><span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span> <span class="s">&quot;Starting Oracle PAB webserver. Press enter to exit.&quot;</span>
    <span class="n">shutdown</span> <span class="ow">&lt;-</span> <span class="kt">PAB</span><span class="o">.</span><span class="kt">Server</span><span class="o">.</span><span class="n">startServerDebug</span>

    <span class="n">cidInit</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">Init</span>
    <span class="n">cs</span>      <span class="ow">&lt;-</span> <span class="n">waitForLast</span> <span class="n">cidInit</span>
    <span class="kr">_</span>       <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">waitUntilFinished</span> <span class="n">cidInit</span>

    <span class="n">cidOracle</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Oracle</span> <span class="n">cs</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="s">&quot;oracle.cid&quot;</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cidOracle</span>
    <span class="n">oracle</span> <span class="ow">&lt;-</span> <span class="n">waitForLast</span> <span class="n">cidOracle</span>

    <span class="n">forM_</span> <span class="n">wallets</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span>
        <span class="n">when</span> <span class="p">(</span><span class="n">w</span> <span class="o">/=</span> <span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">cid</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="n">w</span> <span class="o">$</span> <span class="kt">Swap</span> <span class="n">oracle</span>
            <span class="n">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="p">(</span><span class="sc">&#39;W&#39;</span> <span class="kt">:</span> <span class="n">show</span> <span class="p">(</span><span class="n">getWallet</span> <span class="n">w</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;.cid&quot;</span><span class="p">)</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cid</span>

    <span class="n">void</span> <span class="o">$</span> <span class="n">liftIO</span> <span class="n">getLine</span>
    <span class="n">shutdown</span>
</pre></div>
</div>
<p>The <em>main</em> function makes use of another monad that we haven’t seen before and is specific to the PAB - the <em>Simulator</em> monad.</p>
<p>The <em>Simulator</em> monad is very similar to the <em>EmulatorTrace</em> monad. In principle it has the same capabilities. You can start contracts on wallets, you can inspect
the state using the log, you can call endpoints, and so on.</p>
<p>It is a bit unfortunate that there are two monads for this as they are so similar. The Plutus team plan to align them and maybe turn them into one. So it may not be
worth learning the intricacies of the <em>Simulator</em> monad as it will probably change soon.</p>
<p>Similar to the <em>runEmulatorTraceIO</em>, we have <em>runSimulationWith</em> to which we pass the <em>handlers</em> boilerplate.</p>
<p>One significant difference to the <em>EmulatorTrace</em> monad though is that the <em>EmulatorTrace</em> monad was pure code - there were no real world side-effects, no IO involved. In particular there is a pure interpreter <em>runEmulatorTrace</em> that is a pure Haskell function with no side-effects.</p>
<p><em>Simulator</em> s different - you can do IO. The way it works is using <em>MonadIO</em>, which has one method, <em>liftIO</em>, which takes an <em>IO</em> action and <em>lifts</em> it into the monad
in question. So, if you have some arbitrary IO action that you can do in Haskell, then by applying <em>liftIO</em> to it, you can move it into this <em>Simulator</em> monad.</p>
<p>Apart from that, if you squint, it looks very similar to an <em>EmulatorTrace</em>.</p>
<p>The first thing we do is use <em>logString</em> to log that we are starting the PAB server. We then call the <em>startServerDebug</em> function, and the return value of that
function which gets bound to <em>shutdown</em> can be used later to shut down the server.</p>
<p>Now we use something called <em>activateContract</em> which is the equivalent of <em>activateContractWallet</em> from the <em>EmulatorTrace</em> monad.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cidInit</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">Init</span>
</pre></div>
</div>
<p>It takes a wallet where we want to start that instance, and then a value of the reified contract type. Remember that we associated the <em>Init</em> constructor with the
<em>initContract</em> function.</p>
<p>Now we need the currency symbol. This is an example of how we get information out of a contract using <em>tell</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cs</span> <span class="ow">&lt;-</span> <span class="n">waitForLast</span> <span class="n">cidInit</span>
</pre></div>
</div>
<p>The function <em>cidInit</em> uses a function from the <em>Simulator</em> monad called <em>waitForState</em>, which takes a contract instance and a predicate. The predicate gets a
JSON expression and returns a <em>Maybe a</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">waitForLast</span> <span class="ow">::</span> <span class="kt">FromJSON</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">ContractInstanceId</span> <span class="ow">-&gt;</span> <span class="kt">Simulator</span><span class="o">.</span><span class="kt">Simulation</span> <span class="n">t</span> <span class="n">a</span>
<span class="nf">waitForLast</span> <span class="n">cid</span> <span class="ow">=</span>
    <span class="n">flip</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">waitForState</span> <span class="n">cid</span> <span class="o">$</span> <span class="nf">\</span><span class="n">json</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">fromJSON</span> <span class="n">json</span> <span class="kr">of</span>
        <span class="kt">Success</span> <span class="p">(</span><span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span>
        <span class="kr">_</span>                       <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>The idea is that it will read the state of the contract which we wrote using <em>tell</em>. This is serialized as a JSON value, and it applies this JSON value to the
provided predicate. If the result is <em>Nothing</em>, it simply waits until the state changes again. But, if it is <em>Just x</em>, it will return the <em>x</em>.</p>
<p>There are two ways it could be <em>Nothing</em> - either the JSON parsing could fail, or we could get a <em>Last Nothing</em>. So, the end result is that the function waits until
the state of the contract has told a <em>Just</em> value.</p>
<p>At this point we have the currency symbol bound to <em>cs</em>. And then we wait until <em>initContract</em> has finished.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">waitUntilFinished</span> <span class="n">cidInit</span>
</pre></div>
</div>
<p>The next step is to start the oracle on Wallet 1, using the <em>cs</em> value we have recently obtained.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cidOracle</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Oracle</span> <span class="n">cs</span>
</pre></div>
</div>
<p>In order to interact with the oracle contract from the outside world, e.g. from the web interface, we need to get our hands on the <em>cidOracle</em> handle.</p>
<p>So what we do is write this into a file called <em>oracle.cid</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="s">&quot;oracle.cid&quot;</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cidOracle</span>
</pre></div>
</div>
<p>This is just quick and dirty for the demonstration. In production code you would use a safer mechanism.</p>
<p>Now we use <em>waitForLast</em> again to get the oracle value, which we have provided from the <em>runOracle</em> contract via a <em>tell</em>. We need this because the swap contract
is parameterized by this value.</p>
<p>At this stage the NFT is minted and we know what the oracle value is.</p>
<p>Next, we loop over all the wallets, except wallet 1 which runs the oracle, and we activate the swap contract on each of them. Here we use a similar file-writing method
to get hold of the contract handles.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">forM_</span> <span class="n">wallets</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">w</span> <span class="o">/=</span> <span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">cid</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="n">w</span> <span class="o">$</span> <span class="kt">Swap</span> <span class="n">oracle</span>
        <span class="n">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="p">(</span><span class="sc">&#39;W&#39;</span> <span class="kt">:</span> <span class="n">show</span> <span class="p">(</span><span class="n">getWallet</span> <span class="n">w</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;.cid&quot;</span><span class="p">)</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cid</span>
</pre></div>
</div>
<p>Now we just block until the user presses enter, and then we shutdown the server.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">liftIO</span> <span class="n">getLine</span>
<span class="nf">shutdown</span>
</pre></div>
</div>
<p>It is not actually necessary to do all of this, because you can also start and stop contract instances from the web interface. It was easier for us here to do it in a
scripted way for the demo, but in principle you could just start the simulator and then wait until you shutdown.</p>
<p>If you are curious about the API provided by the PAB, you can check that in the <em>plutus-pab</em> package, in the module <em>Plutus.PAB.Webserver.API</em>. There are several, but
the one that we are using here is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | PAB client API for contracts of type @t@. Examples of @t@ are</span>
<span class="c1">--   * Contract executables that reside in the user&#39;s file system</span>
<span class="c1">--   * &quot;Builtin&quot; contracts that run in the same process as the PAB (ie. the PAB is compiled &amp; distributed with these contracts)</span>
<span class="kr">type</span> <span class="kt">NewAPI</span> <span class="n">t</span> <span class="n">walletId</span> <span class="c1">-- see note [WalletID type in wallet API]</span>
    <span class="ow">=</span> <span class="s">&quot;api&quot;</span> <span class="kt">:&gt;</span> <span class="s">&quot;new&quot;</span> <span class="kt">:&gt;</span> <span class="s">&quot;contract&quot;</span> <span class="kt">:&gt;</span>
        <span class="p">(</span><span class="s">&quot;activate&quot;</span> <span class="kt">:&gt;</span> <span class="kt">ReqBody</span> <span class="kt">&#39;[ JSON]</span> <span class="p">(</span><span class="kt">ContractActivationArgs</span> <span class="n">t</span><span class="p">)</span> <span class="kt">:&gt;</span> <span class="kt">Post</span> <span class="kt">&#39;[JSON]</span> <span class="kt">ContractInstanceId</span> <span class="c1">-- start a new instance</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;instance&quot;</span> <span class="kt">:&gt;</span>
                    <span class="p">(</span><span class="kt">Capture</span> <span class="s">&quot;contract-instance-id&quot;</span> <span class="kt">Text</span> <span class="kt">:&gt;</span>
                        <span class="p">(</span> <span class="s">&quot;status&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[JSON]</span> <span class="p">(</span><span class="kt">ContractInstanceClientState</span> <span class="n">t</span><span class="p">)</span> <span class="c1">-- Current status of contract instance</span>
                        <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;endpoint&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Capture</span> <span class="s">&quot;endpoint-name&quot;</span> <span class="kt">String</span> <span class="kt">:&gt;</span> <span class="kt">ReqBody</span> <span class="kt">&#39;[JSON]</span> <span class="kt">JSON</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">:&gt;</span> <span class="kt">Post</span> <span class="kt">&#39;[JSON]</span> <span class="nb">()</span> <span class="c1">-- Call an endpoint. Make</span>
                        <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;stop&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Put</span> <span class="kt">&#39;[JSON]</span> <span class="nb">()</span> <span class="c1">-- Terminate the instance.</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;instances&quot;</span> <span class="kt">:&gt;</span> <span class="s">&quot;wallet&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Capture</span> <span class="s">&quot;wallet-id&quot;</span> <span class="n">walletId</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[JSON]</span> <span class="p">[</span><span class="kt">ContractInstanceClientState</span> <span class="n">t</span><span class="p">]</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;instances&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[ JSON]</span> <span class="p">[</span><span class="kt">ContractInstanceClientState</span> <span class="n">t</span><span class="p">]</span> <span class="c1">-- list of all active contract instances</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;definitions&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[JSON]</span> <span class="p">[</span><span class="kt">ContractSignatureResponse</span> <span class="n">t</span><span class="p">]</span> <span class="c1">-- list of available contracts</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>This makes use of the popular Haskell library <em>Servant</em> to write type safe web applications, but it should be readable more or less without knowledge of the <em>Servant</em>
library. For example, you can see the <em>/api/new/contract/activate</em> endpoint declared to which you can POST a <em>ContractActivationArgs</em> as its body and returns a <em>ContractInstanceId</em>.</p>
<p>There is also a web socket API, but we have not used that in this example.</p>
<p>So let’s try our executable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span>
</pre></div>
</div>
<p>We get log output similar to what we see with <em>EmulatorTrace</em>, but this is now a live server.</p>
<p>The output below is reduced to avoid the full verbosity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">0</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Starting</span> <span class="n">Oracle</span> <span class="n">PAB</span> <span class="n">webserver</span><span class="o">.</span> <span class="n">Press</span> <span class="n">enter</span> <span class="n">to</span> <span class="n">exit</span><span class="o">.</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Starting</span> <span class="n">PAB</span> <span class="n">backend</span> <span class="n">server</span> <span class="n">on</span> <span class="n">port</span><span class="p">:</span> <span class="mi">8080</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="n">dda39c83</span><span class="o">-</span><span class="mi">5</span><span class="n">a0f</span><span class="o">-</span><span class="mi">484</span><span class="n">f</span><span class="o">-</span><span class="n">b49a</span><span class="o">-</span><span class="mi">9943</span><span class="n">b1ff5526</span> <span class="n">on</span> <span class="n">W1</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
                     <span class="n">Tx</span><span class="p">:</span>
                       <span class="n">Tx</span> <span class="n">da767478580878690990b3a22387be9c5b27fabed2c0ca7b9991eb682a6781f8</span><span class="p">:</span>
                         <span class="p">{</span><span class="n">inputs</span><span class="p">:</span>
                         <span class="n">outputs</span><span class="p">:</span>
                           <span class="o">-</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)])])</span> <span class="n">addressed</span> <span class="n">to</span>
                             <span class="n">addressed</span> <span class="n">to</span> <span class="n">ScriptCredential</span><span class="p">:</span> <span class="n">e9827f1a9e43109d1c8d4555913734b8c48a467a31061b312959f270850fc8a0</span> <span class="p">(</span><span class="n">no</span> <span class="n">staking</span> <span class="n">credential</span><span class="p">)</span>
                         <span class="n">forge</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[])</span>
                         <span class="n">fee</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">)])])</span>
                         <span class="n">mps</span><span class="p">:</span>
                         <span class="n">signatures</span><span class="p">:</span>
                         <span class="n">validity</span> <span class="nb">range</span><span class="p">:</span> <span class="n">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="o">=</span> <span class="n">LowerBound</span> <span class="n">NegInf</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="o">=</span> <span class="n">UpperBound</span> <span class="n">PosInf</span> <span class="kc">True</span><span class="p">}</span>
                         <span class="n">data</span><span class="p">:</span>
                           <span class="o">&lt;&gt;</span><span class="p">}</span>
                     <span class="n">Requires</span> <span class="n">signatures</span><span class="p">:</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">b7d6ba18d02898aa5d0814a306e4a05cf153c199aabb175ef9b00328105ab98f</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">2</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
 <span class="o">...</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">6</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">d690122263521c37f308a0d5ae858aa4807cb1e493c2a3374bf65b934c74782a</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="n">deceaa52</span><span class="o">-</span><span class="n">f117</span><span class="o">-</span><span class="mi">46</span><span class="n">bc</span><span class="o">-</span><span class="n">b0f1</span><span class="o">-</span><span class="n">eb1f2f529b5a</span> <span class="n">on</span> <span class="n">W1</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">7</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
<span class="o">...</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">7</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">a679948d128735ec1f380e9f733d7f4a5e54c81f39c73a656d61b077111840e1</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">8</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
<span class="o">...</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">8</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">f0125e685edd6de2d09f9547f53b18d1bad11bd7fad570a057ba74737ab3053e</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">deceaa52</span><span class="o">-</span><span class="n">f117</span><span class="o">-</span><span class="mi">46</span><span class="n">bc</span><span class="o">-</span><span class="n">b0f1</span><span class="o">-</span><span class="n">eb1f2f529b5a</span><span class="p">:</span> <span class="s2">&quot;started oracle Oracle {oSymbol = b8a1d67cd94acf75d7e00f27015ec5e31242adad0967eee473f49c5d1d686169, oOperator = 21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9, oFee = 1000000, oAsset = (9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">)}&quot;</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">5</span><span class="n">bac6e67</span><span class="o">-</span><span class="n">f956</span><span class="o">-</span><span class="mi">45</span><span class="n">ef</span><span class="o">-</span><span class="n">b386</span><span class="o">-</span><span class="n">f1d045cf5e37</span> <span class="n">on</span> <span class="n">W2</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">2</span><span class="n">c3a2794</span><span class="o">-</span><span class="mi">2592</span><span class="o">-</span><span class="mi">4</span><span class="n">c2b</span><span class="o">-</span><span class="mi">9</span><span class="n">a7d</span><span class="o">-</span><span class="mi">9</span><span class="n">c810cedf886</span> <span class="n">on</span> <span class="n">W3</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">6</span><span class="n">f8d611d</span><span class="o">-</span><span class="n">a3f6</span><span class="o">-</span><span class="mi">4794</span><span class="o">-</span><span class="mi">9048</span><span class="o">-</span><span class="mi">8</span><span class="n">ea3201e3c56</span> <span class="n">on</span> <span class="n">W4</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">387</span><span class="n">d9651</span><span class="o">-</span><span class="mi">6024</span><span class="o">-</span><span class="mi">48</span><span class="n">c1</span><span class="o">-</span><span class="n">a72d</span><span class="o">-</span><span class="mi">5</span><span class="n">b3c6d3a6b53</span> <span class="n">on</span> <span class="n">W5</span>
</pre></div>
</div>
<p>We can see, for example, where we can find instance IDs of contracts if we want to interact with them via the API.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="n">deceaa52</span><span class="o">-</span><span class="n">f117</span><span class="o">-</span><span class="mi">46</span><span class="n">bc</span><span class="o">-</span><span class="n">b0f1</span><span class="o">-</span><span class="n">eb1f2f529b5a</span> <span class="n">on</span> <span class="n">W1</span>
</pre></div>
</div>
<p>If we now stop the server and look in the directory, we will see the files where we stored the instance IDs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[nix-shell:~/git/ada/pioneer-fork/code/week06]$ ls
app            dist-newstyle  LICENSE     plutus-pioneer-program-week06.cabal  W2.cid  W4.cid
cabal.project  hie.yaml       oracle.cid  src                                  W3.cid  W5.cid

[nix-shell:~/git/ada/pioneer-fork/code/week06]$ cat W5.cid
387d9651-6024-48c1-a72d-5b3c6d3a6b53
</pre></div>
</div>
<p>With this information - either obtained from the web server log, or from the files we have created, we could use any HTTP tool such as Curl or Postman to interact
with the contracts when the web server is running. By default it runs on port 8080. We could also write code in any programming language we like to interact with the
web server using the HTTP endpoints.</p>
<p>We will now briefly look at the <em>oracle-client</em> and the <em>swap-client</em>. We won’t go into too much detail because we are not so interested in how to write a front end
here.</p>
</div>
<div class="section" id="oracle-client">
<h3>Oracle Client<a class="headerlink" href="#oracle-client" title="Permalink to this headline">¶</a></h3>
<p>We use the Haskell library <em>Req</em> to interact with the web server.</p>
<p>We first read the <em>oracle.cid</em> file to get the oracle instance ID. Then we have a recursive function <em>go</em>.</p>
<p>The function <em>go</em> looks up the current exchange rate on CoinMarketCap, checks whether that has changed, and, if it has change, it calls <em>updateOracle</em> which calls the
update oracle endpoint on our contract. And, whether or not a change is detected, it waits for an arbitrary five seconds, and then goes again.</p>
<p>The length of the delay would depend on things such as that rate cap imposed by CoinMarketCap. In reality, as blocks on Cardano only appear every twenty seconds, five
seconds is probably too short.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">uuid</span> <span class="ow">&lt;-</span> <span class="n">read</span> <span class="o">&lt;$&gt;</span> <span class="n">readFile</span> <span class="s">&quot;oracle.cid&quot;</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;oracle contract instance id: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">uuid</span>
    <span class="n">go</span> <span class="n">uuid</span> <span class="kt">Nothing</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">uuid</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">getExchangeRate</span>
        <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">x</span>
        <span class="n">when</span> <span class="p">(</span><span class="n">m</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span> <span class="o">$</span>
            <span class="n">updateOracle</span> <span class="n">uuid</span> <span class="n">x</span>
        <span class="n">threadDelay</span> <span class="mi">5_000_000</span>
        <span class="n">go</span> <span class="n">uuid</span> <span class="n">y</span>
</pre></div>
</div>
<p>Now, the <em>updateOracle</em> function prepares an POST request using the oracle instance ID and a JSON body containing the exchange rate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">updateOracle</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">updateOracle</span> <span class="n">uuid</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">runReq</span> <span class="n">defaultHttpConfig</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">req</span>
        <span class="kt">POST</span>
        <span class="p">(</span><span class="n">http</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="o">/:</span> <span class="s">&quot;api&quot;</span>  <span class="o">/:</span> <span class="s">&quot;new&quot;</span> <span class="o">/:</span> <span class="s">&quot;contract&quot;</span> <span class="o">/:</span> <span class="s">&quot;instance&quot;</span> <span class="o">/:</span> <span class="n">pack</span> <span class="p">(</span><span class="n">show</span> <span class="n">uuid</span><span class="p">)</span> <span class="o">/:</span> <span class="s">&quot;endpoint&quot;</span> <span class="o">/:</span> <span class="s">&quot;update&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">ReqBodyJson</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="kt">JsonResponse</span> <span class="nb">()</span><span class="p">))</span>
        <span class="p">(</span><span class="n">port</span> <span class="mi">8080</span><span class="p">)</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="kr">if</span> <span class="n">responseStatusCode</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">200</span>
        <span class="kr">then</span> <span class="s">&quot;updated oracle to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
        <span class="kr">else</span> <span class="s">&quot;error updating oracle&quot;</span>
</pre></div>
</div>
<p>And here is the <em>getExchangeRate</em> function which is a quick and dirty way of getting the exchange rate from CoinMarketCap. They provide a proper API, but here we
are just doing some screen scraping from the web page and using a regex to extract the value we are interested in. This is, of course, very fragile, and could never
be used as production code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getExchangeRate</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Integer</span>
<span class="nf">getExchangeRate</span> <span class="ow">=</span> <span class="n">runReq</span> <span class="n">defaultHttpConfig</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">req</span>
        <span class="kt">GET</span>
        <span class="p">(</span><span class="n">https</span> <span class="s">&quot;coinmarketcap.com&quot;</span> <span class="o">/:</span> <span class="s">&quot;currencies&quot;</span> <span class="o">/:</span> <span class="s">&quot;cardano&quot;</span><span class="p">)</span>
        <span class="kt">NoReqBody</span>
        <span class="n">bsResponse</span>
        <span class="n">mempty</span>
    <span class="kr">let</span> <span class="n">priceRegex</span>      <span class="ow">=</span> <span class="s">&quot;priceValue___11gHJ</span><span class="se">\&quot;</span><span class="s">&gt;</span><span class="se">\\</span><span class="s">$([</span><span class="se">\\</span><span class="s">.0-9]*)&quot;</span> <span class="ow">::</span> <span class="kt">ByteString</span>
        <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="p">[</span><span class="n">bs</span><span class="p">])</span> <span class="ow">=</span> <span class="n">responseBody</span> <span class="n">v</span> <span class="o">=~</span> <span class="n">priceRegex</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">ByteString</span><span class="p">,</span> <span class="kt">ByteString</span><span class="p">,</span> <span class="kt">ByteString</span><span class="p">,</span> <span class="p">[</span><span class="kt">ByteString</span><span class="p">])</span>
        <span class="n">d</span>               <span class="ow">=</span> <span class="n">read</span> <span class="o">$</span> <span class="n">unpack</span> <span class="n">bs</span> <span class="ow">::</span> <span class="kt">Double</span>
        <span class="n">x</span>               <span class="ow">=</span> <span class="n">round</span> <span class="o">$</span> <span class="mi">1_000_000</span> <span class="o">*</span> <span class="n">d</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;queried exchange rate: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">d</span>
    <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Let us run it.</p>
<p>First we need to make sure the PAB is running.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span>
</pre></div>
</div>
<p>Then, in another terminal</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">oracle</span><span class="o">-</span><span class="n">client</span>
<span class="o">...</span>
<span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.54</span>
<span class="n">updated</span> <span class="n">oracle</span> <span class="n">to</span> <span class="mi">1540000</span>
<span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.54</span>
</pre></div>
</div>
<p>We can see the exchange rate that it has obtained from CoinMarketCap, and its request to update the oracle.</p>
<p>And if we wait long enough, we see</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.55</span>
<span class="n">updated</span> <span class="n">oracle</span> <span class="n">to</span> <span class="mi">1550000</span>
<span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.55</span>
</pre></div>
</div>
<p>And we see that we are mooning.</p>
<p>If you switch back to the PAB, you will also see additional log messages.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">16</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
    <span class="n">Tx</span><span class="p">:</span>
    <span class="n">Tx</span> <span class="n">c5b384f75f93ebc8f1e6b514237aa70d0d982e9b035eececa27af0b3e72568e4</span><span class="p">:</span>
        <span class="p">{</span><span class="n">inputs</span><span class="p">:</span>
        <span class="n">outputs</span><span class="p">:</span>
        <span class="o">-</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(</span><span class="n">b8a1d67cd94acf75d7e00f27015ec5e31242adad0967eee473f49c5d1d686169</span><span class="p">,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)])])</span> <span class="n">addressed</span> <span class="n">to</span>
            <span class="n">addressed</span> <span class="n">to</span> <span class="n">ScriptCredential</span><span class="p">:</span> <span class="mi">04</span><span class="n">a718132f7ca493a011c40926e191a76bd84cbf8e7c14b6c99bbea8b8bc0bba</span> <span class="p">(</span><span class="n">no</span> <span class="n">staking</span> <span class="n">credential</span><span class="p">)</span>
        <span class="n">forge</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[])</span>
        <span class="n">fee</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">)])])</span>
        <span class="n">mps</span><span class="p">:</span>
        <span class="n">signatures</span><span class="p">:</span>
        <span class="n">validity</span> <span class="nb">range</span><span class="p">:</span> <span class="n">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="o">=</span> <span class="n">LowerBound</span> <span class="n">NegInf</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="o">=</span> <span class="n">UpperBound</span> <span class="n">PosInf</span> <span class="kc">True</span><span class="p">}</span>
        <span class="n">data</span><span class="p">:</span>
        <span class="mi">1540000</span><span class="p">}</span>
    <span class="n">Requires</span> <span class="n">signatures</span><span class="p">:</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">16</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">40</span><span class="n">c5dbb5e7c8de390a6943d8f0a84d218cf86dd81af1fd7cfc62612e6b616c2c</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="mi">5</span><span class="n">d9d778e</span><span class="o">-</span><span class="mi">55</span><span class="n">f9</span><span class="o">-</span><span class="mi">45</span><span class="n">ab</span><span class="o">-</span><span class="mi">89</span><span class="n">a6</span><span class="o">-</span><span class="mi">2</span><span class="n">ba9aa18045e</span><span class="p">:</span> <span class="s2">&quot;set initial oracle value to 1540000&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="swap-client">
<h3>Swap Client<a class="headerlink" href="#swap-client" title="Permalink to this headline">¶</a></h3>
<p>The swap client is very similar.</p>
<p>Here, we are just giving a simple console interface, so we didn’t bother with graphics or a nice web UI.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">[</span><span class="n">i</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">]</span> <span class="ow">&lt;-</span> <span class="n">map</span> <span class="n">read</span> <span class="o">&lt;$&gt;</span> <span class="n">getArgs</span>
    <span class="n">uuid</span>       <span class="ow">&lt;-</span> <span class="n">read</span> <span class="o">&lt;$&gt;</span> <span class="n">readFile</span> <span class="p">(</span><span class="sc">&#39;W&#39;</span> <span class="kt">:</span> <span class="n">show</span> <span class="n">i</span> <span class="o">++</span> <span class="s">&quot;.cid&quot;</span><span class="p">)</span>
    <span class="n">hSetBuffering</span> <span class="n">stdout</span> <span class="kt">NoBuffering</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;swap contract instance id for Wallet &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">i</span> <span class="o">++</span> <span class="s">&quot;: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">uuid</span>
    <span class="n">go</span> <span class="n">uuid</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">uuid</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">cmd</span> <span class="ow">&lt;-</span> <span class="n">readCommand</span>
        <span class="kr">case</span> <span class="n">cmd</span> <span class="kr">of</span>
            <span class="kt">Offer</span> <span class="n">amt</span> <span class="ow">-&gt;</span> <span class="n">offer</span> <span class="n">uuid</span> <span class="n">amt</span>
            <span class="kt">Retrieve</span>  <span class="ow">-&gt;</span> <span class="n">retrieve</span> <span class="n">uuid</span>
            <span class="kt">Use</span>       <span class="ow">-&gt;</span> <span class="n">use</span> <span class="n">uuid</span>
            <span class="kt">Funds</span>     <span class="ow">-&gt;</span> <span class="n">getFunds</span> <span class="n">uuid</span>
        <span class="n">go</span> <span class="n">uuid</span>

    <span class="n">readCommand</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Command</span>
    <span class="n">readCommand</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">putStr</span> <span class="s">&quot;enter command (Offer amt, Retrieve, Use or Funds): &quot;</span>
        <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
        <span class="n">maybe</span> <span class="n">readCommand</span> <span class="n">return</span> <span class="o">$</span> <span class="n">readMaybe</span> <span class="n">s</span>
</pre></div>
</div>
<p>The idea is to take a command from the console and the call the appropriate endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">cmd</span> <span class="kr">of</span>
    <span class="kt">Offer</span> <span class="n">amt</span> <span class="ow">-&gt;</span> <span class="n">offer</span> <span class="n">uuid</span> <span class="n">amt</span>
    <span class="kt">Retrieve</span>  <span class="ow">-&gt;</span> <span class="n">retrieve</span> <span class="n">uuid</span>
    <span class="kt">Use</span>       <span class="ow">-&gt;</span> <span class="n">use</span> <span class="n">uuid</span>
    <span class="kt">Funds</span>     <span class="ow">-&gt;</span> <span class="n">getFunds</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>The endpoint calling uses the same method for each endpoint, creating an HTTP call in the same way that we did for the oracle client.</p>
<p>The <em>getFunds</em> function is slightly more complicated than the other three as it needs to get information out of the server. For this it needs to make
two requests. The second request is to read the state that was <em>told</em> by the first call.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getFunds</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">getFunds</span> <span class="n">uuid</span> <span class="ow">=</span> <span class="n">handle</span> <span class="n">h</span> <span class="o">$</span> <span class="n">runReq</span> <span class="n">defaultHttpConfig</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">req</span>
        <span class="kt">POST</span>
        <span class="p">(</span><span class="n">http</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="o">/:</span> <span class="s">&quot;api&quot;</span>  <span class="o">/:</span> <span class="s">&quot;new&quot;</span> <span class="o">/:</span> <span class="s">&quot;contract&quot;</span> <span class="o">/:</span> <span class="s">&quot;instance&quot;</span> <span class="o">/:</span> <span class="n">pack</span> <span class="p">(</span><span class="n">show</span> <span class="n">uuid</span><span class="p">)</span> <span class="o">/:</span> <span class="s">&quot;endpoint&quot;</span> <span class="o">/:</span> <span class="s">&quot;funds&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">ReqBodyJson</span> <span class="nb">()</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="kt">JsonResponse</span> <span class="nb">()</span><span class="p">))</span>
        <span class="p">(</span><span class="n">port</span> <span class="mi">8080</span><span class="p">)</span>
    <span class="kr">if</span> <span class="n">responseStatusCode</span> <span class="n">v</span> <span class="o">/=</span> <span class="mi">200</span>
        <span class="kr">then</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="s">&quot;error getting funds&quot;</span>
        <span class="kr">else</span> <span class="kr">do</span>
            <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">req</span>
                <span class="kt">GET</span>
                <span class="p">(</span><span class="n">http</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="o">/:</span> <span class="s">&quot;api&quot;</span>  <span class="o">/:</span> <span class="s">&quot;new&quot;</span> <span class="o">/:</span> <span class="s">&quot;contract&quot;</span> <span class="o">/:</span> <span class="s">&quot;instance&quot;</span> <span class="o">/:</span> <span class="n">pack</span> <span class="p">(</span><span class="n">show</span> <span class="n">uuid</span><span class="p">)</span> <span class="o">/:</span> <span class="s">&quot;status&quot;</span><span class="p">)</span>
                <span class="kt">NoReqBody</span>
                <span class="p">(</span><span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="kt">JsonResponse</span> <span class="p">(</span><span class="kt">ContractInstanceClientState</span> <span class="kt">OracleContracts</span><span class="p">)))</span>
                <span class="p">(</span><span class="n">port</span> <span class="mi">8080</span><span class="p">)</span>
            <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="kr">case</span> <span class="n">fromJSON</span> <span class="o">$</span> <span class="n">observableState</span> <span class="o">$</span> <span class="n">cicCurrentState</span> <span class="o">$</span> <span class="n">responseBody</span> <span class="n">w</span> <span class="kr">of</span>
                <span class="kt">Success</span> <span class="p">(</span><span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="s">&quot;funds: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">flattenValue</span> <span class="n">f</span><span class="p">)</span>
                <span class="kr">_</span>                       <span class="ow">-&gt;</span> <span class="s">&quot;error decoding state&quot;</span>
  <span class="kr">where</span>
    <span class="n">h</span> <span class="ow">::</span> <span class="kt">HttpException</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
    <span class="n">h</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">threadDelay</span> <span class="mi">1_000_000</span> <span class="o">&gt;&gt;</span> <span class="n">getFunds</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>Let’s run the swap client. We will leave the web server and the oracle client running.</p>
<p>When using cabal, we pass parameters in following a <em>–</em>. For the swap client we pass the wallet number in as a parameter.</p>
<p>We will launch the swap client for wallets 2 and 3, each in a separate window, and query their respective funds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span> <span class="o">--</span> <span class="mi">2</span>

<span class="n">swap</span> <span class="n">contract</span> <span class="n">instance</span> <span class="nb">id</span> <span class="k">for</span> <span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span> <span class="n">ab65f248</span><span class="o">-</span><span class="mi">450</span><span class="n">d</span><span class="o">-</span><span class="mi">4988</span><span class="o">-</span><span class="n">ab2a</span><span class="o">-</span><span class="mi">651</span><span class="n">ad5697596</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)]</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span> <span class="o">--</span> <span class="mi">3</span>

<span class="n">swap</span> <span class="n">contract</span> <span class="n">instance</span> <span class="nb">id</span> <span class="k">for</span> <span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="n">dc4f6f2</span><span class="o">-</span><span class="mf">142e-40</span><span class="n">a2</span><span class="o">-</span><span class="n">a1b8</span><span class="o">-</span><span class="n">c431eb29a3a2</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)]</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span>
</pre></div>
</div>
<p>Wallet 2 now offers 10 Ada as a swap, and we check the funds, and we see that the Ada balance has gone down (by the 10 Ada plus the transaction fee),
but the USD Token balance remains the same.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Offer</span> <span class="mi">10000000</span>
<span class="n">offered</span> <span class="n">swap</span> <span class="n">of</span> <span class="mi">10000000</span> <span class="n">lovelace</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">89999990</span><span class="p">)]</span>
</pre></div>
</div>
<p>While these commands are running, you can also see the calls being made in the PAB output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1662</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">17</span><span class="n">f640f03e4dc7d0a4c246129454aa19daa8d9d674bfebeeee486d6143c6648e</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">ab65f248</span><span class="o">-</span><span class="mi">450</span><span class="n">d</span><span class="o">-</span><span class="mi">4988</span><span class="o">-</span><span class="n">ab2a</span><span class="o">-</span><span class="mi">651</span><span class="n">ad5697596</span><span class="p">:</span> <span class="s2">&quot;offered 10000000 lovelace for swap&quot;</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">ab65f248</span><span class="o">-</span><span class="mi">450</span><span class="n">d</span><span class="o">-</span><span class="mi">4988</span><span class="o">-</span><span class="n">ab2a</span><span class="o">-</span><span class="mi">651</span><span class="n">ad5697596</span><span class="p">:</span> <span class="s2">&quot;own funds: [(9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000),(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,89999990)]&quot;</span>
</pre></div>
</div>
<p>Now, Wallet 3 is going to take up the offer of the swap.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Use</span>
<span class="n">used</span> <span class="n">swap</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)]</span>
</pre></div>
</div>
<p>It takes a little while for the funds to update, so let’s try the <em>Funds</em> command again.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">84400000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">108999990</span><span class="p">)]</span>
</pre></div>
</div>
<p>That’s better. And we can see that wallet 3 has received the 10 Ada, minus the oracle fee of 1 Ada and minus the transaction fees.</p>
<p>In the PAB output, we see something like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1868</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">00</span><span class="n">afd25af063d58b4f290e43057f4738483098f26ff0134bc14c9d54b9b94090</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="mi">2</span><span class="n">dc4f6f2</span><span class="o">-</span><span class="mf">142e-40</span><span class="n">a2</span><span class="o">-</span><span class="n">a1b8</span><span class="o">-</span><span class="n">c431eb29a3a2</span><span class="p">:</span> <span class="s2">&quot;made swap with price [(9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,15600000)]&quot;</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="mi">2</span><span class="n">dc4f6f2</span><span class="o">-</span><span class="mf">142e-40</span><span class="n">a2</span><span class="o">-</span><span class="n">a1b8</span><span class="o">-</span><span class="n">c431eb29a3a2</span><span class="p">:</span> <span class="s2">&quot;own funds: [(9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,84400000),(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,108999990)]&quot;</span>
</pre></div>
</div>
<p>Let’s look at wallet 2’s funds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">115600000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">89999990</span><span class="p">)]</span>
</pre></div>
</div>
<p>And we see that wallet 2 has lost some Ada, but gained some USD Tokens. The swap is complete, using the exchange rate as it is live, right now, which was injected
into the mock blockchain via the oracle.</p>
<p>So now we have seen an end-to-end example of a Plutus dApp. It has a front end, it talks to the outside world, goes on the internet, gets information and interacts with Plutus smart contracts.
The smart contracts submit transactions to the blockchain where the validation logic kicks in and makes sure that everything follows the business rules.</p>
<p>In this example, as we have no real blockchain to play with, all wallets use the same PAB server, which, of course, in real life would be silly. Obviously, different
wallets will have different instances of PAB running.</p>
<p>But, apart from that, it is almost exactly, end-to-end, how such a system would work.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
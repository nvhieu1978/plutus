

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Week 07 - State Machines &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="plutus_pioneer_program.html">1. Plutus Pioneer Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="alonzo_white.html">1. Alonzo White Walkthrough</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Week 07 - State Machines</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week7.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-07-state-machines">
<h1>Week 07 - State Machines<a class="headerlink" href="#week-07-state-machines" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=oJupInqvJUI">Lecture
#7</a>.</p>
<p>It covers commit schemes and state machines.</p>
<p>This week we were using Plutus commit 530cc134364ae186f39fb2b54239fb7c5e2986e9</p>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this lecture we will look at state machines. State machines can be very useful for writing shorter and more concise contracts, both on-chain and off-chain. There is higher level support for state machines in the Plutus libraries that builds on top of the lower level mechanisms we have seen so far.</p>
<p>As a running example, we are going to implement a little game, played between Alice and Bob. It’s a bit like Rock, Paper, Scissors, but even simpler, because there are
only two options.</p>
<p>Alice and Bob both have two options, they can either play 0 or 1.</p>
<div class="figure align-default">
<img alt="_images/week07__00000.png" src="_images/week07__00000.png" />
</div>
<p>If there were to play this game while being physically in the same room, they would make their moves at the same time. There would be one gesture for 0 and one
gesture for 1, they would raise their hands simultaneously, and, depending on what they play, one of them wins.</p>
<p>If they both play the same number, Alice wins. If they play different numbers, Bob wins.</p>
<div class="figure align-default">
<img alt="_images/week07__00001.png" src="_images/week07__00001.png" />
</div>
<p>Now let’s imagine that Alice and Bob can’t meet in person but that they still want to play the game. So, they decide to play it via mail - email or snail mail, it doesn’t
matter. How would that work?</p>
<p>Alice could send her move to Bob.</p>
<div class="figure align-default">
<img alt="_images/week07__00004.png" src="_images/week07__00004.png" />
</div>
<p>This, however, gives a very unfair advantage to Bob, because now he opens Alice’s mail, see that she has played 0, and he can simply reply with 1, and he wins.</p>
<div class="figure align-default">
<img alt="_images/week07__00003.png" src="_images/week07__00003.png" />
</div>
<p>And, if Alice plays 1, Bob can simply respond with 1. So Bob always wins, at least if he is unfair.</p>
<div class="figure align-default">
<img alt="_images/week07__00005.png" src="_images/week07__00005.png" />
</div>
<p>What can we do about that?</p>
<p>There’s a very clever trick which is often used in cryptographic protocols, and that is commit schemes. The idea is that Alice doesn’t reveal her choice to Bob, but she commits to it, so that she cannot later change her mind.</p>
<p>One way to make that work is using hash functions.</p>
<p>Hashes are all over the place in the blockchain world. We have seen that script addresses are just the hash of the Plutus code script, and we have seen lots of examples of
public key hashes.</p>
<p>A hash function is a one-way function. Given a hash, tt is difficult, or impossible, to reconstruct the original byte string that was hashed.</p>
<p>So, one way we could try to make this work is that, instead of Alice sending her choice to Bob, she instead sends the hash of her choice.</p>
<div class="figure align-default">
<img alt="_images/week07__00006.png" src="_images/week07__00006.png" />
</div>
<p>Bob then sees this cryptic byte string and he has no idea whether Alice picked 0 or 1.</p>
<p>Bob then replies with his move, picking, for example 0. There is no need for him to use a hash, he can just send his response in clear text.</p>
<p>Now, Alice would have won. But perhaps Bob doesn’t believe her. So there is one additional step that Alice has to take.</p>
<p>Alice has to send her actual choice to Bob in clear text. Bob then has to check that the hash of her choice is indeed the same as the hash Alice sent earlier.</p>
<div class="figure align-default">
<img alt="_images/week07__00007.png" src="_images/week07__00007.png" />
</div>
<p>If it is, then he knows sees that Alice is not lying and that indeed he lost. If it does not match, then he knows that Alice is cheating and he would win.</p>
<p>This all sounds promising, but there is one big problem with it.</p>
<p>In this game there are only two choices, 0 and 1. Which means that there are only two possible hashes. They may look very cryptic to Bob the first time they play,
but before long he will notice that he always sees one of only two possible hashes, and then he can know which choice Alice made.</p>
<p>This is almost as bad as if Alice had just sent her choice in clear text.</p>
<p>What we can do about this is that, instead of sending the hash of her choice, she instead first selects an arbitrary byte string and then hashes the
concatenated of this byte string and her choice. The arbitrary byte string that Alice chooses is called a <em>nonce</em> - a number to be used just once.</p>
<div class="figure align-default">
<img alt="_images/week07__00008.png" src="_images/week07__00008.png" />
</div>
<p>So now, it is not always the same byte string if she picks 0, provided she chooses some random, unpredictable nonce.</p>
<p>Now, Bob receives this and we proceed as before - Bob sends his choice, and then, in the third message Alice needs to send not only her original choice, but she also
has to send the nonce as well.</p>
<div class="figure align-default">
<img alt="_images/week07__00010.png" src="_images/week07__00010.png" />
</div>
<p>And then Bob checks that the hash of Alice’s claimed nonce concatenated with her choice is indeed the hash that he originally received. If it is, he knows he lost, and
if it is not, he knows that she tried to cheat him.</p>
<p>This works very nicely and this is what we will try to implement in Cardano. First we will do it using techniques we have already seen, and then we will see how, by using
state machines, the code can be much clearer and much shorter.</p>
</div>
<div class="section" id="code-example-1">
<h2>Code Example 1<a class="headerlink" href="#code-example-1" title="Permalink to this headline">¶</a></h2>
<p>We can imagine that, at the start of the game, Alice and Bob have put down the same amount of money each and that the winner will take it all.</p>
<p>The game starts with Alice posting her hash, as described above. Bob, if he plays along, will post his own choice. At this point, we have Alice’s hash and Bob’s choice.</p>
<div class="figure align-default">
<img alt="_images/week07__00011.png" src="_images/week07__00011.png" />
</div>
<p>If, at this point, Alice realizes that she has won, based on Bob’s choice, she can reveal her secret, the game ends, and she has won.</p>
<div class="figure align-default">
<img alt="_images/week07__00012.png" src="_images/week07__00012.png" />
</div>
<p>If, however, after Bob makes his move, Alice sees that she has lost, there is no need for her to do anything. After a certain deadline has been reached, if Alice has
not responded, Bob will be able to claim the funds.</p>
<div class="figure align-default">
<img alt="_images/week07__00013.png" src="_images/week07__00013.png" />
</div>
<p>There is a another scenario. Perhaps, after Alice starts playing, Bob simply isn’t interested. In this case, there must be a way for Alice to get her own money back.</p>
<div class="figure align-default">
<img alt="_images/week07__00016.png" src="_images/week07__00016.png" />
</div>
<p>As mentioned, our first attempt at coding this in Plutus will be using the techniques we have learned in previous lectures.</p>
<p>The code we are working with is in the following module</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week07.EvenOdd</span>
</pre></div>
</div>
<p>We call the game <em>EvenOdd</em> due to the fact that if the sum of the numbers is even, then the first player wins, and if the sum is odd, the second player wins.</p>
<p>In our code we will call the players <em>first</em> and <em>second</em> rather than Alice and Bob.</p>
<div class="section" id="on-chain">
<h3>On chain<a class="headerlink" href="#on-chain" title="Permalink to this headline">¶</a></h3>
<p>We define a data type <em>Game</em> which will be used as a parameter for the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Game</span> <span class="ow">=</span> <span class="kt">Game</span>
    <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>The players are identified by their public key hashes as <em>gFirst</em> and <em>gSecond</em>.</p>
<p>The number of lovelace to be used as stake in the game is represented by <em>gStake</em> - This stake must be provided by each player.</p>
<p>There are two deadlines. The <em>gPlayDeadline</em> is the slot by which the second player must make their move. In the case where the second player has made a move,
the <em>gRevealDeadline</em> is the slot by which player 1 must claim victory by revealing his nonce.</p>
<p>Finally we have a token represented by <em>gToken</em>. This will be the same trick that we used for the oracle. It will be an arbitrary NFT, used to identify the right
instance of the UTxO that we are using. The idea is to use the datum sitting at a UTxO in this contract’s script address to keep track of where we are in the game.</p>
<p>Next, we define the two moves that the players can make.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameChoice</span> <span class="ow">=</span> <span class="kt">Zero</span> <span class="o">|</span> <span class="kt">One</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameChoice</span> <span class="kr">where</span>
    <span class="cm">{-# INLINABLE (==) #-}</span>
    <span class="kt">Zero</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">One</span>  <span class="o">==</span> <span class="kt">One</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span>    <span class="o">==</span> <span class="kr">_</span>    <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>We need Plutus <em>Eq</em> for the instance, but it is not possible to declare that in the deriving clause, which is why the <em>Eq</em> in the deriving clause is qualified as being
from the standard Haskell Prelude.</p>
<p>Note that we have used the <em>INLINABLE</em> pragma on the <em>Eq</em> instance for <em>GameChoice</em>. This is again to make it compatible with the Template Haskell we will need to
use.</p>
<p>For state, we will use a type called <em>GameDatum</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameDatum</span> <span class="ow">=</span> <span class="kt">GameDatum</span> <span class="kt">ByteString</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">GameChoice</span><span class="p">)</span>
<span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameDatum</span> <span class="kr">where</span>
    <span class="cm">{-# INLINABLE (==) #-}</span>
    <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="n">mc</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs&#39;</span> <span class="n">mc&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">bs</span> <span class="o">==</span> <span class="n">bs&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mc</span> <span class="o">==</span> <span class="n">mc&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the <em>ByteString</em> is the hash that the first player submits, and <em>Maybe GameChoice</em> is either <em>Just</em> the move of the second player, or <em>Nothing</em>, if they have not yet moved.</p>
<p>Now we come to the redeemer, and we will use a custom type for this as well.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameRedeemer</span> <span class="ow">=</span> <span class="kt">Play</span> <span class="kt">GameChoice</span> <span class="o">|</span> <span class="kt">Reveal</span> <span class="kt">ByteString</span> <span class="o">|</span> <span class="kt">ClaimFirst</span> <span class="o">|</span> <span class="kt">ClaimSecond</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>Here <em>Play</em> is where the second player moves and, as an argument, it has a <em>GameChoice</em>. <em>Reveal</em> is for the case where the first player has won and must prove that
by revealing their nonce, and the nonce is represented by the <em>ByteString</em> argument. We don’t need to include the move for the <em>Reveal</em>, as they will only reveal if they
have won, and we know what move makes them win.</p>
<p><em>ClaimFirst</em> is when the first player claims back the stake in the even that the second player does not make a move by the play deadline. <em>ClaimSecond</em> is for the
case when the first player does not reveal by the reveal deadline.</p>
<p>We then have our <em>lovelaces</em> helper function which we have used in other scripts, which gets the number of lovelaces held in a <em>Value</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>And we have a helper function <em>gameDatum</em> which behaves exactly the same way as the function <em>oracleValue</em>, which you can find in the notes from lecture 6.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameDatum</span> <span class="ow">::</span> <span class="kt">TxOut</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">DatumHash</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Datum</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">GameDatum</span>
<span class="nf">gameDatum</span> <span class="n">o</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">dh</span>      <span class="ow">&lt;-</span> <span class="n">txOutDatum</span> <span class="n">o</span>
    <span class="kt">Datum</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">dh</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">d</span>
</pre></div>
</div>
<p>Now we come to the core business logic in the <em>mkGameValidator</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkGameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkGameValidator</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="n">dat</span> <span class="n">red</span> <span class="n">ctx</span> <span class="ow">=</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first argument is the <em>Game</em> parameter discussed above.</p>
<p>The second and the third arguments are somewhat of a nuisance. We just need them due to the fact that it is not possible to use string literals to
get <em>ByteStrings</em> in Haskell that is compiled to Plutus core. And, we want string literals representing the 0 and 1 choices. So <em>bsZero’</em> will hold “0” and
<em>beOne’</em> will hold “1”. You will see how we pass these in as auxiliary arguments later.</p>
<p>Then we pass in the usual arguments for datum, redeemer and context.</p>
<p>Let’s look at some helper functions first. There are three functions we have used before and discussed in lecture 6.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
<span class="nf">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

<span class="nf">ownInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownInput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;game input missing&quot;</span>
    <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>

<span class="nf">ownOutput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownOutput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">getContinuingOutputs</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
    <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one game output&quot;</span>
</pre></div>
</div>
<p>Note the <em>ownInput</em> should never fail as we are in the process of validating a UTxO.</p>
<p>The <em>outputDatum</em> helper makes use of the <em>GameDatum</em> type which we defined earlier. Given the case we have exactly one output (the return from <em>ownOutput</em>), it will
give us the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">outputDatum</span> <span class="ow">::</span> <span class="kt">GameDatum</span>
<span class="nf">outputDatum</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">gameDatum</span> <span class="n">ownOutput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;game output datum not found&quot;</span>
    <span class="kt">Just</span> <span class="n">d</span>  <span class="ow">-&gt;</span> <span class="n">d</span>
</pre></div>
</div>
<p>The <em>checkNonce</em> function is for the case where the first player as won and wants to prove it by revealing their nonce. The first argument is hash that was original sent,
the second argument is the nonce that is being revealed.</p>
<p>For the <em>GameChoice</em>-typed parameter, we will be passing in the move made by player 2. This should be the same as the move made by player 1, and this is what this function will determine using the hash and the nonce.</p>
<p>In order to check the hash of the nonce concatenated with the <em>GameChoice</em>, we use a helper function to convert the <em>GameChoice</em> to a <em>ByteString</em>. Note that the use
of the <em>cFirst</em> and <em>cSecond</em> in the <em>checkNonce</em> function could be swapped around, and the function would work just the same - the difference between the two is that
one is a <em>GameChoice</em> and one is a <em>ByteString</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkNonce</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">cSecond</span> <span class="ow">=</span> <span class="n">sha2_256</span> <span class="p">(</span><span class="n">nonce</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="n">cFirst</span><span class="p">)</span> <span class="o">==</span> <span class="n">bs</span>
  <span class="kr">where</span>
    <span class="n">cFirst</span> <span class="ow">::</span> <span class="kt">ByteString</span>
    <span class="n">cFirst</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">cSecond</span> <span class="kr">of</span>
        <span class="kt">Zero</span> <span class="ow">-&gt;</span> <span class="n">bsZero&#39;</span>
        <span class="kt">One</span>  <span class="ow">-&gt;</span> <span class="n">bsOne&#39;</span>
</pre></div>
</div>
<p>Finally, there is the question of what happens to the NFT once the game is over and there is no game address anymore. The way we have implemented it here, is that the NFT goes back to the first player. The first player needs it in the beginning to kick off the game and put the NFT
into the correct UTxO, so it is reasonable to give it back the player 1 in the end.</p>
<p>To verify that this condition is met, we have created a helper function called <em>nftToFirst</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nftToFirst</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">nftToFirst</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">valuePaidTo</span> <span class="n">info</span> <span class="o">$</span> <span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Now that we have covered the helper functions, let’s look at the conditions.</p>
<p>There is one condition that covers all the cases, and that is that the input we are validating must contain the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</pre></div>
</div>
<p>After that, the rules depend on the situation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">red</span><span class="p">)</span> <span class="kr">of</span>
</pre></div>
</div>
<p>The first situation is the one where the second player has not yet moved, and they are just now making their move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span>            <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>                             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>         <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span>     <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the first part is the <em>GameDatum</em> and it contains the first player’s hash and a <em>Nothing</em> which shows that the second player has not yet moved. The second part is the <em>GameRedeemer</em> and has been determined
to be of type <em>Play GameChoice</em>. We assign the <em>GameChoice</em> part to <em>c</em> using pattern matching.</p>
<p>We check that the second player has signed the transaction.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>
</pre></div>
</div>
<p>Then, we check that the first player’s stake is present in the input.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>The output should have the second player’s stake added to the total stake.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>
</pre></div>
</div>
<p>We now exactly what the datum of the output must be. It must be the same hash, plus the move made by the second player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span> <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>
</pre></div>
</div>
<p>The, the move must happen before the play deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>
</pre></div>
</div>
<p>And finally, the NFT must be passed on in the output UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second situation is where both players have moved, and the second player discovers that they have won. In order to prove that and get the winnings, they have
to reveal their nonce.</p>
<p>So, the transaction must be signed by the first player, the nonce must indeed agree with the hash submitted earlier, it must be done before the reveal deadline,
the input must contain both players’ stakes and, finally, the NFT must go back to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="n">nonce</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;commit mismatch&quot;</span>               <span class="p">(</span><span class="n">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">c</span><span class="p">)</span>                                            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>       <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>Next we have the case where the second player doesn’t move within the deadline, and the first player is reclaiming their stake. Here, the first player must have signed
the transaction, the play deadline must have passed, their stake must be present, and the NFT must go back to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>Finally, the case where both players have moved and the first player has either lost or not revealed in time, so the second player is claiming the winnings. This time, the
transaction must be signed by the second player, the reveal deadline must have passed, both players’ stakes must be present, and the NFT must, as usual, go back
to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>These four cases are all the legitimate cases that we can have, so in all other cases we fail validation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
</pre></div>
</div>
<p>So now let’s look at the rest of the on-chain code.</p>
<p>As usual, we define a data type that holds the information about the types the datum and redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Gaming</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Gaming</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameDatum</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>And we define the <em>ByteStrings</em> that will be used to represent the two choices. These values are completely arbitrary - they just can’t be the same as each other.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bsZero</span><span class="p">,</span> <span class="n">bsOne</span> <span class="ow">::</span> <span class="kt">ByteString</span>
<span class="nf">bsZero</span> <span class="ow">=</span> <span class="s">&quot;0&quot;</span>
<span class="nf">bsOne</span>  <span class="ow">=</span> <span class="s">&quot;1&quot;</span>
</pre></div>
</div>
<p>Boilerplate to compile our parameterized <em>mkGameValidator</em> to Plutus code. We apply the three parameters, <em>Game</em> and the two <em>ByteStrings</em>s. Remember that, we need
to pass in these <em>ByteString</em> parameters because we can’t refer to <em>ByteString</em>s as string literals within Plutus.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameInst</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Gaming</span>
<span class="nf">gameInst</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Gaming</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkGameValidator</span> <span class="o">||</span><span class="p">])</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">game</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">bsZero</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">bsOne</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">GameDatum</span> <span class="o">@</span><span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>The usual boilerplate for validator and address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">gameValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">gameInst</span>

<span class="nf">gameAddress</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">gameAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">gameValidator</span>
</pre></div>
</div>
<p>Now, as preparation for the off-chain code, we will need to be able to find the right UTxO - the one that carries the NFT. To do this we will write a helper function
called <em>findGameOutput</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findGameOutput</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">GameDatum</span><span class="p">))</span>
<span class="nf">findGameOutput</span> <span class="n">game</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">gameAddress</span> <span class="n">game</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">find</span> <span class="n">f</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
        <span class="n">dat</span>       <span class="ow">&lt;-</span> <span class="n">gameDatum</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(`</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span><span class="p">`</span> <span class="n">txData</span> <span class="p">(</span><span class="n">txOutTxTx</span> <span class="n">o</span><span class="p">))</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The <em>findGameOutput</em> function takes the <em>Game</em>, then uses the <em>Contract</em> monad to try to find the UTxO with the NFT. It returns a <em>Maybe</em>, because it may not find one.
If we find it, we return a <em>Just</em> of a triple containing the transaction reference, the transaction itself, and the <em>GameDatum</em>.</p>
<p>First we get a list of all the UTxOs at the game address, then we use the <em>find</em> function, passing in a helper function <em>f</em>, which checks whether the output contains the
NFT.</p>
<p>The <em>find</em> function is found in module <em>Data.List</em> and is defined as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">find</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>This works for more general containers than just lists, but you can think of lists in this example. It gets a predicate for an element of the <em>Foldable</em> type - the list in
this case, and also takes a container of <em>a</em>s - again a list in this example, and returns a <em>Maybe a</em>.</p>
<p>The logic is that if it finds an element that satisfies the predicate, it will return it as a <em>Just</em>, otherwise it will return <em>Nothing</em>. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">EvenOdd</span><span class="o">&gt;</span> <span class="n">find</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">8</span>

<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">EvenOdd</span><span class="o">&gt;</span> <span class="n">find</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<div class="section" id="the-firstgame-contract">
<h4>The <em>firstGame</em> contract<a class="headerlink" href="#the-firstgame-contract" title="Permalink to this headline">¶</a></h4>
<p>We have two contracts, one for each of the players.</p>
<p>Each contract has its own params type. For the <em>firstGame</em> contract, we call this type <em>FirstParams</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">FirstParams</span> <span class="ow">=</span> <span class="kt">FirstParams</span>
    <span class="p">{</span> <span class="n">fpSecond</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">fpStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">fpPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">fpRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">fpNonce</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">ByteString</span>
    <span class="p">,</span> <span class="n">fpCurrency</span>       <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">fpTokenName</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">fpChoice</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">GameChoice</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>We don’t need a <em>fpFirst</em> field here, as the first player is the owner of the wallet, so we know their public key hash. But we need <em>fpSecond</em> and also the familiar
fields for stake, play deadline and reveal deadline.</p>
<p>Then we need the nonce, the NFT (split into <em>fpCurrency</em> and <em>fpTokenName</em>), and finally the move that the player wants to make.</p>
<p>Now, for the contract</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">firstGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">FirstParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">firstGame</span> <span class="n">fp</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first thing we do is to get our own public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
</pre></div>
</div>
<p>Then we populate the fields of the game.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Game</span>
        <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">pkh</span>
        <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">fpSecond</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">fpStake</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">fpCurrency</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fpTokenName</span> <span class="n">fp</span><span class="p">)</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>The <em>v</em> value is our stake plus the NFT, which must both go into the UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">v</span>    <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">fpStake</span> <span class="n">fp</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We then calculate the hash that we need to send as our disguised move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">c</span>    <span class="ow">=</span> <span class="n">fpChoice</span> <span class="n">fp</span>
    <span class="n">bs</span>   <span class="ow">=</span> <span class="n">sha2_256</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="kr">then</span> <span class="n">bsZero</span> <span class="kr">else</span> <span class="n">bsOne</span>
</pre></div>
</div>
<p>We then submit the transaction and wait as usual. The constraints are very simple. We just need to create a UTxI with the datum of our move (nothing yet for the second player), and the value <em>v</em> we defined above.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">tx</span>   <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">v</span>
<span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span> <span class="n">tx</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">fpChoice</span> <span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<p>And we wait for the play deadline slot, at which point the winner can be determined.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
</pre></div>
</div>
<p>Once the deadline passed, we get hold of the UTxO. If, at this point, the UTxO is not found, something has gone very wrong. We know that we have produced the UTxO, and the
only thing that the second player should be able to do is create a new one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
<span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>             <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="s">&quot;game output not found&quot;</span>
</pre></div>
</div>
<p>So, assuming we find it, the first case we define is the one where the second player hasn’t moved. So we can use the <em>ClaimFirst</em> redeemer to get the stake back.</p>
<p>As lookups we need to provide the UTxO and the validator of the game.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">dat</span> <span class="kr">of</span>
    <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player did not play&quot;</span>
        <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                      <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
            <span class="n">tx&#39;</span>     <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">ClaimFirst</span><span class="p">)</span>
        <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx&#39;</span>
        <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;reclaimed stake&quot;</span>
</pre></div>
</div>
<p>The second case is that the second player did move, and they lost. In which case we must now reveal our nonce, which we do using the <em>Reveal</em> redeemer.</p>
<p>We must put an additional constraint that the transaction must be submitted before the reveal deadline has passed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">c&#39;</span> <span class="o">==</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and lost&quot;</span>
    <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>                                         <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
        <span class="n">tx&#39;</span>     <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">Reveal</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span><span class="p">)</span>
    <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;victory&quot;</span>
</pre></div>
</div>
<p>If the second player moved and won, there is nothing for use to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and won&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-secondgame-contract">
<h4>The <em>secondGame</em> contract<a class="headerlink" href="#the-secondgame-contract" title="Permalink to this headline">¶</a></h4>
<p>The params for the second player are similar to those of the first player. This time we don’t need the second player’s public key hash, because that is ours, and we already
know what it is. Instead we need the first player’s public key hash. Also, we don’t need the nonce.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">SecondParams</span> <span class="ow">=</span> <span class="kt">SecondParams</span>
    <span class="p">{</span> <span class="n">spFirst</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">spStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">spPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">spRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">spCurrency</span>       <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">spTokenName</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">spChoice</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">GameChoice</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>First we get our own public key hash then we set up the game values, in a similar way as we did for the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">secondGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">SecondParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">secondGame</span> <span class="n">sp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Game</span>
            <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">spFirst</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">spStake</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">spCurrency</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spTokenName</span> <span class="n">sp</span><span class="p">)</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>Now, we try to find the UTxO that contains the NFT</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
</pre></div>
</div>
<p>If we don’t find it, then there is nothing to do, but if we do find it…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;running game found&quot;</span>
</pre></div>
</div>
<p>Then we want to call the script with the <em>Play</em> redeemer.</p>
<p>We assign the NFT to <em>token</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">token</span>   <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We now calculate the value that we must put in the new output. Remember, if we decide to play, we must consume the existing UTxO and create a new one at the same address. The
first will contain the stake that the first player added, and now we must add our own stake, and we must keep the NFT in there.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">spStake</span> <span class="n">sp</span><span class="p">)</span> <span class="kr">in</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">token</span>
</pre></div>
</div>
<p>Next, our choice.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">spChoice</span> <span class="n">sp</span>
</pre></div>
</div>
<p>Then the constraints and their required lookups.</p>
<p>We must consume the existing UTxO using the Play redeemer with our choice</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
</pre></div>
</div>
<p>And create a new UTxO with the updated datum (the same <em>bs</em>, but with our choice), and with the <em>v</em> that we computed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">c</span><span class="p">)</span> <span class="n">v</span> <span class="o">&lt;&gt;</span>
</pre></div>
</div>
<p>And it must be done before the deadline passes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>For lookups, we need the UTxO, the validator, and, because we are producing a UTxO for the script, we need the script instance.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>                            <span class="o">&lt;&gt;</span>
              <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>                                 <span class="o">&lt;&gt;</span>
              <span class="kt">Constraints</span><span class="o">.</span><span class="n">scriptInstanceLookups</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we do the usual thing, we submit, we wait for confirmation and we log.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx</span>
<span class="kr">let</span> <span class="n">tid</span> <span class="ow">=</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="n">tid</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">spChoice</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we wait until the reveal deadline has passed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
</pre></div>
</div>
<p>And we again try to find the UTxO, which could now be a different one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
</pre></div>
</div>
<p>If <em>m’</em> is <em>Nothing</em> - in other words, if we did not find a UTxO, then that means that while we were waiting, the first player revealed and won. So there is nothing
for us to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m&#39;</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>             <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player won&quot;</span>
</pre></div>
</div>
<p>However, if we do find the UTxO, it means the first player didn’t reveal, which means that either they decided not to play, probably because they lost. In any case, we
can now claim the winnings.</p>
<p>Our constraints are that we must spend the UTxO that we found after the deadline has passed, and we must hand back the NFT to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
    <span class="kr">let</span> <span class="n">lookups&#39;</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref&#39;</span> <span class="n">o&#39;</span><span class="p">)</span>                              <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
        <span class="n">tx&#39;</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref&#39;</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span><span class="p">)</span>                      <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">spFirst</span> <span class="n">sp</span><span class="p">)</span> <span class="n">token</span>
    <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups&#39;</span> <span class="n">tx&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player won&quot;</span>
</pre></div>
</div>
<p>If we didn’t find the NFT, then there is nothing for use to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no running game found&quot;</span>
</pre></div>
</div>
<p>That is all the code we need for the two on-chain contracts.</p>
<p>To make them more accessible, we define two <em>Endpoint</em>s, one for the first player, and one for the second. And then we define a contract
called <em>endpoints</em> which offers a choice between these two <em>Endpoint</em>s, and recursively calls itself.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">GameSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;first&quot;</span> <span class="kt">FirstParams</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;second&quot;</span> <span class="kt">SecondParams</span>

<span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">GameSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">first</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">second</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">first</span>  <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;first&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">firstGame</span>
    <span class="n">second</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;second&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">secondGame</span>
</pre></div>
</div>
<p>So this concludes the first version of the game - the version that does not use state machines.</p>
<p>Now, let’s test it using the <em>EmulatorTrace</em> monad.</p>
</div>
<div class="section" id="testing">
<h4>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h4>
<p>The <em>test</em> function tests each of the four combinations by calling the <em>test’</em> function which takes the first and second players’ choices respectively.</p>
<p>The <em>test’</em> function uses the <em>runEmulatorTraceIO’</em> variant which allows us to set up the initial wallet distributions using an <em>EmulatorConfig</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">test&#39;</span> <span class="kt">Zero</span> <span class="kt">Zero</span>
    <span class="n">test&#39;</span> <span class="kt">Zero</span> <span class="kt">One</span>
    <span class="n">test&#39;</span> <span class="kt">One</span> <span class="kt">Zero</span>
    <span class="n">test&#39;</span> <span class="kt">One</span> <span class="kt">One</span>

<span class="nf">test&#39;</span> <span class="ow">::</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test&#39;</span> <span class="n">c1</span> <span class="n">c2</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">emCfg</span> <span class="o">$</span> <span class="n">myTrace</span> <span class="n">c1</span> <span class="n">c2</span>
  <span class="kr">where</span>
    <span class="n">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
    <span class="n">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
        <span class="p">[</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="kt">AssetClass</span> <span class="p">(</span><span class="n">gameTokenCurrency</span><span class="p">,</span> <span class="n">gameTokenName</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">,</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="n">v</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="mi">1000_000_000</span>
</pre></div>
</div>
<p>As NFTs are not the focus of this lecture, we have conjured a test NFT out of thin air. In a real world scenario, we would need to mint a real NFT, using one of the methods we have seen before.</p>
<p>Now the trace. We pass the two game choices into the <em>myTrace</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="n">c1</span> <span class="n">c2</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c1</span> <span class="o">++</span> <span class="s">&quot;, second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c2</span>
</pre></div>
</div>
<p>Then we start two instances of the contract, one for wallet 1 and one for wallet 2.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
<span class="nf">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
</pre></div>
</div>
<p>We look up the two public key hashes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">pkh1</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">1</span>
    <span class="n">pkh2</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Then we define the parameters that we are going to use for the contracts. In reality <em>fpNonce</em> would be some random string, but here we just hardcode as “SECRETNONCE”.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fp</span> <span class="ow">=</span> <span class="kt">FirstParams</span>
        <span class="p">{</span> <span class="n">fpSecond</span>         <span class="ow">=</span> <span class="n">pkh2</span>
        <span class="p">,</span> <span class="n">fpStake</span>          <span class="ow">=</span> <span class="mi">5000000</span>
        <span class="p">,</span> <span class="n">fpPlayDeadline</span>   <span class="ow">=</span> <span class="mi">5</span>
        <span class="p">,</span> <span class="n">fpRevealDeadline</span> <span class="ow">=</span> <span class="mi">10</span>
        <span class="p">,</span> <span class="n">fpNonce</span>          <span class="ow">=</span> <span class="s">&quot;SECRETNONCE&quot;</span>
        <span class="p">,</span> <span class="n">fpCurrency</span>       <span class="ow">=</span> <span class="n">gameTokenCurrency</span>
        <span class="p">,</span> <span class="n">fpTokenName</span>      <span class="ow">=</span> <span class="n">gameTokenName</span>
        <span class="p">,</span> <span class="n">fpChoice</span>         <span class="ow">=</span> <span class="n">c1</span>
        <span class="p">}</span>
<span class="nf">sp</span> <span class="ow">=</span> <span class="kt">SecondParams</span>
        <span class="p">{</span> <span class="n">spFirst</span>          <span class="ow">=</span> <span class="n">pkh1</span>
        <span class="p">,</span> <span class="n">spStake</span>          <span class="ow">=</span> <span class="mi">5000000</span>
        <span class="p">,</span> <span class="n">spPlayDeadline</span>   <span class="ow">=</span> <span class="mi">5</span>
        <span class="p">,</span> <span class="n">spRevealDeadline</span> <span class="ow">=</span> <span class="mi">10</span>
        <span class="p">,</span> <span class="n">spCurrency</span>       <span class="ow">=</span> <span class="n">gameTokenCurrency</span>
        <span class="p">,</span> <span class="n">spTokenName</span>      <span class="ow">=</span> <span class="n">gameTokenName</span>
        <span class="p">,</span> <span class="n">spChoice</span>         <span class="ow">=</span> <span class="n">c2</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>And then we call the endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;first&quot;</span> <span class="n">h1</span> <span class="n">fp</span>

<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;second&quot;</span> <span class="n">h2</span> <span class="n">sp</span>

<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Now, we can run this test from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cabal</span> <span class="n">repl</span>
<span class="kt">Prelude</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">StateMachine</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">Test</span>
<span class="kt">Prelude</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">Test</span><span class="o">&gt;</span> <span class="n">test</span>
</pre></div>
</div>
<div class="section" id="test-1">
<h5>Test 1<a class="headerlink" href="#test-1" title="Permalink to this headline">¶</a></h5>
<p>The first scenario is that both play zero, so the first wallet should win.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">fbe753823edc9d69538ae9a03702708ccac2b9ae58b8426bcfcf99e274dd552</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">USER</span> <span class="kt">LOG:</span> <span class="n">first</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span><span class="p">,</span> <span class="n">second</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
</pre></div>
</div>
<p>The first wallet creates the initial UTxO with its stake, and logs a message that it made the move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;first&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;fpChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;fpCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpNonce&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;5345435245544e4f4e4345&quot;</span><span class="p">),(</span><span class="s">&quot;fpPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;fpRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;fpSecond&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;fpTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made first move: Zero&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Slot</span> <span class="mi">00003</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">4</span>
</pre></div>
</div>
<p>While the first wallet is waiting, the second wallet kicks in and finds the UTxO, sees that it can make a move, and does so.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;second&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;spChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;spCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;spFirst&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9&quot;</span><span class="p">)])),(</span><span class="s">&quot;spPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;spRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;spStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;spTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;running game found&quot;</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="mi">9</span><span class="n">ff5cf1ce61c0395b653a57449c39ed14f06bb75600057ea0e32a8d1588d048e</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">ff5cf1ce61c0395b653a57449c39ed14f06bb75600057ea0e32a8d1588d048e</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">5</span>
<span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made second move: Zero&quot;</span>
</pre></div>
</div>
<p>The first player realizes that they have won, and so must reveal. And we see in the final balances that Wallet 1 does indeed have the NFT back and it also has
almost 5 ada more than it started with. The difference is, of course, due to transaction fees. And the second wallet has a little more than 5 ada less.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">6</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player played and lost&quot;</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="n">ea946a524a7a3959743fc4c5dbc3982bf1510a84d973fecbb660a328bb58c0b5</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">ea946a524a7a3959743fc4c5dbc3982bf1510a84d973fecbb660a328bb58c0b5</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">7</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;victory&quot;</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">8</span>
<span class="kt">Slot</span> <span class="mi">00008</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">9</span>
<span class="kt">Slot</span> <span class="mi">00009</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">10</span>
<span class="kt">Slot</span> <span class="mi">00010</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">11</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;first player won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">12</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">13</span>
<span class="kt">Slot</span> <span class="mi">00013</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">14</span>
<span class="kt">Slot</span> <span class="mi">00014</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">15</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1004999980</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">994999990</span>
</pre></div>
</div>
</div>
<div class="section" id="test-2">
<h5>Test 2<a class="headerlink" href="#test-2" title="Permalink to this headline">¶</a></h5>
<p>In the second case, Wallet 1 again plays Zero, but this time Wallet 2 plays One.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">fbe753823edc9d69538ae9a03702708ccac2b9ae58b8426bcfcf99e274dd552</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">USER</span> <span class="kt">LOG:</span> <span class="n">first</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span><span class="p">,</span> <span class="n">second</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">One</span>
</pre></div>
</div>
<p>The beginning is the same.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;first&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;fpChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;fpCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpNonce&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;5345435245544e4f4e4345&quot;</span><span class="p">),(</span><span class="s">&quot;fpPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;fpRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;fpSecond&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;fpTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made first move: Zero&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Slot</span> <span class="mi">00003</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Now the second wallet finds the game, and makes its move, but now the move is One.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;second&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;spChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;One&quot;</span><span class="p">),(</span><span class="s">&quot;spCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;spFirst&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9&quot;</span><span class="p">)])),(</span><span class="s">&quot;spPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;spRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;spStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;spTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;running game found&quot;</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="mi">3200</span><span class="n">aab18d986869a7e9aa65ff45a635e0bc2dff9b04df26a0864355990f9c10</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">3200</span><span class="n">aab18d986869a7e9aa65ff45a635e0bc2dff9b04df26a0864355990f9c10</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">5</span>
<span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made second move: One&quot;</span>
</pre></div>
</div>
<p>Now the first wallet realizes it has lost and does nothing.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">6</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player played and won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">7</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">8</span>
<span class="kt">Slot</span> <span class="mi">00008</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">9</span>
<span class="kt">Slot</span> <span class="mi">00009</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">10</span>
<span class="kt">Slot</span> <span class="mi">00010</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">11</span>
</pre></div>
</div>
<p>The second wallet detects that the deadline has passed without a reveal, and invokes the <em>ClaimSecond</em> endpoint to get the money. When we look at the final balances,
Wallet 1 again has the NFT back, but the Ada balance situation is reversed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="n">a66744d7b4692db9457d9c3a5d832db7d1471299bd36ffe27827f41ec3e999f1</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">a66744d7b4692db9457d9c3a5d832db7d1471299bd36ffe27827f41ec3e999f1</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">12</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">13</span>
<span class="kt">Slot</span> <span class="mi">00013</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">14</span>
<span class="kt">Slot</span> <span class="mi">00014</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">15</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">994999990</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1004999980</span>
</pre></div>
</div>
<p>The remaining two cases are very similar, so we won’t post the logs here.</p>
<p>So, this all seems to work as expected.</p>
</div>
</div>
</div>
</div>
<div class="section" id="code-example-2">
<h2>Code Example 2<a class="headerlink" href="#code-example-2" title="Permalink to this headline">¶</a></h2>
<p>Now we will rewrite this code using state machines.</p>
<div class="section" id="what-is-a-state-machine">
<h3>What is a state machine?<a class="headerlink" href="#what-is-a-state-machine" title="Permalink to this headline">¶</a></h3>
<p>A state machine has nothing in particular to do with blockchain. It is a system that starts with some sort of state, there are one or more transitions to other states,
and from those states there are further transitions, and so on, like a directed graph. Some states can be <em>final</em> states, from which there can be no further
transitions.</p>
<div class="figure align-default">
<img alt="_images/week07__00014.png" src="_images/week07__00014.png" />
</div>
<p>If we look again at how our games works, then we can consider it to be a state machine.</p>
<div class="figure align-default">
<img alt="_images/week07__00016.png" src="_images/week07__00016.png" />
</div>
<p>The initial state would be [Hash], where the first player has made the move.</p>
<p>From the initial state, there are two possible transitions. One where Bob plays, and the other where Bob does not player and Alice can reclaim.</p>
<p>In the diagram, all the nodes correspond to states, and all the arrows correspond to transitions.</p>
<p>In the blockchain, the state machine will be represented by a UTxO sitting at the state machine address. The state of the machine will be the datum of that UTxO.
A transition will be a transaction that consumes the current state, using a redeemer that characterizes the transition, and then produces a new UTxO at the same
address, where the datum now reflects the new state.</p>
<p>This pattern fits a lot of situations very nicely, and there is special support in the Plutus libraries to implement such state machines. We will see that when we use
this approach, our code will be much shorter.</p>
<p>The support for state machines is in the package <em>plutus-contract</em>, in module <a class="reference external" href="https://playground.plutus.iohkdev.io/tutorial/haddock/plutus-contract/html/Language-Plutus-Contract-StateMachine.html">Language.Plutus.Contract.StateMachine</a></p>
<p>A StateMachine has two type parameters, <em>s</em> and <em>i</em>, which stand for state and input. These correspond to datum and redeemer, respectively.</p>
<div class="figure align-default">
<img alt="_images/week07__00017.png" src="_images/week07__00017.png" />
</div>
<p>It is a record type with four fields. Probably the most important one is <em>smTransition</em>, which defines which transitions can move which states which other states.</p>
<p>The <em>State s</em> type is basically the datum. It consists of the state itself and a value. Remember that the state of the state machine is represented by a UTxO, which has
a datum and a value.</p>
<div class="figure align-default">
<img alt="_images/week07__00019.png" src="_images/week07__00019.png" />
</div>
<p>Given the state type <em>s</em>, and a transaction that tries to consume this UTxO with a redeemer <em>i</em>, we can indicate that this transition is not allowed by returning <em>Nothing</em>.
If it is allowed, we return a tuple.</p>
<p>The second component of the tuple is the new state (the new datum and value), which is the new UTxO sitting at the same address, with the
first UTxO having been consumed.</p>
<p>The first component of the tuple specifies additional constraints that the transaction that does this must satisfy. Until now, we have only seen constraints in off-chain
code.</p>
<p>We then have a function <em>setFinal</em> which is predicated on the state which tells us whether it is a final state or not. Final states are special in that the resulting
<em>State</em> from the <em>setTransition</em> function must have no value attached to it, and the output does not get produced. The machine ends there.</p>
<p>The function <em>smCheck</em> is very similar to the <em>setTransition</em> function. It gets the datum, the redeemer and the context and returns a bool.
It provides additional checks that can’t be expressed by the <em>TxConstraints</em> in <em>setTransition</em>.</p>
<p>Finally, <em>smThreadToken</em> allows us to identify the UTxO which represents the current state. This is in the even that there us more than one UTxO sitting at the address
of the state machine. It uses the same trick that we have seen before of using an NFT sitting in the value of the correct UTxO. You could, however, always return <em>Nothing</em>
from <em>smThreadToken</em> and use some other mechanism to identify the correct UTxO.</p>
<p>The same game from example 1 has been implemented using a state machine, in the following module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week07.StateMachine</span>
</pre></div>
</div>
<p>The first parts of the code are the same - we have the same <em>Game</em> type and the same <em>GameChoice</em>. The first change we notice is with <em>GameDatum</em>.</p>
<p>We have added a second constructor to <em>GameDatum</em> called <em>Finished</em>. This will represent the final state of the state machine. It won’t correspond to a UTxO, but we
need it for the state machine mechanism to work.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameDatum</span> <span class="ow">=</span> <span class="kt">GameDatum</span> <span class="kt">ByteString</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">GameChoice</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Finished</span>
<span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>And this adds a little more complexity to the definition of equality.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameDatum</span> <span class="kr">where</span>
<span class="cm">{-# INLINABLE (==) #-}</span>
<span class="kt">GameDatum</span> <span class="n">bs</span> <span class="n">mc</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs&#39;</span> <span class="n">mc&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">bs</span> <span class="o">==</span> <span class="n">bs&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mc</span> <span class="o">==</span> <span class="n">mc&#39;</span><span class="p">)</span>
<span class="kt">Finished</span>        <span class="o">==</span> <span class="kt">Finished</span>          <span class="ow">=</span> <span class="kt">True</span>
<span class="kr">_</span>               <span class="o">==</span> <span class="kr">_</span>                 <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>The redeemer is exactly the same as before. The <em>lovelaces</em> and <em>gameDatum</em> helper functions are also exactly the same as before.</p>
<p>Now we get to the <em>transition</em> function, which sort of corresponds to the <em>mkGameValidator</em> function that we used in the previous example. It is basically the core
business logic.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">GameDatum</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>transition</em> function takes the <em>Game</em>, then a <em>State GameDatum</em>, which, as we saw in the definition of <em>StateMachine</em>, is a pair consisting of the datum and the value.
Thirdly, it takes the redeemer, and then returns a <em>Maybe</em> of the new state and constraints on the transaction.</p>
<p>Let’s compare the <em>transition</em> function of the state machine with the <em>mkGameValidator</em> function from our first game version.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">GameDatum</span><span class="p">)</span>
<span class="nf">transition</span> <span class="n">game</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span>         <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>
                                                     <span class="p">)</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="kr">_</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span>       <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                     <span class="p">)</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span>         <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>   <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                     <span class="p">)</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                     <span class="p">)</span>
    <span class="kr">_</span>                                        <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">where</span>
    <span class="n">token</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">token</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The first thing to notice is that, in the <em>transition</em> function we do not need to do our initial check for the presence of the NFT. This is because the state machine
takes care of that, so long as we set the last field of the <em>StateMachine</em> to some NFT asset class.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- we no longer need something like this for our state machine version</span>
<span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</pre></div>
</div>
<p>Let’s remind ourselves how we defined the first case where the first player had moved, the second player had not yet moved, and now the second player wants to make a move.
We had six conditions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span>            <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>                             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>         <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span>     <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s see how these conditions are reflected in the state machine version.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="n">game</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>
                                             <span class="p">,</span> <span class="kt">State</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>
                                             <span class="p">)</span>
</pre></div>
</div>
<p>We can access the value and datum components of our <em>State</em> parameter using <em>stateValue</em> and <em>stateData</em>, which gives us the triple for our <em>case</em> statement of
value, datum and redeemer.</p>
<p>Our matching case is now</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>First we check that the number of lovelaces in the value matches the stake of the game, which was our second condition in our code for this case from example 1. If this
condition is satisfied, we return a <em>Just</em> pair. The first component of the pair is the constraints on the transaction (formulated from the <em>Constraints</em> module that we know from off-chain code). The
two constraints that comprise this part of the pair correspond to the first and fifth conditions in our old code.</p>
<p>The second component of the pair is the new state - the resulting UTxO - which again is given by datum and value. So here we are specifying that the datum of the new
UTxO will contain both players’ choices, and the value of the UTxO will contain both players’ stakes. We leave the NFT out of this condition, even though it will be
present in the UTxO, and that is again because the state machine implicitly takes care of this for us.</p>
<p>This second component corresponds with the third and fourth conditions from our old code.</p>
<p>The sixth condition from our old code related to the NFT which, as we have seen, we do not need to worry about.</p>
<p>Now let’s compare the code from the second interesting case, where the second player has played and the first player sees that they have won.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- old version</span>
<span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="n">nonce</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;commit mismatch&quot;</span>               <span class="p">(</span><span class="n">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">c</span><span class="p">)</span>                                            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>       <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- new version</span>
<span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="kr">_</span><span class="p">)</span>
<span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span>       <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                             <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                             <span class="p">)</span>
</pre></div>
</div>
<p>Again, we see that the first thing we do is to check that the correct stake exists, and if it does, we again return a <em>Just</em>. So, this takes care of
condition four from the old code. Condition one from the old code is taken care of by the <em>Constraints.mustBeSignedBy</em> constraint in the new code.</p>
<p>Note that we do not check the nonce in the new code. The reason for this is that this check cannot be expressed in terms of a constraint. And this is exactly what
the <em>smCheck</em> function is for, and we will see how this is used for this in a moment.</p>
<p>We can also match up the deadline check from each code sample, with it being defined using <em>Constraints.mustValidateIn</em> in the new code.</p>
<p>In the old code, when the game was over, we returned the NFT to the first player. In the new code, we also make sure the NFT goes back to the first player, but
we also specify the <em>Finished</em> state and say that there is no money left in the contract using <em>mempty</em>.</p>
<p>Now we compare the old and the new code for the third case where the first player reclaims their stake when the second player does not play by the deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- old version</span>
<span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- new version</span>

<span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span>
<span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span>         <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>   <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                             <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                             <span class="p">)</span>
</pre></div>
</div>
<p>These two match up fairly easily, with the lovelaces being the condition on the left in the new code, and the remaining conditions on the right in the new code matching up with
corresponding conditions in the old code. Again we add the <em>Finished</em> state in the new code.</p>
<p>The last case, where the second player has played and the first player does not reveal by the deadline, probably because they lost.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                 <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                 <span class="p">)</span>
</pre></div>
</div>
<p>The conditions in the old and the new code for this last case can be matched up in a very similar way to those for the third case.</p>
<p>All other states with arbitrary transitions are invalid, and we indicate that by returning <em>Nothing</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>In the end we see that while the conditions themselves may not be much shorter in the new version than those in the old version, we also see that we only need one helper
function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">token</span> <span class="ow">::</span> <span class="kt">Value</span>
<span class="nf">token</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>But we are not yet finished defining the state machine. There are some other fields in the <em>StateMachine</em> record.</p>
<p>One is <em>smFinal</em>, which lets us define what the final states are. For us, it is just the <em>Finished</em> state. We define a helper function that we can use for this field.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">final</span> <span class="ow">::</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">final</span> <span class="kt">Finished</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">final</span> <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Another field to define is <em>smCheck</em>. Recall that this is where we can put conditions that cannot be expressed as <em>Constraint</em>s. So this is where we can put our nonce check.</p>
<p>We define another helper function <em>check</em>, with two auxiliary <em>ByteString</em> parameters to represent the zero and one choices, for reasons that we have seen before. We also
pass it the datum, redeemer and context, and it will return us a boolean.</p>
<p>We don’t need the script context, but we need the datum to get the second player’s choice (which the first player is claiming is the same as theirs), and the redeemer
to get the nonce that the first player is claiming to have used. We can then check that the hash of the choice and the nonce match the original hash from the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">check</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">check</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span> <span class="p">(</span><span class="kt">Reveal</span> <span class="n">nonce</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span>
    <span class="n">sha2_256</span> <span class="p">(</span><span class="n">nonce</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="kr">then</span> <span class="n">bsZero&#39;</span> <span class="kr">else</span> <span class="n">bsOne&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">bs</span>
</pre></div>
</div>
<p>In all other situations, those that are not checking the revealed nonce, we don’t need to perform any checks.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">check</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Now we can define our state machine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameStateMachine</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">StateMachine</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
<span class="nf">gameStateMachine</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="ow">=</span> <span class="kt">StateMachine</span>
    <span class="p">{</span> <span class="n">smTransition</span>  <span class="ow">=</span> <span class="n">transition</span> <span class="n">game</span>
    <span class="p">,</span> <span class="n">smFinal</span>       <span class="ow">=</span> <span class="n">final</span>
    <span class="p">,</span> <span class="n">smCheck</span>       <span class="ow">=</span> <span class="n">check</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span>
    <span class="p">,</span> <span class="n">smThreadToken</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">gToken</span> <span class="n">game</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Our old <em>mkGameValidator</em> can now be replaced by using machinery provided by the state machine. There is a <em>mkValidator</em> function which will take our
state machine, generated by the <em>gameStateMachine</em> function and turn it into a validator with exactly the same type as we had in the old code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkGameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkGameValidator</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="ow">=</span> <span class="n">mkValidator</span> <span class="o">$</span> <span class="n">gameStateMachine</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span>
</pre></div>
</div>
<p>In the old code we had this mechanism to bundle datum and redeemer into a <em>Gaming</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- old code</span>
<span class="kr">data</span> <span class="kt">Gaming</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Gaming</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameDatum</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>But now we can define this as.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">StateMachine</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>We also provide an alternate version of <em>gameStateMachine</em>, which doesn’t take the two auxiliary <em>ByteString</em>s. This won’t work for on-chain code, but for off-chain
code it works just fine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameStateMachine&#39;</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">StateMachine</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
<span class="nf">gameStateMachine&#39;</span> <span class="n">game</span> <span class="ow">=</span> <span class="n">gameStateMachine</span> <span class="n">game</span> <span class="n">bsZero</span> <span class="n">bsOne</span>
</pre></div>
</div>
<p>We have the same boilerplate as before for <em>gameInst</em>, <em>gameValidator</em> and <em>gameAddress</em>, which we won’t copy again here.</p>
<p>The function <em>gameClient</em> is new. It is a <em>StateMachineClient</em>, and this is what we need to interact with our state machine from our wallet in the <em>Contract</em> monad.</p>
<div class="figure align-default">
<img alt="_images/week07__00018.png" src="_images/week07__00018.png" />
</div>
<p>As you can see from the definition, it contains a <em>StateMachineInstance</em>. And the <em>StateMachineInstance</em> in turn is just a <em>StateMachine</em> and the corresponding script
instance.</p>
<div class="figure align-default">
<img alt="_images/week07__00020.png" src="_images/week07__00020.png" />
</div>
<p>Once we have that, the <em>StateMachineClient</em> still needs to be bundled with a so called <em>chooser</em>, which is the mechanism, from the off-chain code, for finding the UTxO that represents our
state machine. In general there will be a list of UTxOs at the address of the state machine, and <em>scChooser</em> is a function that specifies which to pick.</p>
<p>We don’t have to worry about that, because we are using the NFT approach, which means that the choosing is taken care of for us automatically.</p>
<p>There is a function <em>mkStateMachineClient</em> that takes a <em>StateMachineInstance</em> and returns a <em>StateMachineClient</em>, and this uses the default implementation of the chooser.
And this will do the right thing and pick the UTxO that contains our NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameClient</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">StateMachineClient</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
<span class="nf">gameClient</span> <span class="n">game</span> <span class="ow">=</span> <span class="n">mkStateMachineClient</span> <span class="o">$</span> <span class="kt">StateMachineInstance</span> <span class="p">(</span><span class="n">gameStateMachine&#39;</span> <span class="n">game</span><span class="p">)</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, <em>gameClient</em> can be used to interact with the state machine from off-chain code.</p>
<p><em>FirstParams</em> is exactly the same, so we won’t repeat it here.</p>
<p>There is one small nuisance. The state machine contracts provided by the state machine module have a specific constraint on the error type. One error type that works
is <em>SMContractError</em>.</p>
<p>But we want to do what we did in the last lectures and always use <em>Text</em> as the error type. To achieve this we will use a helper function to convert the <em>SMContractError</em>
type into a <em>Text</em> type. Recall that <em>show</em> will return a <em>String</em> and <em>pack</em> will convert a <em>String</em> into a <em>Text</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapError&#39;</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">SMContractError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapError&#39;</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>
</pre></div>
</div>
<p>So now the first player contract becomes much shorter and more compact.</p>
<p>The beginning is the same.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">firstGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">FirstParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">firstGame</span> <span class="n">fp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">game</span>   <span class="ow">=</span> <span class="kt">Game</span>
            <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">fpSecond</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">fpStake</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">fpCurrency</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fpTokenName</span> <span class="n">fp</span><span class="p">)</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>Now, we take the client along with some values that we get as before.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">client</span> <span class="ow">=</span> <span class="n">gameClient</span> <span class="n">game</span>
<span class="nf">v</span>      <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">fpStake</span> <span class="n">fp</span><span class="p">)</span>
<span class="nf">c</span>      <span class="ow">=</span> <span class="n">fpChoice</span> <span class="n">fp</span>
<span class="nf">bs</span>     <span class="ow">=</span> <span class="n">sha2_256</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="kr">then</span> <span class="n">bsZero</span> <span class="kr">else</span> <span class="n">bsOne</span>
</pre></div>
</div>
<p>There is a function <em>runIntialise</em> that starts a state machine and creates a UTxO at the state machine address. It takes the client as its first argument and then
it needs the initial datum and the initial value for the UTxO sitting at that address. And it will automatically put the NFT there as well.</p>
<div class="highlight-Haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runInitialise</span> <span class="n">client</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">v</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">fpChoice</span> <span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, the state machine is setup and the first player has made their move.</p>
<p>We wait until the play deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
</pre></div>
</div>
<p>In our first example, we defined a helper function <em>findGameOutput</em> to get the current <em>UTxO</em>, but this can now be done in a simpler way using <em>getOnChainState</em>.</p>
<div class="figure align-default">
<img alt="_images/week07__00021.png" src="_images/week07__00021.png" />
</div>
<p>The function <em>getOnChainState</em> will return a <em>Just OnChainState</em> if it finds the state machine, or a <em>Nothing</em> if it does not find it.</p>
<div class="figure align-default">
<img alt="_images/week07__00022.png" src="_images/week07__00022.png" />
</div>
<p>So what is <em>OnChainState</em>? It is a tuple consisting of <em>TypedScriptTxOut</em> and <em>TypedScriptTxOutRef</em>. This is similar to what <em>utxoAt</em> gives us, which was a map of
<em>TxOutRefs</em>s to <em>TxOuts</em>s. This is similar in that it is a output and its reference, but it is this <em>Typed</em> version that we haven’t seen before.</p>
<p>All that does is bundle what we know from before, <em>TxOut</em>, but additionally it provides the datum. You’ll recall that in our off-chain code we always have to scramble
and write helper functions to access the datum once we had found the UTxO. We had to look up the datum hash, which could fail, and so on. <em>TypedScriptTxOut</em> hides all
this from us.</p>
<div class="figure align-default">
<img alt="_images/week07__00023.png" src="_images/week07__00023.png" />
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">getOnChainState</span> <span class="n">client</span>
</pre></div>
</div>
<p>As before, we should never get <em>Nothing</em> for <em>m</em>.</p>
<blockquote>
<div><dl class="simple">
<dt>case m of</dt><dd><p>Nothing             -&gt; throwError “game output not found”</p>
</dd>
</dl>
</div></blockquote>
<p>Now, we are only interested in the <em>TypedScriptTxOut</em> parameter, which we assign to <em>o</em>, and use it to lookup the datum using <em>tyTxOutData</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">),</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">tyTxOutData</span> <span class="n">o</span> <span class="kr">of</span>
</pre></div>
</div>
<p>As before we have the two cases. Either the second player has moved, or they haven’t moved.</p>
<p>If they haven’t moved, we must reclaim. Earlier we had lots of code to setup the lookups and constraints that we needed. How we only need one line, and the important
function here is <em>runStep</em>, which creates and submits a transaction that will transition the state machine.</p>
<p>It takes as input the client and the redeemer. It then returns a <em>TransitionResult</em>, which we are not using in this example, but basically encodes whether it succeeded
or failed.</p>
<div class="figure align-default">
<img alt="_images/week07__00024.png" src="_images/week07__00024.png" />
</div>
<p>Which means, that we can use <em>runStep</em> with just the client and redeemer to replace all the lookups, the constraints, the transaction submissions and the waiting.</p>
<p>The way it works it that the <em>transition</em> function is that all the necessary constraints have been defined as part of the state machine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player did not play&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="kt">ClaimFirst</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player reclaimed stake&quot;</span>
</pre></div>
</div>
<p>The second case is that the first player did reveal, and we again use the <em>runStep</em> function to transition the state machine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">c&#39;</span> <span class="o">==</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and lost&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="o">$</span> <span class="kt">Reveal</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player revealed and won&quot;</span>
</pre></div>
</div>
<p>And in all other situations, the second player wins.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and won&quot;</span>
</pre></div>
</div>
<p>The second player’s contract is very similar, and just as simple.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">secondGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">SecondParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">secondGame</span> <span class="n">sp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">game</span>   <span class="ow">=</span> <span class="kt">Game</span>
            <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">spFirst</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">spStake</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">spCurrency</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spTokenName</span> <span class="n">sp</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="n">client</span> <span class="ow">=</span> <span class="n">gameClient</span> <span class="n">game</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">getOnChainState</span> <span class="n">client</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>          <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no running game found&quot;</span>
        <span class="kt">Just</span> <span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">),</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">tyTxOutData</span> <span class="n">o</span> <span class="kr">of</span>
</pre></div>
</div>
<p>The only case we need to address is where we haven’t played yet, and so should play. And, in order to play, we again use the <em>runStep</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;running game found&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="o">$</span> <span class="kt">Play</span> <span class="o">$</span> <span class="n">spChoice</span> <span class="n">sp</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">spChoice</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>We then wait until the reveal deadline has passed, then get the new state.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
<span class="nf">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">getOnChainState</span> <span class="n">client</span>
<span class="kr">case</span> <span class="n">m&#39;</span> <span class="kr">of</span>
</pre></div>
</div>
<p>If there is no state, the first player has won and claimed their winnings.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player won&quot;</span>
</pre></div>
</div>
<p>Otherwise, we have won, and we claim our winnings using the <em>runStep</em> function, giving the <em>ClaimSecond</em> redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="kr">_</span>  <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="kt">ClaimSecond</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player won&quot;</span>
</pre></div>
</div>
<p>And a final catch all.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="s">&quot;unexpected datum&quot;</span>
</pre></div>
</div>
<p>That concludes the state machine version of the code.</p>
<p>What is particularly nice about this approach is that we don’t need to replicate logic anymore. We have discussed how off-chain code is used for construction and
on-chain code is used for checking. When we use the state machine approach, we define logic that can be used for both, so we do not need to write it explicitly for the
off-chain part and the on-chain part of the code.</p>
<p>In order to test this, there is a module called <em>Week07.TestStateMachine</em> in the example code. It is exactly the same as the test for the old code, with one exception,
and that is just that instead of importing <em>Week07.EvenOdd</em>, it imports <em>Week07.StateMachine</em>. This is a quick and dirty way of doing things - we could, of course,
have written a script that was parameterized over the contract we want to use.</p>
<p>If you load <em>Week07.TestStateMachine</em> in the REPL and run <em>test</em>, you should get exactly the same results as before.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>State machines are not always appropriate, but when they are, you should definitely use them. They dramatically reduce the amount of code you have to write, and also
reduce sources of errors.</p>
<p>The state machine mechanism automatically ensures that you have on-chain and off-chain code that are working correctly together. Until now, we have always had to take care of that ourselves.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
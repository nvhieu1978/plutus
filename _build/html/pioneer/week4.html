

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1.4. Week 04 - Monads &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1.5. Week 05 - Native Tokens" href="week5.html" />
    <link rel="prev" title="1.3. Week 03 - Script Context" href="week3.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../plutus_pioneer_program.html">1. Plutus Pioneer Program</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="week1.html">1.1. Week 01 - English Auction</a></li>
<li class="toctree-l2"><a class="reference internal" href="week2.html">1.2. Week 02 - Validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="week3.html">1.3. Week 03 - Script Context</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">1.4. Week 04 - Monads</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">1.4.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monads">1.4.2. Monads</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hello-world">1.4.2.1. Hello World</a></li>
<li class="toctree-l4"><a class="reference internal" href="#getline">1.4.2.2. getLine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maybe">1.4.2.3. Maybe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#either">1.4.2.4. Either</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writer">1.4.2.5. Writer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-is-a-monad">1.4.2.6. What is a Monad?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-is-this-useful">1.4.2.7. Why Is This useful?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#do-notation">1.4.2.8. ‘do’ notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#plutus-monads">1.4.3. Plutus Monads</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-emulatortrace-monad">1.4.3.1. The EmulatorTrace Monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-contract-monad">1.4.3.2. The Contract Monad</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week5.html">1.5. Week 05 - Native Tokens</a></li>
<li class="toctree-l2"><a class="reference internal" href="week6.html">1.6. Week 06 - Oracles</a></li>
<li class="toctree-l2"><a class="reference internal" href="week7.html">1.7. Week 07 - State Machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="week8.html">1.8. Week 08 - Property Based Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="week9.html">1.9. Week 09 - Marlowe</a></li>
<li class="toctree-l2"><a class="reference internal" href="week10.html">1.10. Week 10 - Uniswap</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../alonzo_white.html">2. Alonzo Walkthrough</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../plutus_pioneer_program.html"><span class="section-number">1. </span>Plutus Pioneer Program</a> &raquo;</li>
        
      <li><span class="section-number">1.4. </span>Week 04 - Monads</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/pioneer/week4.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-04-monads">
<h1><span class="section-number">1.4. </span>Week 04 - Monads<a class="headerlink" href="#week-04-monads" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://youtu.be/6Reuh0xZDjY">Lecture
#4</a>.</p>
<p>In this lecture we learn about Monads. In particular the EmulatorTrace
and Contract monads.</p>
</div>
<div class="section" id="overview">
<h2><span class="section-number">1.4.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>We have spent the last two lectures talking about the on-chain part of
Plutus - the validation logic that is compiled to Plutus script and
actually lives on the blockchain and is executed by nodes that validate
a transaction.</p>
<p>There is a lot more to say about that on-chain part.</p>
<p>We haven’t looked at more complex examples of validation yet that make
more sophisticated use of the context, and we haven’t see how native
tokens work, yet (Plutus script is also used to validate the minting and
burning of native tokens).</p>
<p>We will definitely have to talk about those topics, and come back to
that.</p>
<p>However, before we go into too many sophisticated topics of on-chain
validation, we mustn’t neglect the off-chain part, because it is equally
important.</p>
<p>The on-chain part takes care of validation but, in order for there to be
something to be validated, we must build a transaction and submit it to
the blockchain. And, that is what the off-chain part does.</p>
<p>So, we will start talking about how to write off-chain Plutus code.</p>
<p>Unfortunately there is a slight problem concerning the Haskell features
needed.</p>
<p>The on-chain part that we have seen so far is somewhat alien and takes a
little getting used to, due to the fact that we have the additional
complication of the compilation to Plutus script. But, we don’t really
have to worry about that if we use the Template Haskell magic. In that
case the validator function is just a plain function.</p>
<p>And it is actually a very simple Haskell function from the technical
point of view. We don’t use any fancy Haskell features to write this
function.</p>
<p>One of the reasons for that is the way Plutus compilation works. We have
seen how, in order for the compilation to Plutus to succeed, all the
code used by the validation function must be available within the Oxford
Brackets. This means that all the functions relied on by the
<em>mkValidator</em> function must use the INLINABLE pragma.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>And recall, that because the standard Haskell functions don’t have this
INLINABLE pragma, there is a new Plutus Prelude module that is similar
to the standard Haskell Prelude, but with the functions defined with the
INLINABLE pragma.</p>
<p>But, of course, there are hundreds of Haskell libraries out there and
most of them weren’t written with Plutus in mind, so we can’t use them
inside validation. And, that has the effect that the Haskell inside
validation will be relatively simple and won’t have many dependencies.</p>
</div>
<div class="section" id="monads">
<h2><span class="section-number">1.4.2. </span>Monads<a class="headerlink" href="#monads" title="Permalink to this headline">¶</a></h2>
<p>In the off-chain part of Plutus, the situation is reversed. We don’t
have to worry about compilation to Plutus script - it is just plain
Haskell. But, the flip side is that, the way this is implemented, it
uses much more sophisticated Haskell features - e.g. so-called effect
systems, streaming and, in particular, monads.</p>
<p>All the off-chain code (the wallet code), is written in a special monad
- the Contract Monad.</p>
<p>Monads are infamous in the Haskell world. It is normally the first
stumbling block for beginning Haskell coders.</p>
<p>There are a lot of tutorials out there that try to explain Monads.
Monads get compared to burritos, and all sorts of metaphors are employed
to try to explain the concept. But here, let’s at least try to give a
crash course in monads for those who are new to Haskell.</p>
<p>Before we get to general monads, we will start with <em>IO</em>, which is how
IO side-effects are handled in Haskell. But, before we get to Haskell,
let’s look at a mainstream language like Java.</p>
<p>Let’s look at the following Java method.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This function takes no arguments, and it returns an <code class="docutils literal notranslate"><span class="pre">int</span></code>. Let’s imagine it gets called twice in the code.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="o">();</span>
<span class="o">...</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">foo</span><span class="o">();</span>
</pre></div>
</div>
<p>Now, we note that, so long as we don’t know what is going on inside the
foo() function, the return value of the following expression is unknown.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// true or false? at compile time, we don&#39;t know</span>
</pre></div>
</div>
<p>We do not know if <code class="docutils literal notranslate"><span class="pre">a</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">b</span></code> because, in Java, it is
perfectly possible that some IO happens inside <code class="docutils literal notranslate"><span class="pre">foo</span></code>. For example,
there code be code that asks the user to enter input on the console and
uses this to compute the return value.</p>
<p>This means that, in order to reason about the code, we need to look
inside <code class="docutils literal notranslate"><span class="pre">foo</span></code>, which makes testing, for example, more difficult. And it
means that, it the first call to <code class="docutils literal notranslate"><span class="pre">foo</span></code> returns, for example, <code class="docutils literal notranslate"><span class="pre">13</span></code> - we
cannot just replace all other calls to <code class="docutils literal notranslate"><span class="pre">foo</span></code> with the known return
value of <code class="docutils literal notranslate"><span class="pre">13</span></code>.</p>
<p>In Haskell the situation is very different because Haskell is a pure
functional language. The equivalent signature in Haskell would be
something like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Now, if we have a situation where we call <code class="docutils literal notranslate"><span class="pre">foo</span></code> twice, even though we
don’t know what the value of <code class="docutils literal notranslate"><span class="pre">foo</span></code> is, we know for sure that the two
return values will be the same.</p>
<p>This is a very important feature that is called <em>referential
transparency</em>. There are, in fact, some escape hatches to get around
this, but we can ignore this.</p>
<p>This makes tasks such as refactoring and testing much easier.</p>
<p>This is all very well, but you need side-effects in order to have an
effect on the world. Otherwise, all your program does is heat up the
processor.</p>
<p>You need input and output. You must be able to write output to the
screen, or read input from the keyboard, or a network connection, or a
file, for example.</p>
<p>There is a famous <a class="reference external" href="https://www.youtube.com/watch?v=iSmkqocn0oQ">video by Simon Peyton-Jones called Haskell Is
Useless</a> which explains
that it is beautiful mathematically to have a pure, side effect-free
language, but in the end you do need side effects to make anything
happen.</p>
<p>And Haskell does have a way to handle side effects and that is the IO
Monad. But, don’t worry about the monad part just yet.</p>
<p>Here is how we do it in Haskell.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p><em>IO</em> is a type constructor that takes one argument, like some other
examples of type constructors such as <em>Maybe</em> and <em>List</em>. However,
unlike those examples, <em>IO</em> is special, in the sense that you can’t
implement it in the language itself. It is a built-in primitive.</p>
<p>The return value <em>IO Int</em> tells us that this is a recipe to compute an
<em>Int</em>, and this recipe can cause side effects. A list of instructions
telling the computer what to do in order to end up with an <em>Int</em>.</p>
<p>It is important to notice that referential transparency is not broken
here. The result of the evaluation of <em>foo</em> is the recipe itself, not
the <em>Int</em> value. And as the recipe is always the same, referential
transparency is maintained.</p>
<p>The only way to actually execute such a recipe in a Haskell program is
from the main entry point of the program - the <em>main</em> function. You can
also execute <em>IO</em> actions in the REPL.</p>
<div class="section" id="hello-world">
<h3><span class="section-number">1.4.2.1. </span>Hello World<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h3>
<p>Hello World in Haskell looks like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
</pre></div>
</div>
<p>Here, <em>main</em> is a recipe that performs some side effects and returns
Unit - nothing of interest.</p>
<p>Let’s look at <em>putStrLn</em> in the REPL. We see that it is an IO action
that takes a <em>String</em> and returns no interesting result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">putStrLn</span>
<span class="nf">putStrLn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>

<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="nf">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>We can also run this. Open up the app/Main.sh file and edit the <em>main</em>
function so it reads:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
</pre></div>
</div>
<p>Then run</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cabal run hello
</pre></div>
</div>
<p>We will take a quick look at the cabal file now.</p>
<p>In previous lectures we only needed the <em>library</em> section in the
<em>plutus-pioneer-program-week04.cabal</em> file as we were dealing only with
library functions. Now, we need to add an <em>executable</em> stanza.</p>
<div class="highlight-cabal notranslate"><div class="highlight"><pre><span></span>executable hello
hs-source-dirs:      app
main-is:             hello.hs
build-depends:       base ^&gt;=4.14.1.0
default-language:    Haskell2010
ghc-options:         -Wall -O2
</pre></div>
</div>
<p>This specifies the source directory and which file holds the main
function. Normally the file name must match the module name, but the
<em>main</em> is an exception.</p>
<p>Rather than just asking for the type of <em>putStrLn</em>, we can run it in the
REPL. As mentioned, the REPL allows us to execute IO actions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="kt">Hello</span><span class="p">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div>
</div>
</div>
<div class="section" id="getline">
<h3><span class="section-number">1.4.2.2. </span>getLine<a class="headerlink" href="#getline" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at <em>getLine</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">getLine</span>
<span class="nf">getLine</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
</pre></div>
</div>
<p>This shows that it is a recipe, possibly producing side-effects, that,
when executed will produce a <em>String</em>. In the case of <em>getLine</em>, the
side-effect in question is that it will wait for user input from the
keyboard.</p>
<p>If we execute <em>getLine</em> in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">getLine</span>
</pre></div>
</div>
<p>It waits for keyboard input. Then, if we enter something, it returns the
result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Haskell</span>
<span class="s">&quot;Haskell&quot;</span>
</pre></div>
</div>
<p>There are a variety of IO actions defined in Haskell to do all sorts of
things like reading files, writing files, reading from and writing to
sockets.</p>
<p>But no matter how many predefined actions you have, that will never be
enough to achieve something complex, so there must be a way to combine
these primitive, provided IO actions into bigger, more complex recipes.</p>
<p>One thing we can do is make use of the <em>Functor</em> type instance of IO.
Let’s look at the type instances of <em>IO</em> in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">IO</span>
<span class="kr">type</span> <span class="kt">IO</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">newtype</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="ow">=</span> <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Types</span><span class="o">.</span><span class="kt">IO</span> <span class="p">(</span><span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">State</span><span class="o">#</span>
                                 <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">RealWorld</span>
                                 <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">#</span> <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">State</span><span class="o">#</span>
                                       <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">RealWorld</span><span class="p">,</span>
                                       <span class="n">a</span> <span class="o">#</span><span class="p">))</span>
   <span class="c1">-- Defined in ‘ghc-prim-0.6.1:GHC.Types’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">MonadFail</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘Control.Monad.Fail’</span>
</pre></div>
</div>
<p>We see the dreaded <em>Monad</em> instance, but we also see a <em>Functor</em>
instance. <em>Functor</em> is a very important type class in Haskell. If we
look at it in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Functor</span>
<span class="kr">type</span> <span class="kt">Functor</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
<span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL fmap #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>The important method here is <em>fmap</em>. The second function <em>(&lt;$)</em> is a
convenience function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>This function, <em>fmap</em>, that all <em>Functor</em>s have tells us that, if we
give it has access to a function that can turn an <em>a</em> into a <em>b</em>, then
it can turn an <em>f a</em> into an <em>f b</em> for us. Here, we are interested in
the case where <em>f</em> is <em>IO</em>.</p>
<p>If we specialized the function for <em>IO</em>, we would have a function like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fmap&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span>
</pre></div>
</div>
<p>How does that work. Well, <em>IO a</em> is a recipe that has side effects and
produces an <em>a</em>. So, how do we get a <em>b</em> out of that? We perform the
recipe, but, before return the <em>a</em>, we apply the <em>(a -&gt; b)</em> function to
to <em>a</em> and return the result, which is the <em>b</em>.</p>
<p>In the REPL, let’s look at the <em>toUpper</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Char</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">toUpper</span>
<span class="nf">toUpper</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Char</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">toUpper</span> <span class="sc">&#39;q&#39;</span>
<span class="sc">&#39;Q&#39;</span>
</pre></div>
</div>
<p>If we want to apply that to a <em>String</em> rather than a <em>Char</em> we can use
the <em>map</em> function. <em>String</em>s in Haskell are just lists of <em>Char</em>s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="s">&quot;Haskell&quot;</span>
<span class="s">&quot;HASKELL&quot;</span>
</pre></div>
</div>
<p>The <em>map toUpper</em> function is a function from <em>String</em> to <em>String</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">map</span> <span class="n">toUpper</span>
<span class="nf">map</span> <span class="n">toUpper</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>And we can use this in combination with <em>fmap</em>. If we use <em>map toUpper</em>
as our function to convert an <em>a</em> to a <em>b</em>, we can see what the type of
output of <em>fmap</em> would be when applied to an <em>IO a</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s see it in action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span>
<span class="nf">haskell</span>
<span class="s">&quot;HASKELL&quot;</span>
</pre></div>
</div>
<p>We can also use the <em>&gt;&gt;</em> operator. This chains two <em>IO</em> actions
together, ignoring the result of the first. In the following example,
both actions will be performed in sequence.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello&quot;</span> <span class="o">&gt;&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;World&quot;</span>
<span class="kt">Hello</span>
<span class="kt">World</span>
</pre></div>
</div>
<p>Here, there is no result from <em>putStrLn</em>, but if there were, it would
have been ignored. Its side effects would have been performed, its
result ignored, then the second <em>putStrLn</em> side effects would been
performed before returning the result of the second call.</p>
<p>Then, there is an important operator that does not ignore the result of
the first <em>IO</em> action, and that is called <em>bind</em>. It is written as the
<em>&gt;&gt;=</em> symbol.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>We see the <em>Monad</em> constraint, but we can ignore that for now and just
think of <em>IO</em>.</p>
<p>What this says is that if I have a recipe that performs side effects
then gives me a result <em>a</em>, and given that I have a function that takes
an <em>a</em> and gives me back a recipe that returns a <em>b</em>, then I can combine
the recipe <em>m a</em> with the recipe <em>m b</em> by taking the value <em>a</em> and using
it in the recipe that results in the value <em>b</em>.</p>
<p>An example will make this clear.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">getLine</span> <span class="o">&gt;&gt;=</span> <span class="n">putStrLn</span>
<span class="kt">Haskell</span>
<span class="kt">Haskell</span>
</pre></div>
</div>
<p>Here, the function <em>getLine</em> is of type <em>IO String</em>. The return value
<em>a</em> is passed to the function <em>(a -&gt; m b)</em> which then generates a recipe
<em>putStrLn</em> with an input value of <em>a</em> and an output of type <em>IO ()</em>.
Then, <em>putStrLn</em> performs its side effects and returns <em>Unit</em>.</p>
<p>There is another, very important, way to create <em>IO</em> actions, and that
is to create recipes that immediately return results without performing
any side effects.</p>
<p>That is done with a function called <em>return</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">return</span>
<span class="nf">return</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>Again, it is general for any Monad, we only need to think about <em>IO</em>
right now.</p>
<p>It takes a value <em>a</em> and returns a recipe that produces the value <em>a</em>.
In the case of <em>return</em>, the recipe does not actually create any side
effects.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="s">&quot;Haskell&quot;</span>
</pre></div>
</div>
<p>We needed to specify the return type so that the REPL knows which Monad
we are using:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>

<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">return</span> <span class="s">&quot;Haskell&quot;</span>
<span class="nf">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>If we now go back to our <em>main</em> program, we can now write relatively
complex <em>IO</em> actions. For example, we can define an <em>IO</em> action that
will ask for two strings and print result of concatenating those two
strings to the console.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">bar</span>

<span class="nf">bar</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">bar</span> <span class="ow">=</span> <span class="n">getLine</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span>
      <span class="n">getLine</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">t</span> <span class="ow">-&gt;</span>
      <span class="n">putStrLn</span> <span class="p">(</span><span class="n">s</span> <span class="o">++</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>And then, when we run it, the program will wait for two inputs and then
output the concatenated result.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cabal run hello
one
two
onetwo
</pre></div>
</div>
<p>This is enough now for our purposes, although we won’t need the <em>IO</em>
Monad until perhaps later in the course when we talk about actually
deploying Plutus contracts. However, the <em>IO</em> Monad is an important
example, and a good one to start with.</p>
<p>So, for now, let’s completely forget about <em>IO</em> and just write pure,
functional Haskell, using the <em>Maybe</em> type.</p>
</div>
<div class="section" id="maybe">
<h3><span class="section-number">1.4.2.3. </span>Maybe<a class="headerlink" href="#maybe" title="Permalink to this headline">¶</a></h3>
<p>The <em>Maybe</em> type is one of the most useful types in Haskell.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Maybe</span>
<span class="kr">type</span> <span class="kt">Maybe</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
   <span class="c1">-- Defined in ‘GHC.Maybe’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Maybe’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Ord</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Maybe’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Show’</span>
<span class="kr">instance</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Read</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Read’</span>
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘Data.Foldable’</span>
<span class="kr">instance</span> <span class="kt">Traversable</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘Data.Traversable’</span>
<span class="kr">instance</span> <span class="kt">MonadFail</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘Control.Monad.Fail’</span>
</pre></div>
</div>
<p>It is often called something like <em>Optional</em> in other programming
languages.</p>
<p>It has two constructors - <em>Nothing</em>, which takes no arguments, and
<em>Just</em>, which takes one argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div>
</div>
<p>Let’s look at an example.</p>
<p>In Haskell, if you want to pass a <em>String</em> to a value that has a <em>read</em>
instance, you will normally do this with the <em>read</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">42</span>
</pre></div>
</div>
<p>But, <em>read</em> is a bit unpleasant, because if we have something that can’t
be parsed as an <em>Int</em>, then we get an error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;42+u&quot;</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">read</span><span class="kt">:</span> <span class="n">no</span> <span class="n">parse</span>
</pre></div>
</div>
<p>Let’s import <em>readMaybe</em> to do it in a better way.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Text.Read</span> <span class="p">(</span><span class="nf">readMaybe</span><span class="p">)</span>
<span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The function <em>readMaybe</em> does the same as <em>read</em>, but it returns a
<em>Maybe</em>, and in the case where it cannot parse, it will return a <em>Maybe</em>
created with the <em>Nothing</em> constructor.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">readMaybe</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="kt">Just</span> <span class="mi">42</span>

<span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">readMaybe</span> <span class="s">&quot;42+u&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>Let’s say we want to create a new function that returns a <em>Maybe</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="p">::</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">Int</span>
</pre></div>
</div>
<p>The idea is that the function should try to parse all three <em>String</em>s
as <em>Int</em>s. If all the <em>String</em>s can be successfully parsed as
<em>Int</em>s, then we want to add those three <em>Int</em>s to get a sum. If one
of the parses fails, we want to return <em>Nothing</em>.</p>
<p>One way to do that would be:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
   <span class="kt">Just</span> <span class="n">k</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">y</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
      <span class="kt">Just</span> <span class="n">l</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">z</span> <span class="kr">of</span>
            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
            <span class="kt">Just</span> <span class="n">m</span>  <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s see if it works. First, the case where is succeeds:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span>
<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;1&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Just</span> <span class="mi">6</span>
</pre></div>
</div>
<p>But, if one of the values can’t be parsed, we get <em>Nothing</em>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>The code is not ideal because we repeat the same pattern three times.
Each time we have to consider the two cases - whether the result of the
read is a <em>Just</em> or a <em>Nothing</em>.</p>
<p>Ask Haskellers, we hate repetition like this.</p>
<p>The thing we want to do is very simple. We want to pass the three
<em>String</em>s and add the result, but with all those cases it is very
noisy and very ugly. We want to abstract away this pattern.</p>
<p>One way to do that would be to define something like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindMaybe</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="nf">bindMaybe</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">bindMaybe</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>Let’s write the same function again using <em>bindMaybe</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">foo&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">readMaybe</span> <span class="n">x</span> <span class="p">`</span><span class="n">bindMaybe</span><span class="p">`</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
            <span class="n">readMaybe</span> <span class="n">y</span> <span class="p">`</span><span class="n">bindMaybe</span><span class="p">`</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
            <span class="n">readMaybe</span> <span class="n">z</span> <span class="p">`</span><span class="n">bindMaybe</span><span class="p">`</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>And then, in the REPL, we get the same results for <em>foo’</em> as we got for
<em>foo</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;1&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Just</span> <span class="mi">6</span>

<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>This does exactly the same as <em>foo</em>, but it is much more compact, there
is far less noise, and the business logic is much clearer.</p>
<p>It may, or may not, help to view the function with it not being used
with infix notation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">bindMaybe</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">42</span>
</pre></div>
</div>
<p>Here you can see the function clearly taking the <em>Maybe</em> and then the
function that takes the <em>a</em> from the <em>Maybe</em> and uses it as the input to
a function that returns a new <em>Maybe</em>.</p>
<p>This produces nothing useful, until we add the second <em>readMaybe</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">bindMaybe</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">bindMaybe</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="p">)))</span>
<span class="kt">Just</span> <span class="mi">47</span>
</pre></div>
</div>
<p>In some ways <em>Nothing</em> is a bit like an exception in other languages. If
any of the computations returns <em>Nothing</em>, the remainder of the
computations in the block are not performed and <em>Nothing</em> is returned.</p>
</div>
<div class="section" id="either">
<h3><span class="section-number">1.4.2.4. </span>Either<a class="headerlink" href="#either" title="Permalink to this headline">¶</a></h3>
<p>Another very useful type in Haskell is the <em>Either</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Either</span>
<span class="kr">type</span> <span class="kt">Either</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
   <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Ord</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Read</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Read</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Foldable’</span>
<span class="kr">instance</span> <span class="kt">Traversable</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Traversable’</span>
</pre></div>
</div>
<p><em>Either</em> takes two parameters, <em>a</em> and <em>b</em>. Like <em>Maybe</em> it has two
constructors, but unlike <em>Maybe</em> both take a value. It can <em>Either</em> be
an <em>a</em> or a <em>b</em>. The two constructors are <em>Left</em> and <em>Right</em>.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">Left</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Left</span> <span class="s">&quot;Haskell&quot;</span>
</pre></div>
</div>
<p>Or</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">Right</span> <span class="mi">7</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Right</span> <span class="mi">7</span>
</pre></div>
</div>
<p>If we take the exception analogy a little further, then one issue with
<em>Maybe</em> is that if we return <em>Nothing</em>, there is no error message. But,
if we want something that gives a message, we can replace <em>Maybe</em> with
an <em>Either</em> type.</p>
<p>In that case, <em>Right</em> can correspond to <em>Just</em> and <em>Left</em> can correspond
to an error, as <em>Nothing</em> did. But, depending on what type we choose for
<em>a</em>, we can give appropriate error messages.</p>
<p>Let’s define something called <em>readEither</em> and see what it does when it
can and when it cannot parse its input.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readEither</span> <span class="ow">::</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span>
<span class="nf">readEither</span> <span class="n">s</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">s</span> <span class="kr">of</span>
   <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;can&#39;t parse: &quot;</span> <span class="o">++</span> <span class="n">s</span>
   <span class="kt">Just</span> <span class="n">a</span>  <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="n">a</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">readEither</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Right</span> <span class="mi">42</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">readEither</span> <span class="s">&quot;42+u&quot;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Left</span> <span class="s">&quot;can&#39;t parse: 42+u&quot;</span>
</pre></div>
</div>
<p>Using this, we can now rewrite <em>foo</em> in terms of <em>Either</em>. First, using
the long-winded method:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">readEither</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
   <span class="kt">Right</span> <span class="n">k</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readEither</span> <span class="n">y</span> <span class="kr">of</span>
      <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
      <span class="kt">Right</span> <span class="n">l</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readEither</span> <span class="n">z</span> <span class="kr">of</span>
            <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
            <span class="kt">Right</span> <span class="n">m</span>  <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s try it. First, the happy path:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;1&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Right</span> <span class="mi">6</span>
</pre></div>
</div>
<p>Then, when we have a problem:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;ays&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Left</span> <span class="s">&quot;can&#39;t parse: ays&quot;</span>
</pre></div>
</div>
<p>But, we have the same problem that we had with <em>Maybe</em>; we have a lot of
repetition.</p>
<p>The solution is similar.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindEither</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span>
<span class="nf">bindEither</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">err</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">err</span>
<span class="nf">bindEither</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span>  <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="nf">foo&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">readEither</span> <span class="n">x</span> <span class="p">`</span><span class="n">bindEither</span><span class="p">`</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
            <span class="n">readEither</span> <span class="n">y</span> <span class="p">`</span><span class="n">bindEither</span><span class="p">`</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
            <span class="n">readEither</span> <span class="n">z</span> <span class="p">`</span><span class="n">bindEither</span><span class="p">`</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
            <span class="kt">Right</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>You can run this again in the REPL and it will behave in the same way as
its long-winded version.</p>
</div>
<div class="section" id="writer">
<h3><span class="section-number">1.4.2.5. </span>Writer<a class="headerlink" href="#writer" title="Permalink to this headline">¶</a></h3>
<p>So far we have looked at three examples: <em>IO a</em>, <em>Maybe a</em> and <em>Either
String a</em>. <em>IO a</em> represents plans that can involve side effects and,
when executed, produce an <em>a</em>. <em>Maybe a</em> and <em>Either String a</em> represent
computations that can produce an <em>a</em> but can also fail. The difference
between <em>Maybe</em> and <em>Either</em> is just that <em>Maybe</em> does not produce any
error message, but <em>Either</em> does.</p>
<p>Now let’s look at a completely different example that captures the idea
of computations that can also produce log output.</p>
<p>We can represent that with a type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
   <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>As an example, let’s write a function that returns a <em>Writer</em> for an
<em>Int</em> and writes a log message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">number</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">number</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="n">n</span> <span class="o">$</span> <span class="p">[</span><span class="s">&quot;number: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">number</span> <span class="mi">42</span>
<span class="kt">Writer</span> <span class="mi">42</span> <span class="p">[</span><span class="s">&quot;number: 42&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, let’s do something similar to that which we have done with <em>Maybe</em>
and <em>Either</em>.</p>
<p>Let’s write a function that takes three logging computations that each
produce an <em>Int</em> and we want to return a single computation that
produces the sum of those <em>Int</em>s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">k</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">l</span> <span class="n">ys</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">m</span> <span class="n">zs</span><span class="p">)</span> <span class="ow">=</span>
<span class="kt">Writer</span> <span class="p">(</span><span class="kt">K</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span>
</pre></div>
</div>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="p">(</span><span class="n">number</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Writer</span> <span class="mi">6</span> <span class="p">[</span><span class="s">&quot;number: 1&quot;</span><span class="p">,</span><span class="s">&quot;number: 2&quot;</span><span class="p">,</span><span class="s">&quot;number: 3&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, let’s write another useful function that takes a list of message
and producers a <em>Writer</em> with no useful result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tell</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="nb">()</span>
<span class="nf">tell</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Now, we can update <em>foo</em> to add an extra log message showing the sum of
the numbers.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">k</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">l</span> <span class="n">ys</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">m</span> <span class="n">zs</span><span class="p">)</span> <span class="ow">=</span>
<span class="kr">let</span>
   <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span>
   <span class="kt">Writer</span> <span class="kr">_</span> <span class="n">us</span> <span class="ow">=</span> <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;sum: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span><span class="p">]</span>
<span class="kr">in</span>
   <span class="kt">Writer</span> <span class="n">s</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span> <span class="o">++</span> <span class="n">us</span>
</pre></div>
</div>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="p">(</span><span class="n">number</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Writer</span> <span class="mi">6</span> <span class="p">[</span><span class="s">&quot;number: 1&quot;</span><span class="p">,</span><span class="s">&quot;number: 2&quot;</span><span class="p">,</span><span class="s">&quot;number: 3&quot;</span><span class="p">,</span><span class="s">&quot;sum: 6&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>As before, we can write a bind function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindWriter</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span>
<span class="nf">bindWriter</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">a</span> <span class="n">xs</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span>
<span class="kr">let</span>
   <span class="kt">Writer</span> <span class="n">b</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
<span class="kr">in</span>
   <span class="kt">Writer</span> <span class="n">b</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span>
</pre></div>
</div>
<p>Here, the <em>bindWriter</em> function is returning the <em>Writer b</em> and
producing log messages which are a concatenation of the <em>xs</em> that we
pattern matched on input, and the <em>ys</em> that we pattern matched when
calling <em>f a</em> in order to produce the <em>Writer b</em>.</p>
<p>Now, we can rewrite <em>foo</em> using <em>bindWriter</em> and make it much nicer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
            <span class="n">y</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
            <span class="n">z</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
            <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span>
            <span class="kr">in</span> <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;sum: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span><span class="p">]</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span>
               <span class="kt">Writer</span> <span class="n">s</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>What we did with <em>foo</em> before, we can now do with <em>foo’</em>, and we get the
same result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">foo&#39;</span> <span class="p">(</span><span class="n">number</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Writer</span> <span class="mi">6</span> <span class="p">[</span><span class="s">&quot;number: 1&quot;</span><span class="p">,</span><span class="s">&quot;number: 2&quot;</span><span class="p">,</span><span class="s">&quot;number: 3&quot;</span><span class="p">,</span><span class="s">&quot;sum: 6&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Admittedly, it is longer than it was before, but it is much nicer. We no
longer need to do the pattern matching to extract the messages. We don’t
have to explicitly combine the log messages, where we could make a
mistake and forget one, or get the order wrong. Instead, we abstract all
that away and can just concentrate on the business logic.</p>
<p>Although the pattern is the same as with <em>Maybe</em> and <em>Either</em>, note that
the special aspect of these computations is completely different. With
<em>Maybe</em> and <em>Either</em> we dealt with the notion of failure, whereas here,
with the <em>Writer</em>, there is no failure, but we instead have additional
output.</p>
</div>
<div class="section" id="what-is-a-monad">
<h3><span class="section-number">1.4.2.6. </span>What is a Monad?<a class="headerlink" href="#what-is-a-monad" title="Permalink to this headline">¶</a></h3>
<p>Now, we are in a position to explain what a Monad is.</p>
<p>Looking back at the four examples, what did they have in common? In all
four cases, We had a type constructor with one type parameter - <em>IO</em>,
<em>Maybe</em>, <em>Either String</em> and <em>Writer</em> all take a type parameter.</p>
<p>And, for all four of these examples, we had a bind function. For <em>IO</em>,
we had the <em>&gt;&gt;=</em> function and for the others we had the bind functions
that we wrote ourselves.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindWriter</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span>
<span class="nf">bindEither</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span>
<span class="nf">bindMaybe</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</pre></div>
</div>
<p>How the bind works depends on the case. In the case of <em>IO</em> it is
built-in magic, but you can think of it as just combining the two plans
describing the actions to take during computation. For <em>bindMaybe</em> and
<em>bindEither</em> the logic is for the whole plan to fail if any part of it
fails, and for <em>bindWriter</em>, the logic was to combine the list of log
messages.</p>
<p>And that is the main idea of Monads. It’s a concept of computation with
some additional side effects, and the ability to bind two such
computations together.</p>
<p>There is another aspect that we briefly mentioned in the case of <em>IO</em>
but not for the other examples - another thing that we can always do.</p>
<p>Whenever we have such a concept of computation with side effects, we
also also always have the ability to produce a computation of this kind
that <em>doesn’t</em> have any side effects.</p>
<p>In the example of <em>IO</em>, this was done with <em>return</em>. Given an <em>a</em>, you
can create an <em>IO a</em> which is the recipe that always simply returns the
<em>a</em> with no side effects. Each of the other example has this ability as
well, as shown below.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span>              <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="kt">Just</span>                <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="kt">Right</span>               <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span>
<span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">a</span>
</pre></div>
</div>
<p>And it is the combination of these two features that defines a Monad.</p>
<ul class="simple">
<li><p>the ability to bind two computations together</p></li>
<li><p>the possibility to construct a computation from a pure value without
making use of any of the potential side effects</p></li>
</ul>
<p>If we look in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Monad</span>
<span class="kr">type</span> <span class="kt">Monad</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL (&gt;&gt;=) #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>We see the bind function</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>And the <em>return</em> function that takes a pure value and turns it into a
computation that has potential for side effects, but does not use them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>The other function <em>&gt;&gt;</em> can easily be defined in terms of <em>&gt;&gt;=</em>, but is
provided for convenience.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>What this function does is to throw away the result of the first
computation, so you could define it in terms of <em>&gt;&gt;=</em> by just ignoring
the argument to the function parameter.</p>
<p>There’s another technical computation. We see that <em>Monad</em> has the super
class <em>Applicative</em>, so every Monad is <em>Applicative</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Applicative</span>
<span class="kr">type</span> <span class="kt">Applicative</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
<span class="nf">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.</span><span class="n">liftA2</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span>
         <span class="kt">Applicative</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>We see it has a bunch of functions, but we only need the first two.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>The function <em>pure</em> has the same type signature as <em>return</em>. Then there
is &lt;*&gt; (pronounced ‘ap’) which looks a bit more complicated. But, the
truth is that, once you have <em>return</em> and <em>&gt;&gt;=</em> in a Monad, we can
easily define both <em>pure</em> and &lt;*&gt;.</p>
<p>We see that <em>Applicative</em> also has a superclass <em>Functor</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Functor</span>
<span class="kr">type</span> <span class="kt">Functor</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
<span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL fmap #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>As we mentioned in the context of <em>IO</em>, <em>Functor</em> has the <em>fmap</em>
function which, given a function from <em>a</em> to <em>b</em> will turn an <em>f a</em> into
an <em>f b</em>.</p>
<p>The prototypical example for <em>fmap</em> is lists where <em>fmap</em> is just <em>map</em>.
Given a function from <em>a</em> to <em>b</em>, you can create a list of type <em>b</em> from
a list of type <em>a</em> by applying the <em>map</em> function to each of the
elements of the list.</p>
<p>Again, once you have <em>return</em> and <em>&gt;&gt;=</em>, it is easy to define <em>fmap</em>.</p>
<p>So, whenever you want to define a Monad, you just define <em>return</em> and
<em>&gt;&gt;=</em>, and to make the compiler happy and to give instances for
<em>Functor</em> and <em>Applicative</em>, there’s always a standard way of doing it.</p>
<p>We can do this in the example of <em>Writer</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Writer</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="ow">=</span> <span class="n">liftM</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Writer</span> <span class="kr">where</span>
   <span class="n">pure</span> <span class="ow">=</span> <span class="n">return</span>
   <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Writer</span> <span class="kr">where</span>
   <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="kt">[]</span>
   <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bindWriter</span>
</pre></div>
</div>
<p>We don’t have to do the same for <em>Maybe</em>, <em>Either</em> or <em>IO</em> because they
are already Monads defined by the Prelude.</p>
</div>
<div class="section" id="why-is-this-useful">
<h3><span class="section-number">1.4.2.7. </span>Why Is This useful?<a class="headerlink" href="#why-is-this-useful" title="Permalink to this headline">¶</a></h3>
<p>It is always useful, in general, to identify a common pattern and give
it a name.</p>
<p>But, maybe the most important advantage is that there are lots of
functions that don’t care which Monad we are dealing with - they will
work with all Monads.</p>
<p>Let’s generalize the example where we compute the sum of three integers.
We use a <em>let</em> in the example below for reasons that will become clear
in moment.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">threeInts</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="nf">threeInts</span> <span class="n">mx</span> <span class="n">my</span> <span class="n">mz</span> <span class="ow">=</span>
   <span class="n">mx</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
   <span class="n">my</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
   <span class="n">mz</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
   <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span> <span class="kr">in</span> <span class="n">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>Now we have this function, we can return to the <em>Maybe</em> example and
rewrite it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">threeInts</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>We can do the same for the <em>Either</em> example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">threeInts</span> <span class="p">(</span><span class="n">readEither</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">readEither</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="n">readEither</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>Writer</em> example is not exactly the same.</p>
<p>If we are happy not to have the log message for the sum, it is very
simple as it is already an instance of <em>threeInts</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">threeInts</span>
</pre></div>
</div>
<p>However, if we want the final log message, it becomes a little more
complicated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">threeInts</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
   <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;sum: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span><span class="p">]</span>
   <span class="n">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>If you look into the Control.Monad module in the standard Haskell
Prelude, you will see that there are many useful functions that you can
use for all Monads.</p>
<p>One way to think about a Monad is as a computation with a super power.</p>
<p>In the case of <em>IO</em>, the super power would be having real-world
side-effects. In the case of <em>Maybe</em>, the super power is being able to
fail. The super power of <em>Either</em> is to fail with an error message. And
in the case of <em>Writer</em>, the super power is to log messages.</p>
<p>There is a saying in the Haskell community that Haskell has an
overloaded semi-colon. The explanation for this is that in many
imperative programming languages, you have semi-colons that end with a
semi-colon - each statement is executed one after the other, each
separated by a semi-colon. But, what exactly the semi-colon means
depends on the language. For example, there could be an exception, in
which case computation would stop and wouldn’t continue with the next
lines.</p>
<p>In a sense, <em>bind</em> is like a semi-colon. And the cool thing about
Haskell is that it is a programmable semi-colon. We get to say what the
logic is for combining two computations together.</p>
<p>Each Monad comes with its own “semi-colon”.</p>
</div>
<div class="section" id="do-notation">
<h3><span class="section-number">1.4.2.8. </span>‘do’ notation<a class="headerlink" href="#do-notation" title="Permalink to this headline">¶</a></h3>
<p>Because this pattern is so common and monadic computations are all over
the place, there is a special notation for this in Haskell, called <em>do</em>
notation.</p>
<p>It is syntactic sugar. Let’s rewrite <em>threeInts</em> using <em>do</em> notation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">threeInts&#39;</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="nf">threeInts&#39;</span> <span class="n">mx</span> <span class="n">my</span> <span class="n">mz</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">k</span> <span class="ow">&lt;-</span> <span class="n">mx</span>
   <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">my</span>
   <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">mz</span>
   <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span>
   <span class="n">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>This does exactly the same thing as the non-<em>do</em> version, but it has
less noise.</p>
<p>Note that the <em>let</em> statement does not use an <em>in</em> part. It does not
need to inside a <em>do</em> block.</p>
<p>And that’s Monads. There is a lot more to say about them but hopefully
you now have an idea of what Monads are and how they work.</p>
<p>Often you are in a situation where you want several effects at once -
for example you may want optional failure <em>and</em> log messages. There are
ways to do that in Haskell. For example there are Monad Transformers
where one can basically build custom Monads with the features that you
want.</p>
<p>There are other approaches. One is called Effect Systems, which has a
similar objective. And this is incidentally what Plutus uses for
important Monads. In particular the Contact Monad in the wallet, and the
Trace Monad which is used to test Plutus code.</p>
<p>The good news is that you don’t need to understand Effect Systems to
work with these Monads. You just need to know that you are working with
a Monad, and what super powers it has.</p>
</div>
</div>
<div class="section" id="plutus-monads">
<h2><span class="section-number">1.4.3. </span>Plutus Monads<a class="headerlink" href="#plutus-monads" title="Permalink to this headline">¶</a></h2>
<p>Now that we have seen how to write monadic code, either by using bind and return or by using do notation, we can look a very important Monad, namely the Contract Monad, which you may have
already noticed in previous code examples.</p>
<p>The Contract Monad defines code that will run in the wallet, which is the off-chain part of Plutus.</p>
<p>But, before we go into details, we will talk about a second Monad, the EmulatorTrace monad.</p>
<div class="section" id="the-emulatortrace-monad">
<h3><span class="section-number">1.4.3.1. </span>The EmulatorTrace Monad<a class="headerlink" href="#the-emulatortrace-monad" title="Permalink to this headline">¶</a></h3>
<p>You may have wondered if there is a way to execute Plutus code for testing purposes without using the Plutus Playground. There is indeed, and this is done using the <em>EmulatorTrace</em> Monad.</p>
<p>You can think of a program in this monad as what we do manually in the <em>simulator</em> tab of the playground. That is, we define the initial conditions, we define the actions such as which wallets
invoke which endpoints with which parameters and we define the waiting periods between actions.</p>
<p>The relevant definitions are in the package <em>plutus-contract</em> in module <em>Plutus.Trace.Emulator</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.Trace.Emulator</span>
</pre></div>
</div>
<p>The most basic function is called <em>runEmulatorTrace</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Run an emulator trace to completion, returning a tuple of the final state</span>
<span class="c1">-- of the emulator, the events, and any error, if any.</span>
<span class="nf">runEmulatorTrace</span>
    <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
    <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
    <span class="ow">-&gt;</span> <span class="p">([</span><span class="kt">EmulatorEvent</span><span class="p">],</span> <span class="kt">Maybe</span> <span class="kt">EmulatorErr</span><span class="p">,</span> <span class="kt">EmulatorState</span><span class="p">)</span>
<span class="nf">runEmulatorTrace</span> <span class="n">cfg</span> <span class="n">trace</span> <span class="ow">=</span>
    <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">xs</span> <span class="kt">:&gt;</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
    <span class="o">$</span> <span class="n">run</span>
    <span class="o">$</span> <span class="n">runReader</span> <span class="p">((</span><span class="n">initialDist</span> <span class="o">.</span> <span class="n">_initialChainState</span><span class="p">)</span> <span class="n">cfg</span><span class="p">)</span>
    <span class="o">$</span> <span class="n">foldEmulatorStreamM</span> <span class="p">(</span><span class="n">generalize</span> <span class="n">list</span><span class="p">)</span>
    <span class="o">$</span> <span class="n">runEmulatorStream</span> <span class="n">cfg</span> <span class="n">trace</span>
</pre></div>
</div>
<p>It gets something called an <em>EmulatorConfig</em> and an <em>EmulatorTrace ()</em>, which is a pure computation where no real-world side effects are involved. It is a pure function that executes
the trace on an emulated blockchain, and then gives a result as a list of <em>EmulatorEvent*s, maybe an error, if there was one, and then finally the final *EmulatorState</em>.</p>
<p><em>EmulatorConfig</em> is defined in a different module in the same package:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Wallet.Emulator.Stream</span>

<span class="kr">data</span> <span class="kt">EmulatorConfig</span> <span class="ow">=</span>
<span class="kt">EmulatorConfig</span>
    <span class="p">{</span> <span class="n">_initialChainState</span>      <span class="ow">::</span> <span class="kt">InitialChainState</span> <span class="c1">-- ^ State of the blockchain at the beginning of the simulation. Can be given as a map of funds to wallets, or as a block of transactions.</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">InitialChainState</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="kt">InitialDistribution</span> <span class="kt">Block</span>
</pre></div>
</div>
<p>We see it only has one field, which is of type <em>InitialChainState</em> and it is either <em>InitialDistribution</em> or <em>Block</em>.</p>
<p><em>InitialDistribution</em> is defined in another module in the same package, and it is a type synonym for a map of key value pairs of <em>Wallet*s to *Value*s, as you would expect. *Value</em> can be
either lovelace or native tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.Contract.Trace</span>

<span class="kr">type</span> <span class="kt">InitialDistribution</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">Value</span>
</pre></div>
</div>
<p>In the same module, we see something called <em>defaultDist</em> which returns a default distribution for all wallets. It does this by passing the 10 wallets defined by <em>allWallets</em> to <em>defaultDistFor</em> which takes a list of
wallets.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | The wallets used in mockchain simulations by default. There are</span>
<span class="c1">--   ten wallets because the emulator comes with ten private keys.</span>
<span class="nf">allWallets</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">EM</span><span class="o">.</span><span class="kt">Wallet</span><span class="p">]</span>
<span class="nf">allWallets</span> <span class="ow">=</span> <span class="kt">EM</span><span class="o">.</span><span class="kt">Wallet</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">]</span>

<span class="nf">defaultDist</span> <span class="ow">::</span> <span class="kt">InitialDistribution</span>
<span class="nf">defaultDist</span> <span class="ow">=</span> <span class="n">defaultDistFor</span> <span class="n">allWallets</span>

<span class="nf">defaultDistFor</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">EM</span><span class="o">.</span><span class="kt">Wallet</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">InitialDistribution</span>
<span class="nf">defaultDistFor</span> <span class="n">wallets</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">(</span><span class="n">repeat</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="mi">100_000_000</span><span class="p">))</span>
</pre></div>
</div>
<p>We can try this out in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.Trace.Emulator</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.Contract.Trace</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">defaultDist</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">6</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">7</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">8</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">9</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">10</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])]))]</span>
</pre></div>
</div>
<p>We can see that each of the 10 wallets has been given an initial distribution of 100,000,000 lovelace.</p>
<p>We can also get the balances for a specific wallet or wallets:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">defaultDistFor</span> <span class="p">[</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])]))]</span>
</pre></div>
</div>
<p>If you want different initial values, of if you want native tokens, then you have to specify that manually.</p>
<p>Let’s see what we need to run our first trace:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">runEmulatorTrace</span>
<span class="nf">runEmulatorTrace</span>
<span class="ow">::</span> <span class="kt">EmulatorConfig</span>
<span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="ow">-&gt;</span> <span class="p">([</span><span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">MultiAgent</span><span class="o">.</span><span class="kt">EmulatorEvent</span><span class="p">],</span> <span class="kt">Maybe</span> <span class="kt">EmulatorErr</span><span class="p">,</span>
      <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">MultiAgent</span><span class="o">.</span><span class="kt">EmulatorState</span><span class="p">)</span>
</pre></div>
</div>
<p>So, we need an <em>EmulatorConfig</em> which we know takes an <em>InitialChainState</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Wallet.Emulator.Stream</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">InitialChainState</span>
<span class="kr">type</span> <span class="kt">InitialChainState</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">type</span> <span class="kt">InitialChainState</span> <span class="ow">=</span>
<span class="kt">Either</span> <span class="kt">InitialDistribution</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Blockchain</span><span class="o">.</span><span class="kt">Block</span>
      <span class="c1">-- Defined in ‘Wallet.Emulator.Stream’</span>
</pre></div>
</div>
<p>If we take the <em>Left</em> of the <em>defaultDist</em> will will get an <em>InitialDistribution</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Left</span> <span class="n">defaultDist</span>
<span class="kt">Left</span> <span class="n">defaultDist</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">InitialDistribution</span> <span class="n">b</span>
</pre></div>
</div>
<p>Which we can then use to construct an <em>EmulatorConfig</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="n">defaultDist</span>
<span class="kt">EmulatorConfig</span> <span class="p">{</span><span class="n">_initialChainState</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">6</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">7</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">8</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">9</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">10</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])]))])}</span>
</pre></div>
</div>
<p>So, let’s try out <em>runEmulatorTrace</em>. Recall that, as well as and <em>EmulatorConfig</em>, we also need to pass in an <em>EmulatorTrace</em>, and the most simple one we can create is simply one that returns Unit - <em>return ()</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runEmulatorTrace</span> <span class="p">(</span><span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="n">defaultDist</span><span class="p">)</span> <span class="o">$</span> <span class="n">return</span> <span class="nb">()</span>
</pre></div>
</div>
<p>If you run this in the REPL you will get a crazy amount of data output to the console, even though we are not doing anything with the trace. If you want to make it useful, you must
somehow filter all this data down to something that sensible, and aggregate it in some way.</p>
<p>Luckily, there are other functions as well as <em>runEmulatorTrace</em>. One of them is <em>runEmulatorTraceIo</em> which runs the emulation then outputs the trace in a nice form on the screen.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runEmulatorTraceIO</span>
<span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runEmulatorTraceIO</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">def</span>
</pre></div>
</div>
<p>To use this function, we don’t need to specify an <em>EmulatorConfig</em> like we did before, because by default will will just use the default distribution.</p>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">...&gt;</span> <span class="n">runEmulatorTraceIO</span> <span class="o">$</span> <span class="n">return</span> <span class="nb">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>And we see a much more manageable, concise output. Nothing happens, but we see the Genesis transaction and then the final balances for each wallet.</p>
<p>If you want more control, there is also <em>runEmulatorTraceIO’</em>, which does take an <em>EmulatorConfig</em>, so we could specify a different distribution.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runEmulatorTraceIO&#39;</span>
<span class="ow">::</span> <span class="kt">TraceConfig</span>
<span class="ow">-&gt;</span> <span class="kt">EmulatorConfig</span>
<span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runEmulatorTraceIO&#39;</span> <span class="n">tcfg</span> <span class="n">cfg</span> <span class="n">trace</span>
<span class="ow">=</span> <span class="n">runPrintEffect</span> <span class="p">(</span><span class="n">outputHandle</span> <span class="n">tcfg</span><span class="p">)</span> <span class="o">$</span> <span class="n">runEmulatorTraceEff</span> <span class="n">tcfg</span> <span class="n">cfg</span> <span class="n">trace</span>
</pre></div>
</div>
<p>It also takes a <em>TraceConfig</em>, which has two fields.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TraceConfig</span> <span class="ow">=</span> <span class="kt">TraceConfig</span>
<span class="p">{</span> <span class="n">showEvent</span>    <span class="ow">::</span> <span class="kt">EmulatorEvent&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="c1">-- ^ Function to decide how to print the particular events.</span>
<span class="p">,</span> <span class="n">outputHandle</span> <span class="ow">::</span> <span class="kt">Handle</span>
<span class="c1">-- ^ Where to print the outputs to. Default: &#39;System.IO.stdout&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first field, <em>showEvent</em> is a function that specifies which <em>EmulatorEvent*s are displayed and how they are displayed. It takes
an *EmulatorEvent</em> as an argument and can return <em>Nothing</em> it the event should not be displayed, or a <em>Just</em> with a <em>String</em> showing how the event will be displayed.</p>
<p>Here is the default <em>TraceConfig</em> used by <em>runEmulatorTraceIO</em>. We can see that most events are ignored and that we only get output for some of the events.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Default</span> <span class="kt">TraceConfig</span> <span class="kr">where</span>
<span class="nf">def</span> <span class="ow">=</span> <span class="kt">TraceConfig</span>
            <span class="p">{</span> <span class="n">showEvent</span>     <span class="ow">=</span> <span class="n">defaultShowEvent</span>
            <span class="p">,</span> <span class="n">outputHandle</span>  <span class="ow">=</span> <span class="n">stdout</span>
            <span class="p">}</span>

<span class="nf">defaultShowEvent</span> <span class="ow">::</span> <span class="kt">EmulatorEvent&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="nf">defaultShowEvent</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
<span class="kt">UserThreadEvent</span> <span class="p">(</span><span class="kt">UserLog</span> <span class="n">msg</span><span class="p">)</span>                                        <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">$</span> <span class="s">&quot;*** USER LOG: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">msg</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">ContractLog</span> <span class="p">(</span><span class="kt">A</span><span class="o">.</span><span class="kt">String</span> <span class="n">msg</span><span class="p">))</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">$</span> <span class="s">&quot;*** CONTRACT LOG: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">msg</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">StoppedWithError</span> <span class="n">err</span><span class="p">)</span>       <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">$</span> <span class="s">&quot;*** CONTRACT STOPPED WITH ERROR: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">err</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="kt">NoRequestsHandled</span>            <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">HandledRequest</span> <span class="kr">_</span><span class="p">)</span>           <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">CurrentRequests</span> <span class="kr">_</span><span class="p">)</span>          <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">SchedulerEvent</span> <span class="kr">_</span>                                                     <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">ChainIndexEvent</span> <span class="kr">_</span> <span class="kr">_</span>                                                  <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">WalletEvent</span> <span class="kr">_</span> <span class="kr">_</span>                                                      <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">ev</span>                                                                   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">.</span> <span class="n">renderString</span> <span class="o">.</span> <span class="n">layoutPretty</span> <span class="n">defaultLayoutOptions</span> <span class="o">.</span> <span class="n">pretty</span> <span class="o">$</span> <span class="n">ev</span>
</pre></div>
</div>
<p>The second field is a handle which defaults to <em>stdout</em>, but we could also specify a file here.</p>
<p>Now let’s look at a more interesting trace, using the <em>Vesting</em> contract from the last lecture.</p>
<p>First, we define a <em>Trace</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
<span class="nf">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="n">h1</span> <span class="o">$</span> <span class="kt">GiveParams</span>
      <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">2</span>
      <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">=</span> <span class="kt">Slot</span> <span class="mi">20</span>
      <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">=</span> <span class="mi">1000</span>
      <span class="p">}</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">waitUntilSlot</span> <span class="mi">20</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="n">h2</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">waitNSlots</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The first thing we have to do is to activate the wallets using the monadic function <em>activateContractWallet</em>. We bind the result of this function to <em>h1</em>, and then bind the result of
a second call (for Wallet 2) to <em>h2</em>. Those two values - <em>h1</em> and <em>h2</em> are handles to their respective wallets.</p>
<p>Next, we use <em>callEndpoint</em> to simulate Wallet 1 calling the <em>give</em> endpoint, with the shown parameters. We then wait for 20 slots. The function <em>waitUntilSlot</em> actually returns
a value representing the slot that was reached, but, as we are not interested in that value here, we use <em>void</em> to ignore it. We then simulate the call to the <em>grab</em> endpoint
by Wallet 2.</p>
<p>Now, we can write a function to call <em>runEmulatorTraceIO</em> with out <em>Trace</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace</span>
</pre></div>
</div>
<p>And, we can then run this in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">test</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;give&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;gpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1000.0</span><span class="p">),(</span><span class="s2">&quot;gpBeneficiary&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s2">&quot;gpDeadline&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;getSlot&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">20.0</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">49</span><span class="n">f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">49</span><span class="n">f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;made a gift of 1000 lovelace to 39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f with deadline Slot {getSlot = 20}&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">5</span>
<span class="n">Slot</span> <span class="mi">00005</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">6</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">7</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">8</span>
<span class="n">Slot</span> <span class="mi">00008</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">9</span>
<span class="n">Slot</span> <span class="mi">00009</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">10</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">11</span>
<span class="n">Slot</span> <span class="mi">00011</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">12</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">13</span>
<span class="n">Slot</span> <span class="mi">00013</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">14</span>
<span class="n">Slot</span> <span class="mi">00014</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">15</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">16</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">17</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">18</span>
<span class="n">Slot</span> <span class="mi">00018</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">19</span>
<span class="n">Slot</span> <span class="mi">00019</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">20</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;grab&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[])]))])</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">21</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;collected gifts&quot;</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">22</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99998990</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000990</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>This output is very similar to the output we see in the playground. We can see the Genesis transaction as well as both the <em>give</em> and <em>grab</em> transactions from the <em>Trace</em>. We can also see
some log output from the contract itself, prefixed with <em>CONTRACT LOG</em>.</p>
<p>We can also log from inside the <em>Trace</em> monad. We could, for example, lof the result of the final <em>waitNSlots</em> call:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="nf">s</span> <span class="ow">&lt;-</span> <span class="n">waitNSlots</span> <span class="mi">1</span>
<span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;reached slot &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span>
</pre></div>
</div>
<p>We would then see this output when we run the emulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">21</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="n">reached</span> <span class="n">slot</span> <span class="n">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="o">=</span> <span class="mi">21</span><span class="p">}</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;collected gifts&quot;</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">22</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Now let’s look at the Contract Monad.</p>
</div>
<div class="section" id="the-contract-monad">
<h3><span class="section-number">1.4.3.2. </span>The Contract Monad<a class="headerlink" href="#the-contract-monad" title="Permalink to this headline">¶</a></h3>
<p>The purpose of the Contract Monad is to define off-chain code that runs in the wallet. It has four type parameters:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Contract</span> <span class="p">{</span> <span class="n">unContract</span> <span class="ow">::</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">ContractEffs</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="p">)</span> <span class="n">a</span> <span class="p">}</span>
      <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Applicative</span><span class="p">,</span> <span class="kt">Monad</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>a</em> is the same as in every Monad - it denotes the result type of the computation.</p>
<p>We will go into the other three in more detail later but just briefly:</p>
<ul class="simple">
<li><p>w is like our Writer monad example, it allows us to write log messages of type <em>w</em>.</p></li>
<li><p>s describes the blockchain capabilities, e.g. waiting for a slot, submitting transactions, getting the wallet’s public key. It can also contain specific endpoints.</p></li>
<li><p>e describes the type of error messages that this monad can throw.</p></li>
</ul>
<p>Let’s write an example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract1</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract1</span> <span class="ow">=</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;Hello from the contract!&quot;</span>
</pre></div>
</div>
<p>Here, we pass a <em>Contract</em> constructed with <em>Unit</em> as the <em>w</em> type and <em>BlockchainActions</em> as the second argument, <em>s</em>. This gives us access to all the blockchain actions - the only thing we can’t do is to call specific endpoints.</p>
<p>For <em>e</em> - the error message type, we use <em>Text</em>. <em>Text</em> is a Haskell type which is like <em>String</em>, but it is much more efficient.</p>
<p>We don’t want a specific result, so we use <em>Unit</em> for the type <em>a</em>.</p>
<p>For the function body, we write a log message. We use <em>&#64;String</em> because, we have imported the type <em>Data.Text</em> and we have used the <em>OverloadedStrings</em> GHC compiler option,
so the compiler needs to know what type we are referencing - a <em>Text</em> or a <em>String</em>. We can use <em>&#64;String</em> if we also use the compiler option <em>TypeApplications</em>.</p>
<p>Let’s now define a <em>Trace</em> that starts the contract in the wallet, and a <em>test</em> function to run it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace1</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace1</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract1</span>

<span class="nf">test1</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test1</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace1</span>
</pre></div>
</div>
<p>If we run this in the REPL, we will see our log message from the contract.</p>
<p>Now, let’s throw an exception.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract1</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract1</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">throwError</span> <span class="s">&quot;BOOM!&quot;</span>
<span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;Hello from the contract!&quot;</span>
</pre></div>
</div>
<p>Recall that we chose the type <em>Text</em> as the error message.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test1</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">STOPPED</span> <span class="n">WITH</span> <span class="n">ERROR</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">BOOM!</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>Now, we don’t get the log message, but we do get told that the contract stopped with an error and we see our exception message.</p>
<p>Another thing you can do is to handle exceptions. We will use the <em>handleError</em> function from module <em>Plutus.Contract.Types</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handleError</span> <span class="ow">::</span>
      <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">e&#39;</span> <span class="n">a</span><span class="o">.</span>
      <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e&#39;</span> <span class="n">a</span><span class="p">)</span>
      <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span>
      <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e&#39;</span> <span class="n">a</span>
<span class="nf">handleError</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Contract</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Contract</span> <span class="n">c&#39;</span> <span class="kr">where</span>
      <span class="n">c&#39;</span> <span class="ow">=</span> <span class="kt">E</span><span class="o">.</span><span class="n">handleError</span> <span class="o">@</span><span class="n">e</span> <span class="p">(</span><span class="n">raiseUnderN</span> <span class="o">@</span><span class="kt">&#39;[E.Error e&#39;]</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">unContract</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>handleError</em> function takes an error handler and a <em>Contract</em> instance. The error handler takes an argument of type <em>e</em> from our contract,
and returns a new <em>Contract</em> with the same type parameters as the first, but we can change the type of the <em>e</em> argument - the error type, which is expressed in the
return <em>Contract</em> argument list as <em>e’</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract2</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Void</span> <span class="nb">()</span>
<span class="nf">myContract2</span> <span class="ow">=</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">handleError</span>
      <span class="p">(</span><span class="nf">\</span><span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logError</span> <span class="o">$</span> <span class="s">&quot;Caught error: &quot;</span> <span class="o">++</span> <span class="n">unpack</span> <span class="n">err</span><span class="p">)</span>
      <span class="n">myContract1</span>

<span class="nf">myTrace2</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace2</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract2</span>

<span class="nf">test2</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test2</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace2</span>
</pre></div>
</div>
<p>We use the type <em>Void</em> as the error type. <em>Void</em> is a type that can hold no value, so, by using this type we are saying that there cannot be any errors for this contract.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function <em>unpack</em> is defined in the <em>Data.Text</em> module. It converts a value of type <em>Text</em> to a value of type <em>String</em>.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test2</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Caught error: BOOM!&quot;</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">stopped</span> <span class="p">(</span><span class="n">no</span> <span class="n">errors</span><span class="p">)</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="o">...</span>
</pre></div>
</div>
<p>We no longer get the error message, but, instead we get a message from the error handler showing the exception that was thrown by Contract1. Note that we still do not get the message
“Hello from the contract!”. Contract 1 still stopped processing after its error, but there was no overall contract error due to the exception being caught and handled.</p>
<p>Of course, exceptions can also happen even if they are not explicitly thrown by your contract code. There are operations, such as submitting a transaction where there are insufficient
inputs to make a payment for an output, where Plutus will throw an exception.</p>
<p>Next, let’s look at the <em>s</em> parameter, the second parameter to <em>Contract</em>, that determines the available blockchain actions.</p>
<p>In the first two examples we just used the <em>BlockChainActions</em> type which has all the standard functionality but without support for specific endpoints. If we want support for
specific endpoints, we must use a different type.</p>
<p>The way that is usually done is by using a type synonym. The following example will create a type synonym <em>MySchema</em> that has all the capabilities of <em>BlockChainActions</em> but
with the addition of being able to call endpoint <em>foo</em> with an argument of type <em>Int</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">MySchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;foo&quot;</span> <span class="kt">Int</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The operator <em>.\/</em> is a type operator - it operates on types, not values. In order to use this we need to use the <em>TypeOperators</em> and <em>DataKinds</em> compiler options.</p>
</div>
<p>Now, we can use the <em>MySchema</em> type to define our contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract3</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">MySchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract3</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;foo&quot;</span>
      <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="n">n</span>
</pre></div>
</div>
<p>This contract will block until the endpoint <em>foo</em> is called with, in our case, an <em>Int</em>. Then the value of the <em>Int</em> parameter will be bound to <em>n</em>.
Because of this, it is no longer enough for us to just activate the contract to test it. Now, we must invoke the endpoint as well.</p>
<p>In order to do this, we now need to handle from <em>activateContractWallet</em>, which we can then use to call the endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace3</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace3</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="n">h</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract3</span>
      <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;foo&quot;</span> <span class="n">h</span> <span class="mi">42</span>

<span class="nf">test3</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test3</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace3</span>
</pre></div>
</div>
<p>Running this in the REPL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test3</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="o">...</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;foo&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">42.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">log</span><span class="p">:</span> <span class="n">Number</span> <span class="mf">42.0</span>
<span class="o">...</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>Finally, let’s look at the first type parameter, the writer. The <em>w</em> cannot be an arbitrary type, it must be an instance of the type class <em>Monoid</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Monoid</span>
<span class="kr">type</span> <span class="kt">Monoid</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="kr">where</span>
<span class="nf">mempty</span> <span class="ow">::</span> <span class="n">a</span>
<span class="nf">mappend</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">mconcat</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL mempty #-}</span>
      <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Ordering</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">d</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span>
      <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=&gt;</span>
      <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="nb">()</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>This is a very important and very common type class in Haskell. It defines <em>mempty</em> and <em>mappend</em>.</p>
<p>The function <em>mempty</em> is like the neutral element, and <em>mappend</em> combines two elements of this type to create a new element of the same type.</p>
<p>The prime example of a <em>Monoid</em> is <em>List</em>, when <em>mempty</em> is the empty list <em>[]</em>, and <em>mappend</em> is concatenation <em>++</em>.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">mempty</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="kt">[]</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">mappend</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>The are many, many other examples of the <em>Monoid</em> type, and we will see other instances in this course.</p>
<p>But for now, let’s stick with lists and write our last example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract4</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract4</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">tell</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">tell</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Rather than using <em>Unit</em> as our <em>w</em> type, we are using <em>[Int]</em>. This allows us to use the <em>tell</em> function as shown.</p>
<p>This now gives us access to those messages during the trace, using the <em>observableState</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace4</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace4</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">h</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract4</span>

    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
    <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="n">show</span> <span class="n">xs</span>

    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">ys</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="n">show</span> <span class="n">ys</span>

    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">zs</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="n">show</span> <span class="n">zs</span>

<span class="nf">test4</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test4</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace4</span>
</pre></div>
</div>
<p>If we run this in the REPL, we can see the <em>USER LOG</em> messages created using the <em>tell</em> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test4</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00005</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">6</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">7</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="p">[]</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">8</span>
<span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">16</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">17</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">18</span>
<span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00025</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">26</span>
<span class="n">Slot</span> <span class="mi">00026</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00026</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">27</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>Using this mechanism, it is possible to pass information from the contract running in the wallet to the outside world. Using endpoints we can pass information into a contract.
And using the <em>tell</em> mechanism we can get information out of the wallet.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week5.html" class="btn btn-neutral float-right" title="1.5. Week 05 - Native Tokens" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="week3.html" class="btn btn-neutral float-left" title="1.3. Week 03 - Script Context" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1.5. Week 05 - Native Tokens &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1.6. Week 06 - Oracles" href="week6.html" />
    <link rel="prev" title="1.4. Week 04 - Monads" href="week4.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../plutus_pioneer_program.html">1. Plutus Pioneer Program</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="week1.html">1.1. Week 01 - English Auction</a></li>
<li class="toctree-l2"><a class="reference internal" href="week2.html">1.2. Week 02 - Validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="week3.html">1.3. Week 03 - Script Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="week4.html">1.4. Week 04 - Monads</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">1.5. Week 05 - Native Tokens</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">1.5.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value">1.5.2. Value</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-value-type">1.5.2.1. The Value Type</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#minting-policies">1.5.3. Minting Policies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-1-free">1.5.4. Example 1 - Free</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#on-chain">1.5.4.1. On chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#off-chain">1.5.4.2. Off chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#in-the-playground">1.5.4.3. In The Playground</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testing-with-emulatortrace">1.5.4.4. Testing with EmulatorTrace</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-2-signed">1.5.5. Example 2 - Signed</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">1.5.5.1. On-chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">1.5.5.2. Off-chain</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#nfts">1.5.6. NFTs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-3-nft">1.5.6.1. Example 3 - NFT</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week6.html">1.6. Week 06 - Oracles</a></li>
<li class="toctree-l2"><a class="reference internal" href="week7.html">1.7. Week 07 - State Machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="week8.html">1.8. Week 08 - Property Based Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="week9.html">1.9. Week 09 - Marlowe</a></li>
<li class="toctree-l2"><a class="reference internal" href="week10.html">1.10. Week 10 - Uniswap</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../alonzo_white.html">2. Alonzo Walkthrough</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../plutus_pioneer_program.html"><span class="section-number">1. </span>Plutus Pioneer Program</a> &raquo;</li>
        
      <li><span class="section-number">1.5. </span>Week 05 - Native Tokens</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/pioneer/week5.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-05-native-tokens">
<h1><span class="section-number">1.5. </span>Week 05 - Native Tokens<a class="headerlink" href="#week-05-native-tokens" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://youtu.be/6VbhY162GQA">Lecture
#5</a>.</p>
<p>In this lecture we learn about native tokens, minting policies and NFTs.</p>
<p>These notes use Plutus commit 0c3c310cab61dbff8cbc1998a3678b367be6815a</p>
</div>
<div class="section" id="overview">
<h2><span class="section-number">1.5.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>We are going to talk about how Plutus supports native tokens and how to define under which conditions native tokens can be minted and burned. But before we get to that,
let’s explore what <em>value</em> means in Cardano.</p>
<p>When we talked about the (E)UTxO model, we learned that each UTxO (unspent transaction) has an address and a value. And, we saw that, as a result of being extended to the (E)UTxO model, each
UTxO also has a <em>Datum</em>. We have seen examples of such UTxOs in previous lectures.</p>
<p>In almost all the examples we have seen so far, the value was simply an Ada value, denominated in lovelace. The exception was the first example, from lecture 1, namely the <em>English Auction</em>
example. In that example we auctioned away an NFT. However, the NFT was just created out of thin air in the playground.</p>
<p>In the real Cardano blockchain, however, in the beginning there are only Ada, there are no other native tokens. So, you have to do something to create new native tokens, or to burn existing ones.
In this lecture we will see how to do that.</p>
<p>But let’s first talk above values.</p>
</div>
<div class="section" id="value">
<h2><span class="section-number">1.5.2. </span>Value<a class="headerlink" href="#value" title="Permalink to this headline">¶</a></h2>
<p>The relevant types are defined in package <em>plutus-ledger-api</em>. The modules of interest are</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.V1.Ledger.Value</span>
<span class="kr">module</span> <span class="nn">Plutus.V1.Ledger.Ada</span>
</pre></div>
</div>
<div class="section" id="the-value-type">
<h3><span class="section-number">1.5.2.1. </span>The Value Type<a class="headerlink" href="#the-value-type" title="Permalink to this headline">¶</a></h3>
<p><em>Value</em> is defined as a map from <em>CurrencySymbol*s to maps from *TokenName*s to *Integers</em>, which sounds a bit weird and complicated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Value</span> <span class="ow">=</span> <span class="kt">Value</span> <span class="p">{</span> <span class="n">getValue</span> <span class="ow">::</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">CurrencySymbol</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">TokenName</span> <span class="kt">Integer</span><span class="p">)</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">Hashable</span><span class="p">,</span> <span class="kt">NFData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Serialise</span><span class="p">,</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kt">Pretty</span> <span class="n">via</span> <span class="p">(</span><span class="kt">PrettyShow</span> <span class="kt">Value</span><span class="p">)</span>
</pre></div>
</div>
<p>The first thing to note is that each native token, including Ada, is identified by two pieces of data - the <em>CurrencySymbol</em> and the <em>TokenName</em>.</p>
<p>A <em>CurrencySymbol</em> is a <em>newtype</em> wrapper around a <em>ByteString</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CurrencySymbol</span> <span class="ow">=</span> <span class="kt">CurrencySymbol</span> <span class="p">{</span> <span class="n">unCurrencySymbol</span> <span class="ow">::</span> <span class="kt">Builtins</span><span class="o">.</span><span class="kt">ByteString</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">IsString</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Serialise</span><span class="p">,</span> <span class="kt">Pretty</span><span class="p">)</span> <span class="n">via</span> <span class="kt">LedgerBytes</span>
    <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Haskell</span><span class="o">.</span><span class="kt">Ord</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">Hashable</span><span class="p">,</span> <span class="kt">ToJSONKey</span><span class="p">,</span> <span class="kt">FromJSONKey</span><span class="p">,</span>  <span class="kt">NFData</span><span class="p">)</span>
</pre></div>
</div>
<p>And the same is true for <em>TokenName</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">TokenName</span> <span class="ow">=</span> <span class="kt">TokenName</span> <span class="p">{</span> <span class="n">unTokenName</span> <span class="ow">::</span> <span class="kt">Builtins</span><span class="o">.</span><span class="kt">ByteString</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Serialise</span><span class="p">)</span> <span class="n">via</span> <span class="kt">LedgerBytes</span>
    <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Haskell</span><span class="o">.</span><span class="kt">Ord</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">Hashable</span><span class="p">,</span> <span class="kt">NFData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kt">Pretty</span> <span class="n">via</span> <span class="p">(</span><span class="kt">PrettyShow</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>So we have these two <em>ByteStrings</em> that define a coin, or, as it is also called, an <em>asset class</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assetClass</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">AssetClass</span>
<span class="nf">assetClass</span> <span class="n">s</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Ada is one asset class, and custom native tokens will be other asset classes.</p>
<p>A <em>Value</em> simply shows how many units exist for a given asset class.</p>
<p>Let’s start the REPL and import the two relevant modules.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cabal</span> <span class="n">repl</span>
<span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Ada</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Value</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">set</span> <span class="o">-</span><span class="kt">XOverloadedStrings</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We have also activated the <em>OverloadedStrings</em> extension so that we can enter <a href="#id1"><span class="problematic" id="id2">*</span></a>ByteString*s as literal strings.</p>
</div>
<p>Now let’s look at some values. Let’s start with lovelace values. In the <em>Ledger.Ada</em> module there is a function called <em>adaSymbol</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">adaSymbol</span>
<span class="nf">adaSymbol</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
</pre></div>
</div>
<p>This gives us the currency symbol of the Ada asset class, which is just the empty <em>ByteString</em>. Similarly, there is a function <em>adaToken</em>, which will give us the token name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">adaToken</span>
<span class="nf">adaToken</span> <span class="ow">::</span> <span class="kt">TokenName</span>
</pre></div>
</div>
<p>Again, this is also the empty <em>ByteString</em>.</p>
<p>We have seen before in the examples how to construct a <em>Value</em> containing just lovelace. There is a function <em>lovelaceValueOf</em> that, given an <em>Integer</em>, gives us a <em>Value</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">lovelaceValueOf</span>
<span class="nf">lovelaceValueOf</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
</pre></div>
</div>
<p>So, for example to have 123 lovelace, we can do:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">123</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">123</span><span class="p">)])])</span>
</pre></div>
</div>
<p>You will always use a helper function such as <em>lovelaceValueOf</em> to construct the value maps - you would never need to construct one directly.</p>
<p>Here we see the map. The out map of currency symbols has one key, which is the empty symbol for Ada, and the inner map of token names has one key, the empty string for Ada,
and a value of 123.</p>
<p>One thing we can do with values is combine them. The <em>Value</em> class is an instance of <em>Monoid</em>, so we can use <em>mappend</em>, which we can write as <em>&lt;&gt;</em>, which comes from a super class of
<em>Monoid</em> called <em>Semigroup</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">123</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">10</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">133</span><span class="p">)])])</span>
</pre></div>
</div>
<p>So, how do we create <a href="#id3"><span class="problematic" id="id4">*</span></a>Value*s containing native tokens?</p>
<p>There is a very useful function called <em>singleton</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">singleton</span>
<span class="nf">singleton</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
</pre></div>
</div>
<p>This will create a <em>Value</em> for a token specified by the <em>CurrencySymbol</em> and the <em>TokenName</em>, and for a given <em>Integer</em> amount.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span> <span class="mi">7</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(</span><span class="n">a8ff</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">)])])</span>
</pre></div>
</div>
<p>The first argument, “a8ff” for <em>CurrencySymbol” has to be a string representing a hexadecimal value, for reasons that will soon become clear. The second argument, “ABC”
for *TokenName</em> can be an arbitrary string.</p>
<p>And, we can combine, as before, with the <em>mappend</em> operator. We can now create a somewhat more interesting map.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span> <span class="mi">7</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">42</span> <span class="o">&lt;&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;XYZ&quot;</span> <span class="mi">100</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">42</span><span class="p">)]),(</span><span class="n">a8ff</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="s">&quot;XYZ&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Now, we see a map representing 42 lovelace as well as two tokens <em>ABC</em> and <em>XYZ</em> both belonging to the <em>CurrencySymbol</em> “af88”, and each with their respective integer amounts.</p>
<p>Let’s give this value a name:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span> <span class="mi">7</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">42</span> <span class="o">&lt;&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;XYZ&quot;</span> <span class="mi">100</span>
<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">v</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">42</span><span class="p">)]),(</span><span class="n">a8ff</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="s">&quot;XYZ&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Another useful function is <em>valueOf</em> which allows us to get the value of a given currency symbol and token name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">valueOf</span>
<span class="nf">valueOf</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">valueOf</span> <span class="n">v</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;XYZ&quot;</span>
<span class="mi">100</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">valueOf</span> <span class="n">v</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span>
<span class="mi">7</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">valueOf</span> <span class="n">v</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;abc&quot;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Another useful function is <em>flattenValue</em>. As the name suggests, it flattens the map of maps into a flat list of triples.</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">flattenValue</span>
<span class="nf">flattenValue</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">flattenValue</span> <span class="n">v</span>
<span class="p">[(</span><span class="n">a8ff</span><span class="p">,</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="n">a8ff</span><span class="p">,</span><span class="s">&quot;XYZ&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">),(,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">42</span><span class="p">)]</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="minting-policies">
<h2><span class="section-number">1.5.3. </span>Minting Policies<a class="headerlink" href="#minting-policies" title="Permalink to this headline">¶</a></h2>
<p>Now the question is why? Why do we need both a currency symbol and a token name? Why don’t we just use one identifier for an asset class? And why does the currency
symbol have to be in hexadecimal digits?</p>
<p>This is where so-called minting policies come in.</p>
<p>The rule is that, in general, a transaction can’t create or delete tokens. Everything that goes in also comes out, with the exception of the fees. There is always a lovelace feel
that has to be paid with each transaction. The fee depends on the size of the transaction and the number of steps that the validation script takes to execute, and the memory
consumption of the script.</p>
<p>But, if that was the whole story then we could never create native tokens. And this is where minting policies come in, and the relevance of the currency symbol comes in.</p>
<p>The reason that the currency symbol has to consist of hexadecimal digits is that it is actually the hash of a script. And this script is called the minting policy, and if
we have a transaction where we ant to create native or burn native tokens then, for each native token that we try to create or burn, the currency symbol is looked up. So, the
corresponding script must also be contained in the transaction. And that script is executed along with the other validation scripts.</p>
<p>And, similar to the validation scripts that we have seen so that validate input, the purpose of these minting scripts is to decide whether this transaction has the right to
mint or burn tokens. Ada also fits into this scheme. Remember the the currency symbol of Ada is just an empty string, which is not the hash of any scripts. So there is no
script that hashes to the empty string, so there is no script that would allow the minting or burning of Ada, which means that Ada can never be minted or burned.</p>
<p>All the Ada that exists comes from the Genesis transaction and the total amount of Ada in the system is fixed and can never change. Only custom native tokens can have custom minting policies.</p>
<p>So we’ll look at an example of a minting policy next and will see that it is very similar to a validation script, but not identical.</p>
<p>Before we write out first minting policy, let’s briefly recall how validation works.</p>
<p>When we don’t have a public key address, but a script address, and a UTxO that sits at that address, then for any transaction that tries to consume that UTxO, a validation script is run.</p>
<p>That validation script gets, as input, the datum, which comes from the UTxO, the redeemer, which comes from the input, and the context.</p>
<p>Recall that the <em>ScriptContext</em> has two fields.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span><span class="p">{</span><span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span> <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span> <span class="p">}</span>
</pre></div>
</div>
<p>One of those fields is <em>ScriptPurpose</em>, and, for this field, everything we have seen until now has been of type <em>Spending</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptPurpose</span>
    <span class="ow">=</span> <span class="kt">Minting</span> <span class="kt">CurrencySymbol</span>
    <span class="o">|</span> <span class="kt">Spending</span> <span class="kt">TxOutRef</span>
    <span class="o">|</span> <span class="kt">Rewarding</span> <span class="kt">StakingCredential</span>
    <span class="o">|</span> <span class="kt">Certifying</span> <span class="kt">DCert</span>
</pre></div>
</div>
<p>The other field is of type <em>TxInfo</em> which contains all the context information about the transaction.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | A pending transaction. This is the view as seen by validator scripts, so some details are stripped out.</span>
<span class="kr">data</span> <span class="kt">TxInfo</span> <span class="ow">=</span> <span class="kt">TxInfo</span>
    <span class="p">{</span> <span class="n">txInfoInputs</span>      <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span> <span class="c1">-- ^ Transaction inputs</span>
    <span class="p">,</span> <span class="n">txInfoInputsFees</span>  <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span>     <span class="c1">-- ^ Transaction inputs designated to pay fees</span>
    <span class="p">,</span> <span class="n">txInfoOutputs</span>     <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">]</span> <span class="c1">-- ^ Transaction outputs</span>
    <span class="p">,</span> <span class="n">txInfoFee</span>         <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The fee paid by this transaction.</span>
    <span class="p">,</span> <span class="n">txInfoForge</span>       <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The &#39;Value&#39; forged by this transaction.</span>
    <span class="p">,</span> <span class="n">txInfoDCert</span>       <span class="ow">::</span> <span class="p">[</span><span class="kt">DCert</span><span class="p">]</span> <span class="c1">-- ^ Digests of certificates included in this transaction</span>
    <span class="p">,</span> <span class="n">txInfoWdrl</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">StakingCredential</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span> <span class="c1">-- ^ Withdrawals</span>
    <span class="p">,</span> <span class="n">txInfoValidRange</span>  <span class="ow">::</span> <span class="kt">SlotRange</span> <span class="c1">-- ^ The valid range for the transaction.</span>
    <span class="p">,</span> <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">]</span> <span class="c1">-- ^ Signatures provided with the transaction, attested that they all signed the tx</span>
    <span class="p">,</span> <span class="n">txInfoData</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)]</span>
    <span class="p">,</span> <span class="n">txInfoId</span>          <span class="ow">::</span> <span class="kt">TxId</span>
    <span class="c1">-- ^ Hash of the pending transaction (excluding witnesses)</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
</pre></div>
</div>
<p>For minting policies, this is triggered if the <em>txInfoForge</em> field of the transaction contains a non-zero value. In all of the transactions we have seen so far, this field value
has been zero - we have never created or destroyed any tokens.</p>
<p>If it <em>is</em> non-zero, then for each currency symbol contained in the <em>Value</em>, the corresponding minting policy script is run.</p>
<p>Whereas the validation scripts had three inputs - the datum, the redeemer and the context, these minting policy scripts only have one input - the context.
And it is the same context as we had before - the <em>ScriptContext</em>. It would make no sense to have the datum, as it belongs to the UTxO, and it would make no sense to have
the redeemer as it belongs to the validation script. The minting policy belongs to the transaction itself, not to a specific input or output.</p>
<p>As for the <em>ScriptPurpose</em>, this will not be <em>Spending</em> as it has been until now, but will be <em>Minting</em>.</p>
</div>
<div class="section" id="example-1-free">
<h2><span class="section-number">1.5.4. </span>Example 1 - Free<a class="headerlink" href="#example-1-free" title="Permalink to this headline">¶</a></h2>
<p>Let’s write a simple minting policy.</p>
<div class="section" id="on-chain">
<h3><span class="section-number">1.5.4.1. </span>On chain<a class="headerlink" href="#on-chain" title="Permalink to this headline">¶</a></h3>
<p>When we wrote a validator we had a function such as the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Datum</span> <span class="ow">-&gt;</span> <span class="kt">Redeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>We also saw the low-level version where we had three <em>Data</em> arguments and returned <em>Unit</em>. And we saw that there can be additional arguments before the datum, if we
write a parameterized script.</p>
<p>We can also have parameterized minting policy scripts and we will see that in a later example. But first we will look at one that is not parameterized.</p>
<p>First, let’s rename the function to <em>mkPolicy</em>, remove the datum and redeemer, and write the simplest minting policy that we can.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>This policy ignores the context and always returns <em>True</em>. This will allow arbitrary minting and burning of tokens for and token name that belongs to the currency symbol
associated with this policy.</p>
<p>Remember that, when we were writing a validator, we needed to use Template Haskell to compile this function to Plutus code. We need to do something similar for our minting policy.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">policy</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">MonetaryPolicy</span>
<span class="nf">policy</span> <span class="ow">=</span> <span class="n">mkMonetaryPolicyScript</span> <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapMonetaryPolicy</span> <span class="n">mkPolicy</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>And, as before, we need to make the <em>mkPolicy</em> function <em>INLINABLE</em>, as everything within the Oxford brackets needs to be available at compile time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkPolicy #-}</span>
<span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Now that we have a policy, we can get a currency symbol from the policy.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">curSymbol</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
<span class="nf">curSymbol</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="n">policy</span>
</pre></div>
</div>
<p>And, we can look at this in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">curSymbol</span>
<span class="nf">e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf</span>
</pre></div>
</div>
<p>And this completes the on-chain part, for this simple minting policy. But in order to try it out and interact with it, we need an off-chain part.</p>
</div>
<div class="section" id="off-chain">
<h3><span class="section-number">1.5.4.2. </span>Off chain<a class="headerlink" href="#off-chain" title="Permalink to this headline">¶</a></h3>
<p>What should the off-chain part do? Well, it should allow arbitrary wallets to mint and burn tokens of this currency symbol.</p>
<p>We have the currency symbol, so what is missing is the token name and the amount we want to mint or burn. And for this, we will define a data type <em>MintParams</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">MintParams</span> <span class="ow">=</span> <span class="kt">MintParams</span>
    <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>We see two fields - <em>mpTokenName</em> and <em>mpAmount</em>. The idea is that if the <em>mpAmount</em> is positive, we should create tokens, and if it is negative, we should burn tokens.</p>
<p>The next step is to define the schema. Recall that one of the parameters of the <em>Contact</em> monad was the schema that defined the available actions that we can take.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">FreeSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;mint&quot;</span> <span class="kt">MintParams</span>
</pre></div>
</div>
<p>As always, we have <em>BlockchainActions</em> that give us access generic things like getting your own public key. And here, we have added an endpoint <em>mint</em> using the type-level operator
we have seen previously.</p>
<p>So, now we can look at the contract itself.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">MintParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">FreeSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
</pre></div>
</div>
<p>In the past, we have not gone into detail with the off-chain part of the contract. But, as we now know about the <em>Contract</em> monad from the last lecture, we are ready to go into it
in much more detail.</p>
<p>Recall that the <em>Contract</em> monad takes four type parameters.</p>
<p>The first is the writer monad which allows us to use a <em>tell</em> function. By leaving this parametric with a small
<em>w</em>, we indicate that we will not be making use of this parameter - we won’t <em>tell</em> any state.</p>
<p>The next parameter is the schema that we just discussed. As noted above, by using <em>FreeSchema</em> we have access to the regular block chain actions, as well as the <em>mint</em> endpoint.</p>
<p>The third parameter is the type of error message, and as we have seen, <em>Text</em> is usually a good choice.</p>
<p>Finally the last parameter is the return type, and our contract will just have the Unit return type.</p>
<p>Now the function body. As <em>Contact</em> is a monad, we can use <em>do</em> notation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="n">mp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">curSymbol</span> <span class="p">(</span><span class="n">mpTokenName</span> <span class="n">mp</span><span class="p">)</span> <span class="p">(</span><span class="n">mpAmount</span> <span class="n">mp</span><span class="p">)</span>
        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="n">policy</span>
        <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;forged %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>The first thing that we define is the value that we want to forge. For this we are using the <em>singleton</em> function that we tried out in the REPL earlier.</p>
<p>The arguments to the <em>singleton</em> function are the currency symbol that represents the hash of the minting policy, plus the token name and amount extracted from the <em>MintParams</em>.</p>
<p>We’ll skip the <em>lookups</em> assignment for the moment, and move onto the <em>tx</em> assignment.</p>
<p>One of the main purposes of the <em>Contract</em> monad is to construct and submit transactions. The path that the Plutus team has taken to do that is provide a way to specify
the constraints of the transaction you are defining. The Plutus libraries then take care of constructing the correct transaction (if possible). This is as opposed to being require to specify
all the inputs and outputs manually, which would be tedious as many requirements, such as sending change back to the sending wallet, are often the same.</p>
<p>These conditions all have names that start with <em>must</em>. There are things like <em>mustSpendScriptOutput</em>, <em>mustPayToPublicKey</em> and all sorts of conditions that can be put
on a condition.</p>
<p>In our example, we are using <em>mustForgeValue</em> and we pass it the previously-defined <em>val</em>. The result of forging the tokens specified by <em>val</em> is that they will end up
in our own wallet.</p>
<p>Once the conditions are defined, you then need to call a function to submit the transaction. There are a variety of such functions, but in this case, the appropriate one
is <em>submitTxConstraintsWith</em>.</p>
<p>These <em>submitTx</em> functions all take these declarative conditions that the transaction must satisfy, and then they try to construct a transaction that
fulfils those conditions. In our case, the only condition is that we want to forge the value.</p>
<p>So what must the <em>submitTxConstraintsWith</em> do in order to create a valid transaction? It must, for example balance the inputs and outputs. In this case, because we always
have transaction fees, we need an input that covers the transactions fees. So, to create the transaction, the function will look at our own UTxOs and find one, or more, that can
cover the transaction fees, and use them as an input to the transaction.</p>
<p>Furthermore, if we are forging value (if <em>mpAmount</em> is positive), that must go somewhere. In this case, <em>submitTxConstraintsWith</em>, will create an output that sends the
newly-minted value to our own wallet.</p>
<p>If, on the other hand, we were burning tokens (if <em>mpAmount</em> is negative), then those tokens must come from somewhere. In that case, the <em>submitTxConstraintsWith</em> function
would find an input in our own wallet from which to take the tokens.</p>
<p>The submit function can also fail. For example, if we want to pay someone, but we do not have enough funds in our wallet, it would fail. Or, if we are asking to burn tokens
that we don’t have, it will also fail. On failure, an exception would be thrown, with an error message of type <em>Text</em>.</p>
<p>Now, back to the <em>lookups</em>. In order to fulfil the conditions in the <em>mustForgeValue</em> function, and to construct the transaction, sometimes the library needs additional information.
In this case, in order to validate a transaction that forges value, the nodes that validate the transaction have to run the policy script.</p>
<p>But, the currency symbol is only the hash of the policy script. In order to run the script itself, it must be included in the transaction. Which means that, in the
construction step of the transaction, when the algorithm see the <em>mustForgeValue</em> constraint, it knows it has to attach the corresponding policy script to the transaction.</p>
<p>In order to tell the algorithm where the policy script is, we can give it hints, and these are the lookups. The are a variety of lookups that can be used - you can give
UTxOs, validator scripts, and, as we do here, you can give monetary policy scripts.</p>
<p>In our case, the only thing we need to supply as a lookup is the policy that we defined earlier in the script.</p>
<p>There are variants of <em>submitTxConstraintsWith</em> without the <em>with</em> that do not take lookups, as we have seen in previous lectures.</p>
<p>Finally, the <em>&#64;Void</em> on the line:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
</pre></div>
</div>
<p>Most of the constraint functions are geared towards using a specific validator script. Normally you have the situation that you are working on one specific smart contract.
And that specific smart contract has a datum and a redeemer type, and most of the constraints functions are parametric in the datum and redeemer type. In that case you
can directly use the datum type without first having to convert it to the Plutus <em>Datum</em> type.</p>
<p>But in this case, we are not making use of that. We don’t have any validator script. Which means that <em>submitTxConstraintsWith</em> wouldn’t know which type to use for datum and
redeemer because we don’t have them in this example. So, in that case we must tell the compiler which type to use. We don’t care, as there is no datum and redeemer, so we
use the <em>Void</em> type.</p>
<p>Also, in the same line, we see a monadic bind, so we know that this is a monadic action happening within the <em>Contract</em> monad. The reason for this is that, in order to lookup,
for example, our UTxOs, the <em>submitTxConstraintsWith</em> function must make use of the super power of the <em>Contract</em> monad, which is to access the <em>BlockchainActions</em>.</p>
<p>Now, <em>ledgerTx</em> is basically a handle to the transaction to we just submitted.</p>
<p>Then we wait for the transaction to be confirmed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
</pre></div>
</div>
<p>Currently, if the transaction validation fails, the await for confirmation line will block forever. However, this will soon change in an upcoming Plutus release to allow
us to listen for status changes, so you could detect if validation failed.</p>
<p>Once confirmed, we simply write a log message.</p>
<p>Finally, we need some more boilerplate to define our endpoint, to be able to actually execute the <em>mint</em> function, for example, in the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">FreeSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="n">mint&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">mint&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">mint</span>
</pre></div>
</div>
<p>We define another contract, <em>endpoints</em>, and that is always the name of the contract that the playground will run. So, if you want to test something in the playground, you
always need something called <em>endpoints</em>.</p>
<p>Here we just define a function called <em>mint’</em> and then recursively call <em>endpoints</em>, so once it has executed, it will be available to be executed again.</p>
<p>For <em>mint’</em> we must somehow get the <em>MintParams</em> and for that we use the <em>endpoint</em> function. The <em>endpoint</em> function blocks until someone provides a parameter. Once the
parameter of <em>MintParams</em> is provided, we use the monadic bind to call the <em>mint</em> function with those arguments.</p>
<p>The final two lines, as we have seen before, are just needed for the playground UI.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSchemaDefinitions</span> <span class="kt">&#39;&#39;FreeSchema</span>
<span class="nf">mkKnownCurrencies</span> <span class="kt">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="in-the-playground">
<h3><span class="section-number">1.5.4.3. </span>In The Playground<a class="headerlink" href="#in-the-playground" title="Permalink to this headline">¶</a></h3>
<p>We have set up a scenario where Wallet 1 mints 555 ABC tokens, and Wallet 2 mints 444 ABC tokens. Then, after waiting for 1 slot, Wallet 1 burns 222 ABC tokens. Finally, we
wait for 1 slot at the end.</p>
<div class="figure align-default">
<img alt="pioneer/img/week05__00007.png" src="pioneer/img/week05__00007.png" />
</div>
<p>Now, if we evaluate this, first we see the genesis transaction where the wallets are given 1000 lovelace each.</p>
<div class="figure align-default">
<img alt="pioneer/img/week05__00008.png" src="pioneer/img/week05__00008.png" />
</div>
<p>Next, we see two transactions at Slot 1. The first is the transaction from Wallet 2, where 444 ABC tokens are minted, and a 10 lovelace fee is paid. The UTxO to pay the fees
was automatically found by the function that created the transaction <em>submitTxConstraintsWith</em>, as discussed previously.</p>
<p>We see something here that we have not seen before - the <em>Forge</em> part of a transaction, where the native tokens are actually created. The box contains the currency symbol (the
policy hash) and the token name.</p>
<p>We also see the two outputs - once with the 990 lovelace change, and another with the newly-minted tokens. These outputs could, in fact, be combined, but here they are shown
as two separate UTxOs.</p>
<div class="figure align-default">
<img alt="pioneer/img/week05__00009.png" src="pioneer/img/week05__00009.png" />
</div>
<p>Then, we see the transaction from Wallet 1, where 555 ABC tokens are minted, and a 10 lovelace fee is paid.</p>
<div class="figure align-default">
<img alt="pioneer/img/week05__00010.png" src="pioneer/img/week05__00010.png" />
</div>
<p>Finally, we see the burning of 222 tokens by Wallet 1. Here we see that the algorithm did something slightly different. When it notices that a burn is taking place, it has
found the ABC tokens UTxO in Wallet 1 and used them as an input. We also note here that the output UTxO is combined, which, as we mentioned above, can be done instead of
using two output UTxOs.</p>
<div class="figure align-default">
<img alt="pioneer/img/week05__00011.png" src="pioneer/img/week05__00011.png" />
</div>
<p>And we can also view the final balances to double check that all went according to plan.</p>
<div class="figure align-default">
<img alt="pioneer/img/week05__00012.png" src="pioneer/img/week05__00012.png" />
</div>
<p>With our monetary policy, we can create arbitrary forging and burning transactions by any wallet. So, this is probably not a very good monetary policy. The purpose of a
token is to represent value, but if anybody at any time can mint new tokens, this token will not make much sense. There might be some exotic use case for it, but realistically
this policy is rather useless.</p>
</div>
<div class="section" id="testing-with-emulatortrace">
<h3><span class="section-number">1.5.4.4. </span>Testing with EmulatorTrace<a class="headerlink" href="#testing-with-emulatortrace" title="Permalink to this headline">¶</a></h3>
<p>Let’s also test this from the command line, rather than in the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">tn</span> <span class="ow">=</span> <span class="s">&quot;ABC&quot;</span>
    <span class="n">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h1</span> <span class="o">$</span> <span class="kt">MintParams</span>
        <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">=</span> <span class="n">tn</span>
        <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">=</span> <span class="mi">555</span>
        <span class="p">}</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h2</span> <span class="o">$</span> <span class="kt">MintParams</span>
        <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">=</span> <span class="n">tn</span>
        <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">=</span> <span class="mi">444</span>
        <span class="p">}</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h1</span> <span class="o">$</span> <span class="kt">MintParams</span>
        <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">=</span> <span class="n">tn</span>
        <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">=</span> <span class="o">-</span><span class="mi">222</span>
        <span class="p">}</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
</pre></div>
</div>
<p>If we run this in the REPL, we see what we saw in the playground, but instead on the console. It’s not as pretty, but it is quicker.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week05</span><span class="o">.</span><span class="n">Free</span><span class="o">&gt;</span> <span class="n">test</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">555.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">7</span><span class="n">c01d39fc031815eaf05d97709e4973a24dfa38e9dd68a4fd1ec92bb80cf76e4</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">444.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">6</span><span class="n">ba7eb4441992284e687d184080d4a8693e7b188fc45150d6e7ccd1243968f53</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">6</span><span class="n">ba7eb4441992284e687d184080d4a8693e7b188fc45150d6e7ccd1243968f53</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">7</span><span class="n">c01d39fc031815eaf05d97709e4973a24dfa38e9dd68a4fd1ec92bb80cf76e4</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,555)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,444)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="o">-</span><span class="mf">222.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">95</span><span class="n">d42e93ee41ab5bed7857b176be5a4e16602323eaacaa90f3bb807a9fd235c0</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">95</span><span class="n">d42e93ee41ab5bed7857b176be5a4e16602323eaacaa90f3bb807a9fd235c0</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,-222)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999980</span>
    <span class="p">{</span><span class="n">e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">333</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span><span class="n">e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">444</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999990</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-2-signed">
<h2><span class="section-number">1.5.5. </span>Example 2 - Signed<a class="headerlink" href="#example-2-signed" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3><span class="section-number">1.5.5.1. </span>On-chain<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at a more realistic example.</p>
<p>We’ll take a copy of the Free module, and call it Signed.</p>
<p>Probably the easiest example of a realistic minting policy is one where the minting and burning of tokens is restricted to transactions that are signed by a specific
public key hash. That is similar to a central bank, in fiat currencies.</p>
<p>This means that our policies is no longer without parameters. We need the public key hash.  In addition, we are going to need to look at the context, so we can’t just ignore it like last time.</p>
<p>We recall that <em>scriptContextTxInfo</em> from the context contains a list of all the signatories of the transaction. So, we can use this to see if the required signatory is one
of them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="n">pkh</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">txSignedBy</span> <span class="p">(</span><span class="n">scriptContextTxInfo</span> <span class="n">ctx</span><span class="p">)</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>The <em>txSignedBy</em> function is a convenient way of checking this. In previous examples, we used the <em>elem</em> function to check that it existed in the list.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger</span>
<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">txSignedBy</span>
<span class="nf">txSignedBy</span> <span class="ow">::</span> <span class="kt">TxInfo</span> <span class="ow">-&gt;</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Now, we need to update the part of the code that compiles our <em>mkPolicy</em> function into Plutus code. We will use the same techniques that we have used when writing
validator scripts. Specifically, we use the <em>applyCode</em> function to allows us to reference <em>pkh</em>, whose value is only known at runtime.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">policy</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">MonetaryPolicy</span>
<span class="nf">policy</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">mkMonetaryPolicyScript</span> <span class="o">$</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapMonetaryPolicy</span> <span class="o">.</span> <span class="n">mkPolicy</span> <span class="o">||</span><span class="p">])</span>
    <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>We also need to update the <em>curSymbol</em> function, as it now depends on the public key hash. It depends on it so that it can pass it to the <em>policy</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">curSymbol</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">CurrencySymbol</span>
<span class="nf">curSymbol</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="o">.</span> <span class="n">policy</span>
</pre></div>
</div>
<p>Note, the second line here, the body, is a shorter way of writing:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">curSymbol</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>This is clear, when you consider something like the following, where <em>timesSix</em> is just another way of writing the results of combining the functions <em>timesTwo</em> and <em>timesThree</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">timesSix</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">timesTwo</span> <span class="o">$</span> <span class="n">timesThree</span> <span class="n">x</span>
</pre></div>
</div>
<p>is exactly the same as…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">timesSix</span> <span class="ow">=</span> <span class="n">timesTwo</span> <span class="o">.</span> <span class="n">timesThree</span>
</pre></div>
</div>
<p>This process of simplification is called ETA reduction, so if you ever see your IDE hinting that you can ETA reduce, this is what it’s talking about.</p>
<p>Now for the off-chain code.</p>
</div>
<div class="section" id="id6">
<h3><span class="section-number">1.5.5.2. </span>Off-chain<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>We don’t need to extend the <em>MintParams</em> data type for the off-chain code. A wallet that wants to mint or burn a currency can sign with its own public key hash. This is the only
signature that a wallet can provide, and it has the ability to look it up for itself.</p>
<p>We will make a change to the name of the schema for clarity. We’ll also, of course, update this name wherever it appears in the contract script.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">SignedSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;mint&quot;</span> <span class="kt">MintParams</span>
</pre></div>
</div>
<p>Now, for the <em>mint</em> function, we need to pass the public key hash to the <em>curSymbol</em> function. Getting hold of the public key is something that is provided by
<em>BlockchainActions</em>. So, we will get this from <em>Contract</em> and apply the <em>pubKeyHash</em> function to it.</p>
<p>One way to do this would be</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pk</span> <span class="ow">&lt;-</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
<span class="kr">let</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="n">pk</span>
</pre></div>
</div>
<p>However, as <em>Contract</em> is a monad, and therefore an instance of <em>Functor</em>, we have the <em>fmap</em> function available, which will turn a <em>Contract a</em> into a <em>Contract b</em>. In
this case we can take advantage of that by using the <em>pubKeyHash</em> function as the (a -&gt; b) function of fmap and this will turn <em>Contract pubKey</em> into <em>Contract pubKeyHash</em>,
and then we can grab this value instead.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="n">pubKeyHash</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
</pre></div>
</div>
<p>There is one more thing we can do to improve this. There is an operator for <em>fmap</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
</pre></div>
</div>
<p>Ok, now let’s update the lookups line to pass in the public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>And now we have finished modifying the <em>mint</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">MintParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">SignedSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">mp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="n">curSymbol</span> <span class="n">pkh</span><span class="p">)</span> <span class="p">(</span><span class="n">mpTokenName</span> <span class="n">mp</span><span class="p">)</span> <span class="p">(</span><span class="n">mpAmount</span> <span class="n">mp</span><span class="p">)</span>
        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">pkh</span>
        <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;forged %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>So, let’s try it out using the <em>test</em> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Ledger</span> <span class="n">Week05</span><span class="o">.</span><span class="n">Signed</span><span class="o">&gt;</span> <span class="n">Week05</span><span class="o">.</span><span class="n">Signed</span><span class="o">.</span><span class="n">test</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">555.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mf">20289e7</span><span class="n">b1bb6692b35e24e0f9293327f9169d843ae0ea431186fdefae6092a44</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">444.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">1</span><span class="n">c367cf81dd2da478abb96235ee16facf9f7d47374c9455d5fdd516aaf04d0c2</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">1</span><span class="n">c367cf81dd2da478abb96235ee16facf9f7d47374c9455d5fdd516aaf04d0c2</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mf">20289e7</span><span class="n">b1bb6692b35e24e0f9293327f9169d843ae0ea431186fdefae6092a44</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(7183b1cf81e44b26c558ddf442c4a7161a1b504b61136a8773dc2e4960323521,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,555)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(2a964fa6314803cf1b61165aeb1d758e355aae9480a29e282b58e76983f101ba,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,444)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="o">-</span><span class="mf">222.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mf">6e20</span><span class="n">d243447d7f49de509ef6b52c6d947769d95a6451c9cda53e42a0ba02fa69</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mf">6e20</span><span class="n">d243447d7f49de509ef6b52c6d947769d95a6451c9cda53e42a0ba02fa69</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(7183b1cf81e44b26c558ddf442c4a7161a1b504b61136a8773dc2e4960323521,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,-222)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999980</span>
    <span class="p">{</span><span class="mi">7183</span><span class="n">b1cf81e44b26c558ddf442c4a7161a1b504b61136a8773dc2e4960323521</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">333</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span><span class="mi">2</span><span class="n">a964fa6314803cf1b61165aeb1d758e355aae9480a29e282b58e76983f101ba</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">444</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999990</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>This looks very similar to before, but this time, notice that, while the token names are the same, the currency symbols are different for each wallet.</p>
</div>
</div>
<div class="section" id="nfts">
<h2><span class="section-number">1.5.6. </span>NFTs<a class="headerlink" href="#nfts" title="Permalink to this headline">¶</a></h2>
<p>Let’s now talk about NFTs - Non-Fungible Tokens. NFTs are tokens that have a quantity of exactly 1.</p>
<p>The examples of native tokens that we have studied so far are definitely not NFTs because we could easily mint as many as we wanted. This is true not only in the first
example where anyone could mint tokens, but also in the second example, where, so long as you are the owner of the correct public key hash, you could mint unlimited tokens
for the associated currency symbol and token name.</p>
<p>In order to produce an NFT, perhaps the first naive idea would be to look at forge field in the policy and enforce a policy where the amount is one.</p>
<p>But that wouldn’t help us. That would only mean that during one transaction you can mint only one token. But nobody could stop us from submitting as many of those transactions
as we like.</p>
<p>The second option is actually in use already on the Cardano blockchain. NFTs have been available since the Mary fork, which predates Plutus, and to do this, they are implemented
using deadlines.</p>
<p>We saw in previous examples how time can be incorporated in validation scripts, and the same can be done in policy scripts.</p>
<p>The idea here is to only allow minting before a given deadline has passed. Using this method, if you want to mint an NFT, you mint one token before the deadline, then allow the
deadline to pass. This guarantees that, after the deadline, no new tokens will ever be minted.</p>
<p>But, in order to check that you only minted one token before the deadline, you need something like a blockchain explorer. So, in this sense, they are not true NFTs, insofar as
the currency symbol itself guarantees that they are unique.</p>
<p>Using Plutus, it is possible to mint true NFTs. If you know the policy script that corresponds to the currency symbol, you can be sure that only one token is in existence
without having to resort to something like a blockchain explorer.</p>
<p>And, thinking about how to do that, there must be a way to prevent there ever being more than one minting transaction for the token in question. Whatever you write in your
policy script, it must only return true for one transaction, so that it is impossible to do the same again in another transaction.</p>
<p>At first, this sounds impossible. Why can’t you just run the same transaction again and have validation succeed again? Even considering deadlines, what stops a second transaction
in the same slot from passing validation?</p>
<p>The key here is that we need something unique. Something that can only exist in one transaction and never again. This is an important trick, and it is something to keep in mind.</p>
<p>The idea is to use UTxOs. A UTxO is unique. A UTxO is the output of a transaction and its unique identifier is the transaction ID and its index in the list of outputs from that transaction.</p>
<p>The reason that transactions are unique is a bit subtle. They would not necessarily be unique if it were not for fees. Without fees, you could have a transaction that has
zero inputs and only with outputs without value. Such a transaction would have the exact some hash each time it was run, and therefore the exact same transaction id. But with
fees, such a transaction cannot exist, as you always need an input that provides fees, and the fees can never come from the same UTxO as input.</p>
<p>So, to create an NFT, we are going to provide a specific UTxO as a parameter to the minting policy and, in the policy, we are going to check that the transaction consumes this
UTxO. And, as we have just noted, once that UTxO is consumed, it can never be consumed again.</p>
<div class="section" id="example-3-nft">
<h3><span class="section-number">1.5.6.1. </span>Example 3 - NFT<a class="headerlink" href="#example-3-nft" title="Permalink to this headline">¶</a></h3>
<p>We start with a copy of the previous example, <em>Signed</em> and we will call it <em>NFT</em>.</p>
<p>So let’s turn the signed policy into a true NFT policy.</p>
<div class="section" id="id7">
<h4><span class="section-number">1.5.6.1.1. </span>On-chain<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>First, we will no longer use the public key hash as an input, as if we were a central bank, but will use a UTxO instead. So, what type corresponds to a UTxO?</p>
<p>Let’s look in the REPL and remind ourselves about <em>TxInfo</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger</span>
<span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Ledger</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">TxInfo</span>
<span class="kr">type</span> <span class="kt">TxInfo</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">TxInfo</span>
    <span class="ow">=</span> <span class="kt">TxInfo</span> <span class="p">{</span><span class="n">txInfoInputs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">],</span>
                <span class="n">txInfoInputsFees</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">],</span>
                <span class="n">txInfoOutputs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">],</span>
                <span class="n">txInfoFee</span> <span class="ow">::</span> <span class="kt">Value</span><span class="p">,</span>
                <span class="n">txInfoForge</span> <span class="ow">::</span> <span class="kt">Value</span><span class="p">,</span>
                <span class="n">txInfoDCert</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">DCert</span><span class="o">.</span><span class="kt">DCert</span><span class="p">],</span>
                <span class="n">txInfoWdrl</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Credential</span><span class="o">.</span><span class="kt">StakingCredential</span><span class="p">,</span>
                                <span class="kt">Integer</span><span class="p">)],</span>
                <span class="n">txInfoValidRange</span> <span class="ow">::</span> <span class="kt">SlotRange</span><span class="p">,</span>
                <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">],</span>
                <span class="n">txInfoData</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)],</span>
                <span class="n">txInfoId</span> <span class="ow">::</span> <span class="kt">TxId</span><span class="p">}</span>
</pre></div>
</div>
<p>We we are interested in this field:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">txInfoInputs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s look at the type <em>TxInInfo</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Ledger</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">TxInInfo</span>
<span class="kr">type</span> <span class="kt">TxInInfo</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">TxInInfo</span>
    <span class="ow">=</span> <span class="kt">TxInInfo</span> <span class="p">{</span><span class="n">txInInfoOutRef</span> <span class="ow">::</span> <span class="kt">TxOutRef</span><span class="p">,</span> <span class="n">txInInfoResolved</span> <span class="ow">::</span> <span class="kt">TxOut</span><span class="p">}</span>
</pre></div>
</div>
<p>We see that it is a record with two fields. The first is of type <em>TxOutRef</em>, and this references a UTxO, which is exactly what we need. So, let’s use it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Now, we are ready to write the logic. We must check that the script contains the specified UTxO as input. We will delegate this to a helper function. This function, which we
will call <em>hasUTxO</em> uses the <em>any</em> function, which is a standard Prelude function, but also has a Plutus version, for reasons we have addressed previously.</p>
<p>The <em>any</em> function takes a predicate (a function that returns a boolean) and applies it to an input collection of the type <em>Foldable</em> (a list, for example), and will
return true if the predicate is true for any of the inputs.</p>
<p>Here, we use the <em>any</em> function to see if any of the <em>txInInfoOutRef*s from the *txInfoInputs</em> from the <em>TxInfo</em> field of the context matches the UTxO for which
we are validating.</p>
<p>For clarity, we will also provide a helper function to get the list of <em>txInfoInputs</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
<span class="nf">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

<span class="nf">hasUTxO</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">hasUTxO</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">txInInfoOutRef</span> <span class="n">i</span> <span class="o">==</span> <span class="n">oref</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
</pre></div>
</div>
<p>So, do we have enough to finish writing our policy? Let’s see what we have.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="n">oref</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;UTxO not consumed&quot;</span> <span class="n">hasUTxO</span>
<span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">hasUTxO</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">hasUTxO</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">txInInfoOutRef</span> <span class="n">i</span> <span class="o">==</span> <span class="n">oref</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
</pre></div>
</div>
<p>Right now, we have a policy that can only mint or burn once. But, of course, in that single transaction, we can still mint as many tokens as we like.</p>
<p>Now, we think about what we actually want. Maybe we want a policy that allows us to mint just one token for the currency symbol. Or perhaps, we would like to be able
to mint many NFTs at once, each with a different token name.</p>
<p>It’s up to us. But, let’s say we go with the first option. We just want to mint one token.</p>
<p>So, it makes sense to pass the token name as a parameter.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>And we need a second condition that checks that we mint just this one specific coin.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="n">oref</span> <span class="n">tn</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;UTxO not consumed&quot;</span>   <span class="n">hasUTxO</span>           <span class="o">&amp;&amp;</span>
                       <span class="n">traceIfFalse</span> <span class="s">&quot;wrong amount minted&quot;</span> <span class="n">checkMintedAmount</span>
</pre></div>
</div>
<p>And, of course, we need to implement <em>checkMintedAmount</em>.</p>
<p>First of all, we need access to the forged value. We get this from the field <em>txInfoForge</em> of <em>TxInfo</em>.</p>
<p>How do we check that this forged value is exactly 1 token of the name that we require? There are several approaches, but one is to use the <em>flattenValue</em> function which,
we will recall, returns a list of triples of currency symbol, token name and value. We can then check that the output of <em>flattenValue</em> is exactly one triple that matches
the symbol, token and value that we expect.</p>
<p>This would look something like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="p">[(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>But we still have a problem to solve - we need to know what the currency symbol is. Given that the currency symbol is a hash of the policy, it seems as if we have a chicken
and egg problem.</p>
<p>As luck would have it, there is a function called <em>ownCurrencySymbol</em> which exists to solve exactly this problem.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="p">[(</span><span class="n">ownCurrencySymbol</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>As it happens, this won’t compile, because <em>Eq</em> is not defined for triples in the Plutus Prelude. So, we can work around this with a case statement and some pattern matching.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
        <span class="p">[(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tn&#39;</span><span class="p">,</span> <span class="n">amt</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">cs</span>  <span class="o">==</span> <span class="n">ownCurrencySymbol</span> <span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">tn&#39;</span> <span class="o">==</span> <span class="n">tn</span> <span class="o">&amp;&amp;</span> <span class="n">amt</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="kr">_</span>                <span class="ow">-&gt;</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Now, we can complete our policy.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="n">oref</span> <span class="n">tn</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;UTxO not consumed&quot;</span>   <span class="n">hasUTxO</span>           <span class="o">&amp;&amp;</span>
                    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong amount minted&quot;</span> <span class="n">checkMintedAmount</span>
<span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">hasUTxO</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">hasUTxO</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">txInInfoOutRef</span> <span class="n">i</span> <span class="o">==</span> <span class="n">oref</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>

    <span class="n">checkMintedAmount</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">checkMintedAmount</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
        <span class="p">[(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tn&#39;</span><span class="p">,</span> <span class="n">amt</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">cs</span>  <span class="o">==</span> <span class="n">ownCurrencySymbol</span> <span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">tn&#39;</span> <span class="o">==</span> <span class="n">tn</span> <span class="o">&amp;&amp;</span> <span class="n">amt</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="kr">_</span>                <span class="ow">-&gt;</span> <span class="kt">False</span>
</pre></div>
</div>
<p>And we will update our boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">policy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">MonetaryPolicy</span>
<span class="nf">policy</span> <span class="n">oref</span> <span class="n">tn</span> <span class="ow">=</span> <span class="n">mkMonetaryPolicyScript</span> <span class="o">$</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="nf">\</span><span class="n">oref&#39;</span> <span class="n">tn&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapMonetaryPolicy</span> <span class="o">$</span> <span class="n">mkPolicy</span> <span class="n">oref&#39;</span> <span class="n">tn&#39;</span> <span class="o">||</span><span class="p">])</span>
    <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">oref</span>
    <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">tn</span>

<span class="nf">curSymbol</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">CurrencySymbol</span>
<span class="nf">curSymbol</span> <span class="n">oref</span> <span class="n">tn</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span>
</pre></div>
</div>
<p>That completes the on-chain part.</p>
</div>
<div class="section" id="id8">
<h4><span class="section-number">1.5.6.1.2. </span>Off-chain<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>We need to think about the inputs we need for this transaction.</p>
<p>First, we need a UTxO, and we need to provide one of our own. However, we don’t need to pass that in because we can look it up directly.</p>
<p>We only need to provide the token name, so we no longer need a special data type, so we can delete <em>MintParams</em> and just use <em>TokenName</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">NFTSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;mint&quot;</span> <span class="kt">TokenName</span>
</pre></div>
</div>
<p>Now we will write the off-chain <em>mint</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">NFTSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">tn</span> <span class="ow">=</span> <span class="kr">do</span>
</pre></div>
</div>
<p>The first thing to do is to get the list of UTxOs that belong to us.</p>
<p>The <em>Plutus.Contract</em> module gives us the <em>utxoAt</em> function, which has the signature below, and looks up all the UTxOs at a given address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">utxoAt</span> <span class="ow">::</span> <span class="kt">Address</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span>
</pre></div>
</div>
<p>An <em>AddressMap</em> is a map where the keys are <a href="#id9"><span class="problematic" id="id10">*</span></a>TxOutRef*s and the values are <a href="#id11"><span class="problematic" id="id12">*</span></a>TxOutTx*s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span>
<span class="kr">type</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">type</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Internal</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">TxOutRef</span> <span class="kt">TxOutTx</span>
</pre></div>
</div>
<p>If we pass this function our own address then the keys of this map will be the UTxOs that belong to us. It doesn’t matter which one of these we pick. So long as we own
at least one UTxO, we are good.</p>
<p>The first step is to find our own address. We know how to find our own public key, and, given this, we can use the function <em>pubKeyAddress</em> to get our address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pubKeyAddress</span> <span class="ow">::</span> <span class="kt">PubKey</span> <span class="ow">-&gt;</span> <span class="n">address</span>
</pre></div>
</div>
<p>Let’s get them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>

<span class="nf">mint</span> <span class="ow">::</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">NFTSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">tn</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pk</span>    <span class="ow">&lt;-</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">pubKeyAddress</span> <span class="n">pk</span><span class="p">)</span>
</pre></div>
</div>
<p>We only need one - we don’t care which one. We will write a case statement that will either log an error if we have no UTxO available, or will use the first
UTxO in the list continue with the forging code.</p>
<p>The first change is to specify <em>1</em> instead of the <em>mpAmount</em>, as we want exactly 1 coin minted.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">keys</span> <span class="n">utxos</span> <span class="kr">of</span>
    <span class="kt">[]</span>       <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logError</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no utxo found&quot;</span>
    <span class="n">oref</span> <span class="kt">:</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="n">curSymbol</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="n">tn</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Secondly, we add the token name argument to the lookups.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span>
</pre></div>
</div>
<p>Thirdly, we now need an additional constraint which insists that our specific UTxO is consumed.</p>
<p>There’s a function for that.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger.Constraints</span>
<span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">mustSpendPubKeyOutput</span>
<span class="nf">mustSpendPubKeyOutput</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TxConstraints</span> <span class="n">i</span> <span class="n">o</span>
</pre></div>
</div>
<p>How do we combine the constraints of <em>mustForgeValue</em> and <em>mustSpendPubKeyOutput</em>? <em>Contraints</em> don’t form a <em>Monoid</em>, but they do form a <em>Semigroup</em>, and the difference
is just that in <em>Semigroup</em> we don’t have <em>mempty</em>, the neutral element. We can still combine them with the <em>&lt;&gt;</em> operator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendPubKeyOutput</span> <span class="n">oref</span>
</pre></div>
</div>
<p>Now, we need to provide a lookup that gives access to where the UTxO <em>oref</em> can be found. For that we can use</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="ow">::</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Internal</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">TxOutRef</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">ScriptLookups</span> <span class="n">a</span>
</pre></div>
</div>
<p>So, let’s update our lookups.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="p">(</span><span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>
</pre></div>
</div>
<p>Something we need to do before this script will run is to import the operator <em>&lt;&gt;</em> for <em>Semigroup</em> from the standard Haskell Prelude, as we have explicitly excluded it from
the <em>PlutusTx.Prelude</em> module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Semigroup</span> <span class="p">(</span><span class="o">..</span><span class="p">))</span>
</pre></div>
</div>
<p>Let’s take a look at the whole function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">NFTSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">tn</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pk</span>    <span class="ow">&lt;-</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">pubKeyAddress</span> <span class="n">pk</span><span class="p">)</span>
    <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">keys</span> <span class="n">utxos</span> <span class="kr">of</span>
        <span class="kt">[]</span>       <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logError</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no utxo found&quot;</span>
        <span class="n">oref</span> <span class="kt">:</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="n">curSymbol</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="n">tn</span> <span class="mi">1</span>
                <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="p">(</span><span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendPubKeyOutput</span> <span class="n">oref</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;forged %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>For the test script.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">tn</span> <span class="ow">=</span> <span class="s">&quot;ABC&quot;</span>
    <span class="n">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h1</span> <span class="n">tn</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h2</span> <span class="n">tn</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Let’s test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Ledger</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Constraints</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">.</span><span class="n">test</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;mint&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ABC&quot;</span><span class="p">)]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">691</span><span class="n">a5c0725ac09f79c8c45c899d732d26460d18c4c18167be71d55319bcd5669</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;mint&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ABC&quot;</span><span class="p">)]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="n">e53519b17bf7d11a148ce17ac0305330f138a684530ba08b1c57f714672b8c68</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">e53519b17bf7d11a148ce17ac0305330f138a684530ba08b1c57f714672b8c68</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">691</span><span class="n">a5c0725ac09f79c8c45c899d732d26460d18c4c18167be71d55319bcd5669</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;forged Value (Map [(9d969e597d45fcd1732ce255e12a97599e883f924b4565fc3a2407bc08d34524,Map [(</span><span class="se">\&quot;</span><span class="s">ABC</span><span class="se">\&quot;</span><span class="s">,1)])])&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;forged Value (Map [(913f220c3b1ba49531bae2fedd9edb138a8b360e7e605bfcf4ff3f2045433069,Map [(</span><span class="se">\&quot;</span><span class="s">ABC</span><span class="se">\&quot;</span><span class="s">,1)])])&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{</span><span class="mi">9</span><span class="n">d969e597d45fcd1732ce255e12a97599e883f924b4565fc3a2407bc08d34524</span><span class="p">,</span> <span class="s">&quot;ABC&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">99999990</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{</span><span class="mi">913</span><span class="n">f220c3b1ba49531bae2fedd9edb138a8b360e7e605bfcf4ff3f2045433069</span><span class="p">,</span> <span class="s">&quot;ABC&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">99999990</span>
<span class="o">...</span>
<span class="kt">Wallet</span> <span class="mi">10</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>And now we have minted some NFTs.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week6.html" class="btn btn-neutral float-right" title="1.6. Week 06 - Oracles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="week4.html" class="btn btn-neutral float-left" title="1.4. Week 04 - Monads" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1.8. Week 08 - Property Based Testing &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1.9. Week 09 - Marlowe" href="week9.html" />
    <link rel="prev" title="1.7. Week 07 - State Machines" href="week7.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../plutus_pioneer_program.html">1. Plutus Pioneer Program</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="week1.html">1.1. Week 01 - English Auction</a></li>
<li class="toctree-l2"><a class="reference internal" href="week2.html">1.2. Week 02 - Validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="week3.html">1.3. Week 03 - Script Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="week4.html">1.4. Week 04 - Monads</a></li>
<li class="toctree-l2"><a class="reference internal" href="week5.html">1.5. Week 05 - Native Tokens</a></li>
<li class="toctree-l2"><a class="reference internal" href="week6.html">1.6. Week 06 - Oracles</a></li>
<li class="toctree-l2"><a class="reference internal" href="week7.html">1.7. Week 07 - State Machines</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">1.8. Week 08 - Property Based Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#token-sale">1.8.1. Token Sale</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#on-chain-code">1.8.1.1. On-chain code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#off-chain-code">1.8.1.2. Off-chain code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testing">1.8.1.3. Testing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unit-testing">1.8.2. Unit Testing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tasty">1.8.2.1. Tasty</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#optics-and-lenses">1.8.3. Optics and Lenses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#property-based-testing">1.8.4. Property Based Testing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quickcheck">1.8.4.1. QuickCheck</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week9.html">1.9. Week 09 - Marlowe</a></li>
<li class="toctree-l2"><a class="reference internal" href="week10.html">1.10. Week 10 - Uniswap</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../alonzo_white.html">2. Alonzo Walkthrough</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../plutus_pioneer_program.html"><span class="section-number">1. </span>Plutus Pioneer Program</a> &raquo;</li>
        
      <li><span class="section-number">1.8. </span>Week 08 - Property Based Testing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/pioneer/week8.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-08-property-based-testing">
<h1><span class="section-number">1.8. </span>Week 08 - Property Based Testing<a class="headerlink" href="#week-08-property-based-testing" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://youtu.be/JMRwkMgaBOg">Lecture
#8</a>.</p>
<p>In this lecture we cover another state machine example, automatic testing using emulator traces, optics, and property-based testing.</p>
<p>This week we were using Plutus commit ae35c4b8fe66dd626679bd2951bd72190e09a123, the same commit as we used in the last lecture.</p>
</div>
<div class="section" id="token-sale">
<h2><span class="section-number">1.8.1. </span>Token Sale<a class="headerlink" href="#token-sale" title="Permalink to this headline">¶</a></h2>
<p>In the last lecture we looked at state machines, and saw how they often allow us to write much less code to express the logic of a smart contract, partly because
there is a lot of sharing between on-chain and off-chain code and partly because a lot of boilerplate is encapsulated in the state machine machinery.</p>
<p>In this lecture we will see another example using a state machine, because the concept is very important. We will also take a look at testing.
First we will look at the code, then we will explore various ways to go about testing.</p>
<p>The example we will use is a contract that allows somebody to sell tokens. The idea is that someone call lock some tokens in a contract, set a price, and then
other people can buy them.</p>
<p>To begin, the seller starts with an NFT. It can be an arbitrary NFT and it will just be used, as before, to identify the correct UTxO that contains the contract state.</p>
<p>The first step is to lock the NFT at the script address of the smart contract that we are about to write. We’ll call that contract <em>TS</em> for Token Sale. As a datum, we will
use a simple integer, which will represent the price of the token we are selling, and this will start off as zero.</p>
<div class="figure align-default">
<img alt="pioneer/img/week08__00001.png" src="pioneer/img/week08__00001.png" />
</div>
<p>There will be several operations that the seller can do. One of those will be setting the price to a different value. In order to do that the seller will submit
a transaction which has the current UTxO as input and the updated UTxO as output, where the datum has been changed to a different price per token.</p>
<div class="figure align-default">
<img alt="pioneer/img/week08__00002.png" src="pioneer/img/week08__00002.png" />
</div>
<p>Another thing that the seller can do is to lock some tokens in the contract. In order to do that they have to create another transaction which has as input the UTxO of
the contract and a UTxO containing some tokens and, as output, the updated UTxO at the contract address which now contains the provided tokens.</p>
<div class="figure align-default">
<img alt="pioneer/img/week08__00003.png" src="pioneer/img/week08__00003.png" />
</div>
<p>In this example, the seller provides five tokens to the contract.</p>
<p>In order to buy tokens, there needs to be a transaction created by the buyer. This transaction has as input the UTxO sitting at the TS script address,
and the buying price in Ada.</p>
<p>So, if a buyer wants to buy two tokens, they will create a transaction that has, as input, 12 Ada, and the UTxO at the script address. Then, two outputs. One
the updated contract state where now the tokens are taken out and the Ada has been added, and one output going to the buyer with the tokens that they have just
bought.</p>
<div class="figure align-default">
<img alt="pioneer/img/week08__00004.png" src="pioneer/img/week08__00004.png" />
</div>
<p>Finally, there must be a way for the seller to retrieve tokens and Ada. In this example if, after the sale, the seller wants to retrieve all the Ada and one token, they
would create a transaction that, again, has the script UTxO as input, and, as output, the updated script UTxO with the reduced balances, and one to themselves with the
retrieved funds.</p>
<p>The diagram just shows one scenario, but these operations can be performed in any order - tokens can be added, the price can be changed, tokens can be bought, and so on,
in an arbitrary order.</p>
<div class="section" id="on-chain-code">
<h3><span class="section-number">1.8.1.1. </span>On-chain code<a class="headerlink" href="#on-chain-code" title="Permalink to this headline">¶</a></h3>
<p>This week’s first example is implemented in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week08.TokenSale</span>
</pre></div>
</div>
<p>Let’s first look at the type that we will use as the parameter that we will use for the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TokenSale</span> <span class="ow">=</span> <span class="kt">TokenSale</span>
    <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>This has three fields - the seller’s public key has, the token being sold, and the NFT used to identify the UTxO.</p>
<p>For the redeemer, we provide exactly the operations we saw in the diagram</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TSRedeemer</span> <span class="ow">=</span>
      <span class="kt">SetPrice</span> <span class="kt">Integer</span>         <span class="c1">-- the price</span>
    <span class="o">|</span> <span class="kt">AddTokens</span> <span class="kt">Integer</span>        <span class="c1">-- the number of tokens to add</span>
    <span class="o">|</span> <span class="kt">BuyTokens</span> <span class="kt">Integer</span>        <span class="c1">-- the number of tokens to buy</span>
    <span class="o">|</span> <span class="kt">Withdraw</span> <span class="kt">Integer</span> <span class="kt">Integer</span> <span class="c1">-- first argument is the number of tokens, the second is the number of lovelace</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Again we have the helper function that we have used in previous examples</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>Now, we get to the <em>transition</em> function of the state machine. We see the <em>TokenSale</em> parameter which holds the state machines configuration values, the <em>State</em>
object with an <em>Integer</em> value to represent the price of the token, then the redeemer <em>TsRedeemer</em>. Again, we return a <em>Maybe</em>, which will be <em>Nothing</em> if the
corresponding transition is illegal, or, if it is legal, a <em>Just</em> containing constraints and the new state.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TSRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="nf">transition</span> <span class="n">ts</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
</pre></div>
</div>
<p>If the <em>SetPrice</em> redeemer is provided, then we only consider it to be legal if the price is not negative. We then return a <em>Just</em> with the constraint that the
transaction must be signed by the token seller, and with the new state. The new state will be the new price <em>p</em>, and the <em>Value</em> in the contract
remains the same, except for one thing.</p>
<p>It is a little unfortunate, but there is a discrepancy between the <em>v</em> on the left and the <em>v</em> on the right. On the left it does not contain the NFT, but
on the right it does not. So, even though we want to say that we don’t want the value changed, in fact we have to remove the NFT, because the Plutus libraries will
add it again. This is perhaps not an ideal design, but that is how it currently is.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kt">SetPrice</span> <span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">tsSeller</span> <span class="n">ts</span><span class="p">)</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span> <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>We use a helper function to reference the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nft</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
<span class="nf">nft</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsNFT</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
<p>When adding tokens, we could check that the seller has signed the transaction, but this contract would be provided by the seller, and the seller doesn’t mind if someone
wants to give them a free gift! Therefore, once we have the <em>AddTokens</em> redeemer and <em>n</em> is greater than zero, we are happy to return the
new state without constraints.</p>
<p>The state that we return is untouched, except for the unfortunate trick we need to do with the NFT, and the addition of the new tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">AddTokens</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                      <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="n">n</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>For the <em>BuyTokens</em> redeemer, again we check the number of tokens is positive, and again we don’t need any constraints, because anybody can buy tokens.</p>
<p>For the new state, we don’t touch the price. We again correct for the NFT. Then we subtract the tokens that were bought, and we add the lovelace that were paid for them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">BuyTokens</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                      <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">negate</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                      <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>Finally, for <em>WithDraw</em>, we insist that the token amount and the lovelace amount are both nonnegative. This time we again add a constraint that the seller must sign
the transaction. We modify the state in a similar way to the way we did for the <em>BuyTokens</em> redeemer, but this time we adjust the token and lovelace amounts according
to how much has been withdrawn.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">Withdraw</span> <span class="n">n</span> <span class="n">l</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">tsSeller</span> <span class="n">ts</span><span class="p">)</span>
                                                <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                                  <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                                  <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                                  <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">negate</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                                  <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">negate</span> <span class="n">l</span><span class="p">)</span>
                                                <span class="p">)</span>
</pre></div>
</div>
<p>All other state transitions are illegal.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>In this example we are able to construct our state machine more simply that we could in the previous lecture. This is because, in the previous lecture we had one
condition that could not be expressed in the regular constraints.</p>
<p>In these situations, there is a helper function called <em>mkStateMachine</em> that takes three arguments. The first one is the state token, the second is the transition
function. The last one is to indicate which states are final. In this case, there is no final state. Once this token sale has been setup, it will always be there.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tsStateMachine</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">StateMachine</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>
<span class="nf">tsStateMachine</span> <span class="n">ts</span> <span class="ow">=</span> <span class="n">mkStateMachine</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">$</span> <span class="n">tsNFT</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">transition</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">const</span> <span class="kt">False</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now use the usual boilerplate to turn it into a Plutus smart contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TS</span> <span class="ow">=</span> <span class="kt">StateMachine</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>

<span class="nf">tsInst</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">TS</span>
<span class="nf">tsInst</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">TS</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkTSValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">ts</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">Integer</span> <span class="o">@</span><span class="kt">TSRedeemer</span>

<span class="nf">tsValidator</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">tsValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">tsInst</span>

<span class="nf">tsAddress</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">tsAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">tsValidator</span>

<span class="nf">tsClient</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">StateMachineClient</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>
<span class="nf">tsClient</span> <span class="n">ts</span> <span class="ow">=</span> <span class="n">mkStateMachineClient</span> <span class="o">$</span> <span class="kt">StateMachineInstance</span> <span class="p">(</span><span class="n">tsStateMachine</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">tsInst</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two helper functions to convert specialised error types to <em>Text</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapErrorC</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">C</span><span class="o">.</span><span class="kt">CurrencyError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapErrorC</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>

<span class="nf">mapErrorSM</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">SMContractError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapErrorSM</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>
</pre></div>
</div>
</div>
<div class="section" id="off-chain-code">
<h3><span class="section-number">1.8.1.2. </span>Off-chain code<a class="headerlink" href="#off-chain-code" title="Permalink to this headline">¶</a></h3>
<p>For the off-chain code, we start by defining a constant for the token name of the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nftName</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">nftName</span> <span class="ow">=</span> <span class="s">&quot;NFT&quot;</span>
</pre></div>
</div>
<p>The first contract we define is to start the token sale. This contract is designed to be invoked by the seller.</p>
<p>This first argument is a <em>Maybe CurrencySymbol</em>. The idea here is that if you pass in <em>Nothing</em>, the contract will mint a new NFT. Alternatively, you can provide a
<em>Just CurrencySymbol</em> if the token already exists. We have done it this way mainly to make testing easier.</p>
<p>The <em>AssetClass</em> argument is the token the seller wants to trade.</p>
<p>For the return type, we are using the writer monad type with the <em>Last</em> type. The ideas is that once the token sale has been setup, it will get written here so that other
contracts are able to discover it. In addition, we return the created token sale.</p>
<p>To begin, we lookup the seller’s public key hash. We then need to get hold of the NFT. So, we determine if we need to mint the NFT, and, if we do, we mint it, otherwise we just use the one that was
passed into the function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startTS</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">AssetClass</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">TokenSale</span>
<span class="nf">startTS</span> <span class="n">mcs</span> <span class="n">token</span> <span class="ow">=</span> <span class="kr">do</span>

    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">cs</span>  <span class="ow">&lt;-</span> <span class="kr">case</span> <span class="n">mcs</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>  <span class="ow">-&gt;</span> <span class="kt">C</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="o">&lt;$&gt;</span> <span class="n">mapErrorC</span> <span class="p">(</span><span class="kt">C</span><span class="o">.</span><span class="n">forgeContract</span> <span class="n">pkh</span> <span class="p">[(</span><span class="n">nftName</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="kt">Just</span> <span class="n">cs&#39;</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">cs&#39;</span>
</pre></div>
</div>
<p>And now we can define the <em>TokenSale</em> and create the state machine client.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kt">TokenSale</span>
        <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">=</span> <span class="n">pkh</span>
        <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">=</span> <span class="n">token</span>
        <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">nftName</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="n">client</span> <span class="ow">=</span> <span class="n">tsClient</span> <span class="n">ts</span>
</pre></div>
</div>
<p>We then use the <em>runInitialise</em> function that we discussed in the last lecture, using the client, an initial price of zero, and no initial funds, except for the NFT
which will be automatically added.</p>
<p>We write the <em>ts</em> into the log, then log a message, and return the <em>ts</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runInitialise</span> <span class="n">client</span> <span class="mi">0</span> <span class="n">mempty</span>
<span class="nf">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">ts</span>
<span class="nf">logInfo</span> <span class="o">$</span> <span class="s">&quot;started token sale &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">ts</span>
<span class="nf">return</span> <span class="n">ts</span>
</pre></div>
</div>
<p>The functions for all the other operations are extremely short. This example is ideal for the state machine approach.</p>
<p>They are all very similar. They all invoke <em>runStep</em> and then invoke the correct transition from the state machine.</p>
<p>For example, for <em>setPrice</em>, we need the <em>TokenSale</em> argument to identify the correct contract and the new value of the price. Then we use <em>runStep</em> using the client and
<em>SetPrice</em> as the redeemer. We wrap that using <em>mapErrorSM</em> to convert to <em>Text</em> error messages, and we ignore the result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">setPrice</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">setPrice</span> <span class="n">ts</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">SetPrice</span> <span class="n">p</span>
</pre></div>
</div>
<p>The remaining three follow the same pattern.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">addTokens</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">addTokens</span> <span class="n">ts</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">void</span> <span class="p">(</span><span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">AddTokens</span> <span class="n">n</span><span class="p">)</span>

<span class="nf">buyTokens</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">buyTokens</span> <span class="n">ts</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">BuyTokens</span> <span class="n">n</span>

<span class="nf">withdraw</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">withdraw</span> <span class="n">ts</span> <span class="n">n</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Withdraw</span> <span class="n">n</span> <span class="n">l</span>
</pre></div>
</div>
<p>Now we define three schemas.</p>
<p>One for the seller which just has one endpoint which takes the <em>CurrencySymbol</em> and the <em>TokenName</em> of the asset to be traded.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSStartSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
    <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>For testing purposes, we create <em>TSStartSchema’</em> which additionally takes the <em>CurrencySymbol</em> of the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSStartSchema&#39;</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
    <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>Lastly we have a <em>use</em> schema, with endpoints for the four operations - set price, add tokens, buy tokens and withdraw.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSUseSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;set price&quot;</span>  <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;add tokens&quot;</span> <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;buy tokens&quot;</span> <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;withdraw&quot;</span>   <span class="p">(</span><span class="kt">Integer</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)</span>
</pre></div>
</div>
<p>Now to implement the start endpoint. It simply calls <em>startTs’</em> and recurses. <em>startTs’</em> blocks until the parameters are provided and then calls <em>startTs</em> with
<em>Nothing</em>, indicating that the NFT has to be minted. We wrap it in <em>handleError</em> and if there is an error, we simply log that error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startEndpoint</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">startEndpoint</span> <span class="ow">=</span> <span class="n">startTS&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">startEndpoint</span>
  <span class="kr">where</span>
    <span class="n">startTS&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">void</span> <span class="o">.</span> <span class="n">startTS</span> <span class="kt">Nothing</span> <span class="o">.</span> <span class="kt">AssetClass</span>
</pre></div>
</div>
<p>The <em>startEndpoint’</em> function is very similar, but we add the NFT parameter, as per <em>TSStartSchema’</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startEndpoint&#39;</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema&#39;</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">startEndpoint&#39;</span> <span class="ow">=</span> <span class="n">startTS&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">startEndpoint&#39;</span>
  <span class="kr">where</span>
    <span class="n">startTS&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="p">(</span><span class="n">cs1</span><span class="p">,</span> <span class="n">cs2</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span> <span class="ow">-&gt;</span>  <span class="n">void</span> <span class="o">$</span> <span class="n">startTS</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">cs1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">cs2</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</pre></div>
</div>
<p>No surprises in the <em>use</em> endpoints. We give a choice between the four endpoints and just call the functions we defined earlier with the arguments fed in
from the endpoint call, and with everything wrapped inside an error handler so that the contract won’t crash in the event of an error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">useEndpoints</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">TSUseSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">useEndpoints</span> <span class="n">ts</span> <span class="ow">=</span> <span class="p">(</span><span class="n">setPrice&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">addTokens&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">buyTokens&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">withdraw&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
  <span class="kr">where</span>
    <span class="n">setPrice&#39;</span>  <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;set price&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">setPrice</span> <span class="n">ts</span>
    <span class="n">addTokens&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;add tokens&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">addTokens</span> <span class="n">ts</span>
    <span class="n">buyTokens&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">buyTokens</span> <span class="n">ts</span>
    <span class="n">withdraw&#39;</span>  <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;withdraw&quot;</span>   <span class="o">&gt;&gt;=</span> <span class="n">uncurry</span> <span class="p">(</span><span class="n">withdraw</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="testing">
<h3><span class="section-number">1.8.1.3. </span>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h3>
<p>In order to try it out, let’s run it in the emulator.</p>
<p>We define a <em>runMyTrace</em> function which uses <em>runEmulatorTraceIO’</em> with a custom emulator configuration and a <em>myTrace</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runMyTrace</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runMyTrace</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">emCfg</span> <span class="n">myTrace</span>
</pre></div>
</div>
<p>Let’s first look at the <em>emCfg</em> function. Recall that this is where we can give custom initial distributions to wallets. Here we give 1000 Ada and 1000 of a custom
token to three wallets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ability to use underscores in large numbers such as 1000_000_000 is provided by a GHC extension <em>NumericUnderscores</em></p>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
<span class="nf">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">3</span><span class="p">]]</span>
  <span class="kr">where</span>
    <span class="n">v</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="mi">1000_000_000</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="mi">1000</span>

<span class="nf">currency</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
<span class="nf">currency</span> <span class="ow">=</span> <span class="s">&quot;aa&quot;</span>

<span class="nf">name</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">name</span> <span class="ow">=</span> <span class="s">&quot;A&quot;</span>

<span class="nf">token</span> <span class="ow">::</span> <span class="kt">AssetClass</span>
<span class="nf">token</span> <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">currency</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>For the trace, first we activate Wallet 1 using the non-primed <em>startEndpoint</em> function which mints the NFT is minted automatically. Then, we call the start endpoint, giving it
the symbol and name of the token we want to sell, and then wait for five slots, although two would be enough in this case.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">h</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">startEndpoint</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span> <span class="n">h</span> <span class="p">(</span><span class="n">currency</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
    <span class="kt">Last</span> <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
</pre></div>
</div>
<p>We then read the state, which we wrote using <em>tell</em>, and check to see if it is valid. If it is not, we log an error. If it is, we proceed with the test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
  <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Extras</span><span class="o">.</span><span class="n">logError</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;error starting token sale&quot;</span>
  <span class="kt">Just</span> <span class="n">ts</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;started token sale &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">ts</span>
</pre></div>
</div>
<p>We can now activate the endpoints for the three wallets. Recall that the <em>useEndpoints</em> function is parameterised by the <em>TokenSale</em> data, which is why we needed to
get that value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
<span class="nf">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
<span class="nf">h3</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
</pre></div>
</div>
<p>Wallet 1 sets the price to 1 Ada and we again wait for a generous amount of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;set price&quot;</span> <span class="n">h1</span> <span class="mi">1_000_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Wallet 1 adds 100 tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;add tokens&quot;</span> <span class="n">h1</span> <span class="mi">100</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Wallet 2 buys 20 tokens. So now the contract should contain 80 tokens and 20 Ada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="n">h2</span> <span class="mi">20</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Wallet 3 buys 5 tokens. Now there should be 75 tokens in the contract and 25 Ada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="n">h3</span> <span class="mi">5</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Finally, Wallet 1 calls the withdraw endpoint, taking out 40 tokens and 10 Ada. At this point, there should be 35 tokens and 10 Ada in the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;withdraw&quot;</span> <span class="n">h1</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">10_000_000</span><span class="p">)</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Let’s run this in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">repl</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span>
<span class="n">Ok</span><span class="p">,</span> <span class="n">five</span> <span class="n">modules</span> <span class="n">loaded</span><span class="o">.</span>
<span class="n">Prelude</span> <span class="n">Main</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">l</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span>
<span class="n">Ok</span><span class="p">,</span> <span class="n">one</span> <span class="n">module</span> <span class="n">loaded</span><span class="o">.</span>
<span class="n">Prelude</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="n">runMyTrace</span>

<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">2125</span><span class="n">c8770581c6140c3c71276889f6353830744191de0184b6aa00b185004500</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
</pre></div>
</div>
<p>The first endpoint call is to <em>start</em>. This creates three transaction. Two of these are from the forge contract to create the NFT, and the third one is to set up our
initial UTxO for the token sale.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;start&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;aa&quot;</span><span class="p">)]),</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;A&quot;</span><span class="p">)])])]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">cccba8b2abc3e82a735735c2346aa3fcac58152f17854b1745306e5b63a0b965</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">cccba8b2abc3e82a735735c2346aa3fcac58152f17854b1745306e5b63a0b965</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">e23e19192aea3304a989ab98f05e70bc01fe43f3ea940da78a92ab7cebec9bbb</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">e23e19192aea3304a989ab98f05e70bc01fe43f3ea940da78a92ab7cebec9bbb</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">4</span><span class="n">cae1c5115eb4128243ce029dcd4d6c23d6497d3ab5e71a79f4dc34e9b8cd763</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">4</span><span class="n">cae1c5115eb4128243ce029dcd4d6c23d6497d3ab5e71a79f4dc34e9b8cd763</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;started token sale TokenSale {tsSeller = 21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9, tsToken = (aa,</span><span class="se">\&quot;</span><span class="s2">A</span><span class="se">\&quot;</span><span class="s2">), tsNFT = (65b4199f7d025bfb3b065b0fb88a77d694ffd849ff740b1a4cc453bfaab30f55,</span><span class="se">\&quot;</span><span class="s2">NFT</span><span class="se">\&quot;</span><span class="s2">)}&quot;</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">5</span>
<span class="n">Slot</span> <span class="mi">00005</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">6</span>
</pre></div>
</div>
<p>We successfully read the <em>TokenSale</em> value from the observable state, and start the three contract instances for the use contract.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">7</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="n">started</span> <span class="n">token</span> <span class="n">sale</span> <span class="n">TokenSale</span> <span class="p">{</span><span class="n">tsSeller</span> <span class="o">=</span> <span class="mi">21</span><span class="n">fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9</span><span class="p">,</span> <span class="n">tsToken</span> <span class="o">=</span> <span class="p">(</span><span class="n">aa</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">tsNFT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">65</span><span class="n">b4199f7d025bfb3b065b0fb88a77d694ffd849ff740b1a4cc453bfaab30f55</span><span class="p">,</span><span class="s2">&quot;NFT&quot;</span><span class="p">)}</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000003</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
</pre></div>
</div>
<p>Then we set the price.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;set price&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1000000.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">2</span><span class="n">de6dd820e6939b4b1f9e162c0e2cc878cc38ea1231a9be610315da4eda06714</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">2</span><span class="n">de6dd820e6939b4b1f9e162c0e2cc878cc38ea1231a9be610315da4eda06714</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">8</span>
<span class="n">Slot</span> <span class="mi">00008</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">9</span>
<span class="n">Slot</span> <span class="mi">00009</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">10</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">11</span>
<span class="n">Slot</span> <span class="mi">00011</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">12</span>
</pre></div>
</div>
<p>Then add some tokens.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;add tokens&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">100.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">42</span><span class="n">f1bebe285d1ea23bd90683d110866bb438eede8ef62eaf5e9e3d65eec18e90</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">42</span><span class="n">f1bebe285d1ea23bd90683d110866bb438eede8ef62eaf5e9e3d65eec18e90</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">13</span>
<span class="n">Slot</span> <span class="mi">00013</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">14</span>
<span class="n">Slot</span> <span class="mi">00014</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">15</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">16</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">17</span>
</pre></div>
</div>
<p>Then the two buys by Wallets 2 and 3.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;buy tokens&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">20.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">30</span><span class="n">d28ca855a14accbb11deee682b174adffb548922e1d4257242880f28328f8e</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">30</span><span class="n">d28ca855a14accbb11deee682b174adffb548922e1d4257242880f28328f8e</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">18</span>
<span class="n">Slot</span> <span class="mi">00018</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">19</span>
<span class="n">Slot</span> <span class="mi">00019</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">20</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">21</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">22</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000003</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;buy tokens&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">5.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="n">W3</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">708</span><span class="n">b0c4117ad3b38b69254a714e4695c574af404c3fff0eda859b571218b003c</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">708</span><span class="n">b0c4117ad3b38b69254a714e4695c574af404c3fff0eda859b571218b003c</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">23</span>
<span class="n">Slot</span> <span class="mi">00023</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">24</span>
<span class="n">Slot</span> <span class="mi">00024</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">25</span>
<span class="n">Slot</span> <span class="mi">00025</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">26</span>
<span class="n">Slot</span> <span class="mi">00026</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">27</span>
</pre></div>
</div>
<p>And finally, the withdraw by Wallet 1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;withdraw&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[</span><span class="n">Number</span> <span class="mf">40.0</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1.0e7</span><span class="p">])]))])</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">28</span>
<span class="n">Slot</span> <span class="mi">00028</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">29</span>
<span class="n">Slot</span> <span class="mi">00029</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">30</span>
<span class="n">Slot</span> <span class="mi">00030</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">31</span>
<span class="n">Slot</span> <span class="mi">00031</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">32</span>
<span class="n">Slot</span> <span class="mi">00032</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">33</span>
</pre></div>
</div>
<p>All wallets initially owned 1000 tokens and 1000 Ada. Wallet 1 added 100 tokens to the contract, but then in the last step retrieved 40 tokens and 10 Ada,
and so we see its final balance as 940 tokens and 1010 Ada minus transaction fees.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">940</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">1009942570</span>
</pre></div>
</div>
<p>Wallet 2 bought 20 tokens and paid 20 Ada for them, plus some transaction fees.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">1020</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">979985260</span>
</pre></div>
</div>
<p>Wallet 3 bought 5 tokens for 5 Ada.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">1005</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">994985211</span>
</pre></div>
</div>
<p>Finally, the script still contains the NFT, which will forever stay there, plus 35 tokens and 15 Ada. There were, at one point, 75 tokens and 25 Ada, before Wallet 1
made a withdrawal.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Script</span> <span class="n">fb3eca878d177b6d9264c7c36845fb1e28935553812ed2b56e39c9c4564b85ad</span><span class="p">:</span>
    <span class="p">{</span><span class="mi">65</span><span class="n">b4199f7d025bfb3b065b0fb88a77d694ffd849ff740b1a4cc453bfaab30f55</span><span class="p">,</span> <span class="s2">&quot;NFT&quot;</span><span class="p">}:</span> <span class="mi">1</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">35</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">15000000</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="unit-testing">
<h2><span class="section-number">1.8.2. </span>Unit Testing<a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tasty">
<h3><span class="section-number">1.8.2.1. </span>Tasty<a class="headerlink" href="#tasty" title="Permalink to this headline">¶</a></h3>
<p>You can find <em>tasty</em> on Hackage.</p>
<div class="figure align-default">
<img alt="pioneer/img/pic__00001.png" src="pioneer/img/pic__00001.png" />
</div>
<p>There is also some example code on the same page.</p>
<p>Basically you have a main program that references some <em>tests</em> of type <em>TestTree</em>. As the name suggests, this allows for a tree of tests,
where you can have sub groups and sub-sub groups and so on.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="n">defaultMain</span> <span class="n">tests</span>

<span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">testGroup</span> <span class="s">&quot;Tests&quot;</span> <span class="p">[</span><span class="n">properties</span><span class="p">,</span> <span class="n">unitTests</span><span class="p">]</span>
</pre></div>
</div>
<p>There is special support for tests in Plutus in the <em>plutus-contract</em> package in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.Contract.Test</span>
</pre></div>
</div>
<p>There are various types of tests that are supported, but here we will only look at two of those. One that works with emulator traces, and one which is much more
sophisticated and uses so-called property-based testing.</p>
<p>This module gives us functions for checking predicates, for example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkPredicate</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">TestTree</span>
</pre></div>
</div>
<p>Here we see the connection with Tasty. It takes, as arguments, the descriptive name of the test, then a <em>TracePredicate</em> which we will get to in a moment, and an
<em>EmulatorTrace</em> like the one we have used to test our contracts previously. And the result is a <em>TestTree</em> which, as we have seen, is the type of tests that Tasty
uses. So, using this <em>checkPredicate</em> function we can produce something that the Tasty framework can understand.</p>
<p>There’s also a variant with one additional argument of <em>CheckOptions</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkPredicateOptions</span> <span class="ow">::</span> <span class="kt">CheckOptions</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">TestTree</span>
</pre></div>
</div>
<p><em>CheckOptions</em> has no constructors. This is a bit unfortunate, as we are forced to interact with it via three operations that take a type <em>Lens’</em>. <em>Lens’</em> is related to something called <em>optics</em> in Haskell. Optics is a huge topic
in itself, with whole books haven been written about it, so we will just touch on it for now and just learn how to use the emulator trace.</p>
<p>One of its operations is <em>emulatorConfig</em> which allows us to specify initial distributions of funds, in a way similar to that which we have done in previous testing examples.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emulatorConfig</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="kt">CheckOptions</span> <span class="kt">EmulatorConfig</span>
</pre></div>
</div>
<p>Now let’s look at <em>TracePredicate</em>. This specifies some condition that the emulator trace should satisfy. This is what will be tested when we run the test.</p>
<p>First of all we see some logical combinators - a logical <em>not</em> and a logical <em>and</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">not</span> <span class="ow">::</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">.&amp;&amp;.</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<p>There are lots of functions for producing <em>TracePredicate</em>s. A few example are</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpointAvailable</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">l</span> <span class="ow">::</span> <span class="kt">Symbol</span><span class="p">)</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span> <span class="kt">HasType</span> <span class="n">l</span> <span class="kt">Endpoints</span><span class="o">.</span><span class="kt">ActiveEndpoint</span> <span class="p">(</span><span class="kt">Output</span> <span class="n">s</span><span class="p">),</span> <span class="kt">KnownSymbol</span> <span class="n">l</span><span class="p">,</span> <span class="kt">ContractConstraints</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span> <span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceTag</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">queryingUtxoAt</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span> <span class="kt">UtxoAt</span><span class="o">.</span><span class="kt">HasUtxoAt</span> <span class="n">s</span><span class="p">,</span> <span class="kt">ContractConstraints</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span> <span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceTag</span> <span class="ow">-&gt;</span> <span class="kt">Address</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assertDone</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span> <span class="kt">ContractConstraints</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span> <span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceTag</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<p>For our example, we will only use one of the available checks, <em>walletFundsChange</em>, which checks funds.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Check that the funds in the wallet have changed by the given amount, exluding fees.</span>
<span class="nf">walletFundsChange</span> <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<p>The <em>walletFundsChange</em> creates a <em>TracePredicate</em> that checks whether the funds in a <em>Wallet</em> have changed by a given <em>Value</em>. Interestingly, here, fees are ignored.
We would have a hard time writing precise tests if this were not the case - we would find ourselves needing to approximate the costs of fees without knowing exactly what
they would be.</p>
<p>There is a variation <em>walletFundsExactChange</em>, which <em>does</em> take fees into account.</p>
<p>If we go back to our test module <em>Spec.Trace</em> there is a function that we have not looked at yet, <em>tests</em>, and it uses this <em>checkPredicateOptions</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">checkPredicateOptions</span>
    <span class="p">(</span><span class="n">defaultCheckOptions</span> <span class="o">&amp;</span> <span class="n">emulatorConfig</span> <span class="o">.~</span> <span class="n">emCfg</span><span class="p">)</span>
    <span class="s">&quot;token sale trace&quot;</span>
    <span class="p">(</span>     <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>   <span class="mi">10_000_000</span>  <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="p">(</span><span class="o">-</span><span class="mi">60</span><span class="p">))</span>
    <span class="o">.&amp;&amp;.</span> <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="o">-</span><span class="mi">20_000_000</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span>   <span class="mi">20</span><span class="p">)</span>
    <span class="o">.&amp;&amp;.</span> <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="o">-</span> <span class="mi">5_000_000</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span>    <span class="mi">5</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">myTrace</span>
</pre></div>
</div>
<p>The first argument, as we have seen is of type <em>CheckOptions</em>. This is where we have to use optics, but we won’t go into the details of that here. It is sufficient for now
to note that we use the same <em>EmulatorConfig</em> as we used for <em>runMyTrace</em>.</p>
<p>The second argument is the descriptive name of the trace.</p>
<p>For the third argument, we use the (.&amp;&amp;.) combinator to chain together three different trace predicates, each of which uses the <em>walletFundsChange</em> function we saw above. Here
we specify the changes that we expect to see in each of the wallets at the end of the trace - for example, we expect Wallet 1 to have gained 10 Ada and
lost 60 Tokens.</p>
<p>We can now run this in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="kn">import</span> <span class="nn">Test.Tasty</span>
<span class="n">Prelude</span> <span class="n">Test</span><span class="o">.</span><span class="n">Tasty</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="n">defaultMain</span> <span class="n">tests</span>
<span class="n">token</span> <span class="n">sale</span> <span class="n">trace</span><span class="p">:</span> <span class="n">OK</span> <span class="p">(</span><span class="mf">1.22</span><span class="n">s</span><span class="p">)</span>

<span class="n">All</span> <span class="mi">1</span> <span class="n">tests</span> <span class="n">passed</span> <span class="p">(</span><span class="mf">1.22</span><span class="n">s</span><span class="p">)</span>
<span class="o">***</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">ExitSuccess</span>
</pre></div>
</div>
<p>This passes. Let’s see what happens if it doesn’t pass. We can change one of the values.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span> <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>   <span class="mi">10_000_000</span>  <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Test</span><span class="o">.</span><span class="n">Tasty</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">l</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span>
<span class="p">[</span><span class="mi">1</span> <span class="n">of</span> <span class="mi">1</span><span class="p">]</span> <span class="n">Compiling</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span>       <span class="p">(</span> <span class="n">test</span><span class="o">/</span><span class="n">Spec</span><span class="o">/</span><span class="n">Trace</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">chris</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">ada</span><span class="o">/</span><span class="n">pioneer</span><span class="o">-</span><span class="n">fork</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">week08</span><span class="o">/</span><span class="n">dist</span><span class="o">-</span><span class="n">newstyle</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">/</span><span class="n">ghc</span><span class="o">-</span><span class="mf">8.10</span><span class="o">.</span><span class="mf">4.20210212</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="o">/</span><span class="n">t</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span><span class="o">-</span><span class="n">tmp</span><span class="o">/</span><span class="n">Spec</span><span class="o">/</span><span class="n">Trace</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="n">Ok</span><span class="p">,</span> <span class="n">one</span> <span class="n">module</span> <span class="n">loaded</span><span class="o">.</span>
<span class="n">Prelude</span> <span class="n">Test</span><span class="o">.</span><span class="n">Tasty</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="n">defaultMain</span> <span class="n">tests</span>
<span class="n">token</span> <span class="n">sale</span> <span class="n">trace</span><span class="p">:</span> <span class="n">FAIL</span> <span class="p">(</span><span class="mf">1.32</span><span class="n">s</span><span class="p">)</span>
  <span class="n">Expected</span> <span class="n">funds</span> <span class="n">of</span> <span class="n">W1</span> <span class="n">to</span> <span class="n">change</span> <span class="n">by</span>
    <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10000000</span><span class="p">)]),(</span><span class="n">aa</span><span class="p">,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">50</span><span class="p">)])])</span>
    <span class="p">(</span><span class="n">excluding</span> <span class="mi">57430</span> <span class="n">lovelace</span> <span class="ow">in</span> <span class="n">fees</span><span class="p">)</span>
  <span class="n">but</span> <span class="n">they</span> <span class="n">changed</span> <span class="n">by</span>
    <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10000000</span><span class="p">)]),(</span><span class="n">aa</span><span class="p">,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">60</span><span class="p">)])])</span>
  <span class="n">Test</span> <span class="n">failed</span><span class="o">.</span>
  <span class="n">Emulator</span> <span class="n">log</span><span class="p">:</span>

  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">0</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">2125</span><span class="n">c8770581c6140c3c71276889f6353830744191de0184b6aa00b185004500</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
                   <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
                   <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;start&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;aa&quot;</span><span class="p">)]),</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;A&quot;</span><span class="p">)])])]))])</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
  <span class="o">...</span>
  <span class="o">...</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">27</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">27</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
    <span class="n">src</span><span class="o">/</span><span class="n">Plutus</span><span class="o">/</span><span class="n">Contract</span><span class="o">/</span><span class="n">Test</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">245</span><span class="p">:</span>
    <span class="n">token</span> <span class="n">sale</span> <span class="n">trace</span>

<span class="mi">1</span> <span class="n">out</span> <span class="n">of</span> <span class="mi">1</span> <span class="n">tests</span> <span class="n">failed</span> <span class="p">(</span><span class="mf">1.32</span><span class="n">s</span><span class="p">)</span>
<span class="o">***</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">ExitFailure</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We see a nice error message, followed by the emulator log, which we didn’t get when the tests passed.</p>
<p>This is probably the simplest way to write automated tests for Plutus contracts. You simply write one or more emulator traces, and then use <em>checkPredicate</em> in association
with the appropriate test predicates, to check that the trace leads to the desired result. This lets us write more or less traditional unit tests.</p>
</div>
</div>
<div class="section" id="optics-and-lenses">
<h2><span class="section-number">1.8.3. </span>Optics and Lenses<a class="headerlink" href="#optics-and-lenses" title="Permalink to this headline">¶</a></h2>
<p>Before we get to the second way of testing Plutus contracts, we will take a brief look at optics and lenses.</p>
<p>There are various competing optics libraries on Hackage, but the most prominent, and the most infamous one, and the one that the Plutus team decided to use is called <em>Lens</em>.</p>
<p><em>Lens</em> is authored by Edward Kmett, who is probably the most prolific contributor to Haskell libraries.</p>
<div class="figure align-default">
<img alt="pioneer/img/pic__00002.png" src="pioneer/img/pic__00002.png" />
</div>
<p>You can see on the Hackage page there is a scary diagram. There is a whole zoo of optics. There are lenses and prisms and traversals and isos and whatnot. This diagram
shows some of the operations that the library provides.</p>
<div class="figure align-default">
<img alt="pioneer/img/pic__00003.png" src="pioneer/img/pic__00003.png" />
</div>
<p>Optics are all about reaching deeply into hierarchical data types to inspect parts that are hidden deeply in the data type and to manipulate them.</p>
<p>Let’s look at a very simple example in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week08.Lens</span>
</pre></div>
</div>
<p>We have a type <em>Company</em> which is a wrapper around a list of <em>Person</em>. There is a field <em>_staff</em>. When dealing with lenses, it is convention to start field names with underscores.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Company</span> <span class="ow">=</span> <span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Person</span><span class="p">]}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">data</span> <span class="kt">Person</span>  <span class="ow">=</span> <span class="kt">Person</span>
    <span class="p">{</span> <span class="n">_name</span>    <span class="ow">::</span> <span class="kt">String</span>
    <span class="p">,</span> <span class="n">_address</span> <span class="ow">::</span> <span class="kt">Address</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">newtype</span> <span class="kt">Address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>And we define two <em>Person</em>s and a <em>Company</em> with which these <em>Person</em>s are associated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">alejandro</span><span class="p">,</span> <span class="n">lars</span> <span class="ow">::</span> <span class="kt">Person</span>
<span class="nf">alejandro</span> <span class="ow">=</span> <span class="kt">Person</span>
  <span class="p">{</span>  <span class="n">_name</span>    <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span>
  <span class="p">,</span>  <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Zacateca&quot;</span><span class="p">}</span>
  <span class="p">}</span>
<span class="nf">lars</span> <span class="ow">=</span> <span class="kt">Person</span>
  <span class="p">{</span>  <span class="n">_name</span>    <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span>
  <span class="p">,</span>  <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Regensburg&quot;</span><span class="p">}</span>
  <span class="p">}</span>

<span class="nf">iohk</span> <span class="ow">::</span> <span class="kt">Company</span>
<span class="nf">iohk</span> <span class="ow">=</span> <span class="kt">Company</span> <span class="p">{</span> <span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="n">alejandro</span><span class="p">,</span> <span class="n">lars</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>The task is to write a simple function, <em>goTo</em>, that gets a <em>String</em> as argument along with a <em>Company</em>. The function should create a new company which it gets by
changing all the cities of all the staff of the company with the given string.</p>
<p>If we apply that to <em>iohk</em> with a string argument of “Athens*, then we should get a <em>Company</em> with the same two <em>Person</em>s, but now both of those <em>Person</em>s have
a city of “Athens”.</p>
<p>You don’t need any advanced Haskell to achieve this, but it’s a bit messy, even in this simple example. The function below uses record syntax to modify specific fields
of records, while leaving the other fields the same.</p>
<p>The helper function <em>movePerson</em> updates the <em>_address</em> field of the <em>Person</em> <em>p</em>, and the <em>_city</em> field of that <em>Address</em>, and the main part of the function maps the
<em>movePerson</em> function over each member of <em>_staff</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">goTo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Company</span> <span class="ow">-&gt;</span> <span class="kt">Company</span>
<span class="nf">goTo</span> <span class="n">there</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">c</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">movePerson</span> <span class="p">(</span><span class="n">_staff</span> <span class="n">c</span><span class="p">)}</span>
  <span class="kr">where</span>
    <span class="n">movePerson</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">p</span> <span class="p">{</span><span class="n">_address</span> <span class="ow">=</span> <span class="p">(</span><span class="n">_address</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="n">there</span><span class="p">}}</span>
</pre></div>
</div>
<p>We can look at the original company in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">iohk</span>
<span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Zacateca&quot;</span><span class="p">}},</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Regensburg&quot;</span><span class="p">}}]}</span>
</pre></div>
</div>
<p>Now, let’s apply the <em>goTo</em> function to it, and see the changes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">goTo</span> <span class="s">&quot;Athens&quot;</span> <span class="n">iohk</span>
<span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}},</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}}]}</span>
</pre></div>
</div>
<p>So, dealing with nested record types, even though it is quite simple conceptually, can be quite messy.</p>
<p>This is what optics try to make easier with the idea of providing first-class field accessors. In the end it’s very similar to dealing with such data types in an imperative
language such as C# or Java.</p>
<p>We saw in lecture four how monads can be viewed as a programmable semi-colon, where the semi-colon is the statement separator in many imperative languages. In a similar way, optics can be thought of as providing a programmable dot,
where a dot is the accessor dot as in Python or Java.</p>
<p>You could implement lenses by hand, but the <em>lens</em> library provides some Template Haskell magic to do it automatically, so long as we follow the underscore convention mentioned above.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">makeLenses</span> <span class="kt">&#39;&#39;Company</span>
<span class="nf">makeLenses</span> <span class="kt">&#39;&#39;Person</span>
<span class="nf">makeLenses</span> <span class="kt">&#39;&#39;Address</span>
</pre></div>
</div>
<p>The names of the lenses will be the names of the original fields without the underscore.</p>
<p>There is a way, within the REPL, to inspect what code Template Haskell writes at compile time.</p>
<p>First, enable the following flag</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="p">:</span><span class="nb">set</span> <span class="o">-</span><span class="n">ddump</span><span class="o">-</span><span class="n">splices</span>
</pre></div>
</div>
<p>Then, reload the module. If nothing happens, you’ll need to make a minor change to the code, perhaps by adding some whitespace, before reloading.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">r</span>
<span class="p">[</span><span class="mi">4</span> <span class="n">of</span> <span class="mi">4</span><span class="p">]</span> <span class="n">Compiling</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span>      <span class="p">(</span> <span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">chris</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">ada</span><span class="o">/</span><span class="n">pioneer</span><span class="o">-</span><span class="n">fork</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">week08</span><span class="o">/</span><span class="n">dist</span><span class="o">-</span><span class="n">newstyle</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">/</span><span class="n">ghc</span><span class="o">-</span><span class="mf">8.10</span><span class="o">.</span><span class="mf">4.20210212</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">35</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">20</span><span class="p">:</span> <span class="n">Splicing</span> <span class="n">declarations</span>
    <span class="n">makeLenses</span> <span class="s1">&#39;&#39;</span><span class="n">Company</span>
  <span class="o">======&gt;</span>
    <span class="n">staff</span> <span class="p">::</span> <span class="n">Iso</span><span class="s1">&#39; Company [Person]</span>
    <span class="n">staff</span> <span class="o">=</span> <span class="p">(</span><span class="n">iso</span> <span class="p">(</span>\ <span class="p">(</span><span class="n">Company</span> <span class="n">x_abBO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x_abBO</span><span class="p">))</span> <span class="n">Company</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE staff #-}</span>
<span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">19</span><span class="p">:</span> <span class="n">Splicing</span> <span class="n">declarations</span>
    <span class="n">makeLenses</span> <span class="s1">&#39;&#39;</span><span class="n">Person</span>
  <span class="o">======&gt;</span>
    <span class="n">address</span> <span class="p">::</span> <span class="n">Lens</span><span class="s1">&#39; Person Address</span>
    <span class="n">address</span> <span class="n">f_abEJ</span> <span class="p">(</span><span class="n">Person</span> <span class="n">x1_abEK</span> <span class="n">x2_abEL</span><span class="p">)</span>
      <span class="o">=</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span>\ <span class="n">y1_abEM</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Person</span> <span class="n">x1_abEK</span><span class="p">)</span> <span class="n">y1_abEM</span><span class="p">))</span> <span class="p">(</span><span class="n">f_abEJ</span> <span class="n">x2_abEL</span><span class="p">)</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE address #-}</span>
    <span class="n">name</span> <span class="p">::</span> <span class="n">Lens</span><span class="s1">&#39; Person String</span>
    <span class="n">name</span> <span class="n">f_abEN</span> <span class="p">(</span><span class="n">Person</span> <span class="n">x1_abEO</span> <span class="n">x2_abEP</span><span class="p">)</span>
      <span class="o">=</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span>\ <span class="n">y1_abEQ</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Person</span> <span class="n">y1_abEQ</span><span class="p">)</span> <span class="n">x2_abEP</span><span class="p">))</span> <span class="p">(</span><span class="n">f_abEN</span> <span class="n">x1_abEO</span><span class="p">)</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE name #-}</span>
<span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">20</span><span class="p">:</span> <span class="n">Splicing</span> <span class="n">declarations</span>
    <span class="n">makeLenses</span> <span class="s1">&#39;&#39;</span><span class="n">Address</span>
  <span class="o">======&gt;</span>
    <span class="n">city</span> <span class="p">::</span> <span class="n">Iso</span><span class="s1">&#39; Address String</span>
    <span class="n">city</span> <span class="o">=</span> <span class="p">(</span><span class="n">iso</span> <span class="p">(</span>\ <span class="p">(</span><span class="n">Address</span> <span class="n">x_abFw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x_abFw</span><span class="p">))</span> <span class="n">Address</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE city #-}</span>
</pre></div>
</div>
<p>This now shows us what Template Haskell does.</p>
<p>We see that <em>makeLenses</em> for <em>Company</em> creates a function <em>staff</em>, which returns an <em>Iso’</em> - a type of optic - from <em>Company</em> to <em>[Person]</em>.</p>
<p>For <em>makeLenses Person</em> we get an <em>address</em> function which returns a <em>Lens’</em> from <em>Person</em> to <em>Address</em>, and we also get a <em>name</em> lens from <em>Person</em> to <em>String</em>.</p>
<p>For <em>makeLenses Address</em> we get a <em>city</em> function which returns an <em>Iso’</em> from <em>Address</em> to <em>String</em>.</p>
<p><em>Iso</em> and <em>Lens</em> are two different types of optics but the order of type arguments is always the same.
You always have two type arguments, at least for these primed versions (there are more general optics which take four type parameters). The first argument is always the
big data type and the second parameter is the part you are zooming into. The name optics relates to the mental image of zooming into a datatype.</p>
<p>Let’s try them out in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span>
<span class="n">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="o">=</span> <span class="n">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="o">=</span> <span class="s2">&quot;Regensburg&quot;</span><span class="p">}}</span>

<span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="kn">import</span> <span class="nn">Control.Lens</span>

<span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">^.</span> <span class="n">name</span>
<span class="s2">&quot;Lars&quot;</span>

<span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">^.</span> <span class="n">address</span>
<span class="n">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="o">=</span> <span class="s2">&quot;Regensburg&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>A very powerful feature of lenses is that you can compose them.</p>
<p>Where we have, above, something going from <em>Person</em> to <em>Address</em> and we have something else going from <em>Address</em> to <em>String</em>, then we can combine them using the
function composition dot. There is some advanced type-level machinery going on behind the scenes to make that work, but it works.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">^.</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span>
<span class="s2">&quot;Regensburg&quot;</span>
</pre></div>
</div>
<p>Not only can you view the contents of record types like this, but you can also manipulate them.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">&amp;</span> <span class="n">name</span> <span class="o">.~</span> <span class="s2">&quot;LARS&quot;</span>
<span class="n">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;LARS&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="o">=</span> <span class="n">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="o">=</span> <span class="s2">&quot;Regensburg&quot;</span><span class="p">}}</span>
</pre></div>
</div>
<p>The <em>&amp;</em> symbol here is function application, but the other way around - the argument comes first and then the function.</p>
<p>Again, we can compose.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">&amp;</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span> <span class="o">.~</span> <span class="s">&quot;Munich&quot;</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Munich&quot;</span><span class="p">}}</span>
</pre></div>
</div>
<p>There is another type of optics called <em>Traversables</em>, that zooms not only into one field, but into many simultaneously. If you had a list it would zoom into each
element. So, for example, we could use a list of integers, with the <em>each</em> traversable that works with many container types, including lists, and set every element to 42.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">each</span> <span class="o">.~</span> <span class="mi">42</span>
<span class="p">[</span><span class="mi">42</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
</pre></div>
</div>
<p>You may see a <em>type-defaults</em> warning when you run the above, but it is removed here.</p>
<p>A cool thing is that various types of lenses can be combined, again with the dot operator. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">iohk</span> <span class="o">&amp;</span> <span class="n">staff</span> <span class="o">.</span> <span class="n">each</span> <span class="o">.</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span> <span class="o">.~</span> <span class="s">&quot;Athens&quot;</span>
<span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}},</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}}]}</span>
</pre></div>
</div>
<p>And this is exactly what our <em>goTo</em> function achieved, so we can write <em>goTo’</em> as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">goTo&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Company</span> <span class="ow">-&gt;</span> <span class="kt">Company</span>
<span class="nf">goTo&#39;</span> <span class="n">there</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">staff</span> <span class="o">.</span> <span class="n">each</span> <span class="o">.</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span> <span class="o">.~</span> <span class="n">there</span>
</pre></div>
</div>
<p>And this is actually what we did when we configured our test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">checkPredicateOptions</span>
    <span class="p">(</span><span class="n">defaultCheckOptions</span> <span class="o">&amp;</span> <span class="n">emulatorConfig</span> <span class="o">.~</span> <span class="n">emCfg</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <em>defaultCheckOptions</em> is of type <em>CheckOptions</em> and there is a lens from <em>CheckOptions</em> to <em>EmulatorConfig</em>, and this is the part that we wanted to change.</p>
<p>And that concludes our brief excursion into optics and lenses.</p>
</div>
<div class="section" id="property-based-testing">
<h2><span class="section-number">1.8.4. </span>Property Based Testing<a class="headerlink" href="#property-based-testing" title="Permalink to this headline">¶</a></h2>
<p>Property Based Testing is quite a revolutionary approach to testing that is much more powerful than simple unit testing. It originated from Haskell, which, with its
pureness and immutable data structures is particularly suited to this approach. It has now been copied by almost all other programming languages.</p>
<div class="section" id="quickcheck">
<h3><span class="section-number">1.8.4.1. </span>QuickCheck<a class="headerlink" href="#quickcheck" title="Permalink to this headline">¶</a></h3>
<p>One of the inventors of <em>QuickCheck</em>, which is the most prominent and was the first library using this approach, is John Hughes, who is also one of the original inventors
of Haskell. He and his company work with IOHK to provide special support of this approach to testing Plutus contracts.</p>
<p>Before we look at using QuickCheck for Plutus contracts, let’s first look at its use for pur Haskell programs.</p>
<p>Property based testing subsumes unit tests. Let’s write a very simple and silly unit test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_simple</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">prop_simple</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>This function is available in the module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week08.QuickCheck</span>
</pre></div>
</div>
<p>After loading this module, and the <em>Test.QuickCheck</em> module, we can test our unit test in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_simple</span>
<span class="o">+++</span> <span class="kt">OK</span><span class="p">,</span> <span class="n">passed</span> <span class="mi">1</span> <span class="n">test</span><span class="o">.</span>
</pre></div>
</div>
<p>This is not very exciting. For a more interesting example, the same module contains a buggy implementation of an insertion sort.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">sort</span> <span class="kt">[]</span>     <span class="ow">=</span>  <span class="kt">[]</span>
<span class="nf">sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>  <span class="n">insert</span> <span class="n">x</span> <span class="n">xs</span>

<span class="nf">insert</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="kt">[]</span>                     <span class="ow">=</span>  <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>       <span class="ow">=</span>  <span class="n">x</span> <span class="kt">:</span> <span class="n">ys</span>
                 <span class="o">|</span> <span class="n">otherwise</span>    <span class="ow">=</span>  <span class="n">y</span> <span class="kt">:</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>
</pre></div>
</div>
<p>To test it, a property that would could test would be that after applying sort to a list of integers, the resulting list is sorted.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isSorted</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isSorted</span> <span class="kt">[]</span>           <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isSorted</span> <span class="p">[</span><span class="kr">_</span><span class="p">]</span>          <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isSorted</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">isSorted</span> <span class="p">(</span><span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>Using this, we can now provide a QuickCheck property that is not just simply of type <em>Bool</em>, but instead is a function from a list of <em>Int</em>s to <em>Bool</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_sort_sorts</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">prop_sort_sorts</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">isSorted</span> <span class="o">$</span> <span class="n">sort</span> <span class="n">xs</span>
</pre></div>
</div>
<p>You can read that like a specification, which says “for all the lists of integers <em>xs</em>, if you apply <em>sort</em> to it, then the result should be sorted.”</p>
<p>QuickCheck can deal with such properties.</p>
<p>In the REPL</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_sort_sorts</span>
<span class="o">***</span> <span class="kt">Failed</span><span class="o">!</span> <span class="kt">Falsified</span> <span class="p">(</span><span class="n">after</span> <span class="mi">8</span> <span class="n">tests</span> <span class="n">and</span> <span class="mi">4</span> <span class="n">shrinks</span><span class="p">)</span><span class="kt">:</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>It fails, and gives us an example where the property does not hold. We can test that example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>And can see that, indeed, it is not correct.</p>
<p>How does QuickCheck do this? If you provide a function with one or more arguments, it will generate random arguments for the function. In our example, QuickCheck
has generated 100 random lists of integers and, for each of those lists, has checked whether the property holds, until it hit a failure.</p>
<p>Note that the failure was reported as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>*** Failed! Falsified (after 8 tests and 4 shrinks):
</pre></div>
</div>
<p>This means that after 8 tests the property was falsified, but at this point, rather than just report the failure, it has tried to shrink it - to simplify it.</p>
<p>This is a powerful feature of QuickCheck, because the random counter examples that QuickCheck finds are very complicated - long lists with long numbers. But once a counter
example has been found, QuickCheck tries to simplify it, perhaps by dropping some elements from the list, or by making some of the numbers smaller, until it doesn’t
find a way to get an even simpler example.</p>
<p>It is this combination of random test generation and shrinking that makes QuickCheck so tremendously useful.</p>
<p>We can see what type of random lists QuickCheck generates.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">(</span><span class="n">arbitrary</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
<span class="kt">[]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">17</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">19</span><span class="p">]</span>
</pre></div>
</div>
<p>The way QuickCheck does this random generation is by using a type class called <em>Arbitrary</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Test</span><span class="o">.</span><span class="n">QuickCheck</span> <span class="n">Week08</span><span class="o">.</span><span class="n">QuickCheck</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">i</span> <span class="n">Arbitrary</span>
<span class="nb">type</span> <span class="n">Arbitrary</span> <span class="p">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="n">Constraint</span>
<span class="k">class</span> <span class="nc">Arbitrary</span> <span class="n">a</span> <span class="n">where</span>
  <span class="n">arbitrary</span> <span class="p">::</span> <span class="n">Gen</span> <span class="n">a</span>
  <span class="n">shrink</span> <span class="p">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>There are many more lines to the above output, but the important ones are shown. We can see that it has two methods. One is called <em>arbitrary</em> and one is called <em>shrink</em>.</p>
<p><em>Gen</em> is yet another monad. The monad provides various methods that allow for random number generation for values of type <em>a</em>.</p>
<p>The second method is <em>shrink</em>, which, when given an <em>a</em> will provide a list of simpler versions of <em>a</em>. This, of course, depends on the type of <em>a</em>.</p>
<p>If we look at the output above that provides some random integer lists, we see something interesting. The further we go down the list, the more complicated the list becomes. The
first is just the empty list, then we get single-element lists, then some longer lists, and it tends towards greater complexity over time.</p>
<p>In addition to just providing random generation in the <em>Gen</em> monad, there is also a concept of complexity. If you implement an instance of <em>Gen</em> you are expected not only
to generate a random <em>a</em> but also a random <em>a</em> of some given complexity.</p>
<p>When <em>QuickCheck</em> checks a property, it starts with simple, random arguments, then makes them more complex over time. By default it tests 100 random arguments, but this
can be configured.</p>
<p>Now that we know that our code fails, let’s try to fix it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">sort</span> <span class="kt">[]</span>     <span class="ow">=</span>  <span class="kt">[]</span>
<span class="nf">sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>  <span class="n">insert</span> <span class="n">x</span> <span class="n">xs</span>
</pre></div>
</div>
<p>The problem is that all we do for a non-empty list is to insert the first element into the tail, but we don’t recursively sort the tail.</p>
<p>Our first attempt to fix…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">sort</span> <span class="kt">[]</span>     <span class="ow">=</span>  <span class="kt">[]</span>
<span class="nf">sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>  <span class="n">insert</span> <span class="n">x</span> <span class="o">$</span> <span class="n">sort</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Now, when we test this…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude Control.Lens Test.QuickCheck&gt; :r
[1 of 1] Compiling Week08.QuickCheck ( src/Week08/QuickCheck.hs, /home/chris/git/ada/pioneer-fork/code/week08/dist-newstyle/build/x86_64-linux/ghc-8.10.4.20210212/plutus-pioneer-program-week08-0.1.0.0/build/Week08/QuickCheck.o )
Ok, one module loaded.
Prelude Control.Lens Test.QuickCheck Week08.QuickCheck&gt; quickCheck prop_sort_sorts
+++ OK, passed 100 tests.
</pre></div>
</div>
<p>It passes. However, if we test specifically for the case that failed previously…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>It is clearly not correct. Even though the list has been sorted, the length of the list has changed. This leads to an important point. QuickCheck can’t do magic - its results are only
as good as the properties we provide. What we see here is that our property <em>prop_sort_sorts</em> is not strong enough to test if the function is correct.</p>
<p>We can add a second property that checks the length.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_sort_preserves_length</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">prop_sort_preserves_length</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">sort</span> <span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="n">length</span> <span class="n">xs</span>
</pre></div>
</div>
<p>And we find that this property is not satisfied by our code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_sort_preserves_length</span>
<span class="o">***</span> <span class="kt">Failed</span><span class="o">!</span> <span class="kt">Falsified</span> <span class="p">(</span><span class="n">after</span> <span class="mi">4</span> <span class="n">tests</span> <span class="n">and</span> <span class="mi">3</span> <span class="n">shrinks</span><span class="p">)</span><span class="kt">:</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The bug in our code is in the <em>insert</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="kt">[]</span>                     <span class="ow">=</span>  <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>       <span class="ow">=</span>  <span class="n">x</span> <span class="kt">:</span> <span class="n">ys</span>
                 <span class="o">|</span> <span class="n">otherwise</span>    <span class="ow">=</span>  <span class="n">y</span> <span class="kt">:</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>
</pre></div>
</div>
<p>We say here that, if <em>x</em> is less or equal to <em>y</em>, then we append <em>x</em> to <em>ys</em>, but we have forgotten about the <em>y</em>. It should read:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>       <span class="ow">=</span>  <span class="n">x</span> <span class="kt">:</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span>
</pre></div>
</div>
<p>This should fix it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">r</span>
<span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_sort_preserves_length</span>
<span class="o">+++</span> <span class="kt">OK</span><span class="p">,</span> <span class="n">passed</span> <span class="mi">100</span> <span class="n">tests</span><span class="o">.</span>
</pre></div>
</div>
<p>Of course, this is still not proof that our function is correct, because these two properties are still not enough to specify a sorting function fully. For example,
the sorting function could return a list of the same length containing only zeroes. This would pass all tests. It is quite an art to find properties to guarantee that,
if they are all satisfied, there is no bug.</p>
<p>Even so, this approach to testing is often more effective than unit testing as it can test a huge number of random cases and can find examples of
failure which a programmer writing a unit test may not have thought of.</p>
<div class="section" id="using-quickcheck-with-plutus">
<h4><span class="section-number">1.8.4.1.1. </span>Using QuickCheck with Plutus<a class="headerlink" href="#using-quickcheck-with-plutus" title="Permalink to this headline">¶</a></h4>
<p>Now that we have seen what QuickCheck can do, we will turn our attention to using it to test Plutus contracts.</p>
<p>Here we hit a problem - how do you use QuickCheck to test side-effected code? This problem does not only arise with blockchain, it arises with all systems
that use IO.</p>
<p>John Hughes always uses the example of the file system. How would you test file system operations, i.e. reading, writing, opening and closing files, using QuickCheck.</p>
<p>The approach to use is very similar to the one you can use with Plutus. The idea is that you start with a model.</p>
<div class="figure align-default">
<img alt="pioneer/img/pic__00004.png" src="pioneer/img/pic__00004.png" />
</div>
<p>The model is basically an idealised model of how the real world system should work. There must be some sort of relation between the model and the real system.</p>
<p>If the real system is a file system, then you could, in the model, have an idealised version of how you think files should work. And then, what QuickCheck does, in its
random generation, is to generate a random sequence of actions that you can perform on the system. In the example of a file system, it would randomly generate a
sequence of opening files, closing files, writing to files, reading files and so on. Now you can basically step this model and the system in parallel.</p>
<p>You have some sort of action that you perform in the real world, and you apply the same type of action to your model. Then your real system has progressed into a new state,
and your model has also been updated. After this step, you can compare the two and check that they are still in sync. You can then continue this for several steps.</p>
<div class="figure align-default">
<img alt="pioneer/img/pic__00009.png" src="pioneer/img/pic__00009.png" />
</div>
<p>While our first QuickCheck example generated a random list of <em>Int</em>s, the idea for testing a real world system is to generate random lists of actions and then to
apply those actions both to a model and to the real system and to check that the model and the real system stay in sync.</p>
<p>Shrinking in this example would be that, if you have a list of actions that show that there is a bug, then you can, for example, drop some of the actions and see
whether the problem still arises. This can be repeated until you cannot drop any further actions from the list and still reproduce the bug.</p>
<p>This is exactly how the QuickCheck support for Plutus works. In order to test a Plutus contract, we have to come up with a model and define our expectations of how
the various endpoints, for example, would change the model. We would then need to provide a link between the model and the real system (the emulator), and then apply the
QuickCheck machinery.</p>
<p>The code to do this is in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Spec.Model</span>
</pre></div>
</div>
<p>We notice that we import two Plutus test modules, with the QuickCheck support being provided by the <em>ContractModel</em>, which has all the machinery to define a model and to link
it to a real contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span>           <span class="nn">Plutus.Contract.Test</span>
<span class="kr">import</span>           <span class="nn">Plutus.Contract.Test.ContractModel</span>
</pre></div>
</div>
<p>And we import three more test modules. One for Tasty, one for QuickCheck, and one that allows for using QuickCheck properties in Tasty test suites.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span>           <span class="nn">Test.QuickCheck</span>
<span class="kr">import</span>           <span class="nn">Test.Tasty</span>
<span class="kr">import</span>           <span class="nn">Test.Tasty.QuickCheck</span>
</pre></div>
</div>
<p>To define a model, we first define a datatype that represents the state of one <em>TokenSale</em> instance.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TSState</span> <span class="ow">=</span> <span class="kt">TSState</span>
  <span class="p">{</span> <span class="n">_tssPrice</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
  <span class="p">,</span> <span class="n">_tssLovelace</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
  <span class="p">,</span> <span class="n">_tssToken</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>It has three fields - the current price, the current supply of lovelace in the contract, and the current supply of tokens in the contract.</p>
<p>Then our model <em>TSModel</em> is a map from wallets to <em>TokenSale</em> states.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">TSModel</span> <span class="ow">=</span> <span class="kt">TSModel</span> <span class="p">{</span><span class="n">_tsModel</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">TSState</span><span class="p">}</span>
<span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>The idea in this test is that we have two wallets and each wallet runs its own <em>TokenSale</em> contract, and the two wallets will trade different tokens.</p>
<p>We create lenses for the model. We need optics to interact with the <em>ContactModel</em> library.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">makeLenses</span> <span class="kt">&#39;&#39;TSModel</span>
</pre></div>
</div>
<p>All the logic that defines how our model should behave, and how it is linked to the real contract is in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">ContractModel</span> <span class="kt">TSModel</span> <span class="kr">where</span>
</pre></div>
</div>
<p>First we have an associated datatype. This is quite an advanced Haskell feature. In type classes, as well as methods, you can have data types. We have seen this
before in validators where we define a dummy type that provides a link between the datum type and the redeemer type.</p>
<p>Here, we associate an <em>Action</em> type, which represents the actions that QuickCheck will generate. In principal, we just have one constructor in the <em>Action</em> type for
each of the endpoints we saw earlier. We have additional arguments because now there are additional wallets at play and we must keep track of which wallet performs an
action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Action</span> <span class="kt">TSModel</span> <span class="ow">=</span>
    <span class="kt">Start</span> <span class="kt">Wallet</span>
  <span class="o">|</span> <span class="kt">SetPrice</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">AddTokens</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">Withdraw</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span> <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">BuyTokens</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span>
<span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Start Wallet</em> means that this wallet starts the token sale contract.</p>
<p><em>SetPrice Wallet Wallet Integer</em> means that the second wallet sets the price for the token sale contract operated by the first wallet. We know from the contract logic that
this should only work if both the wallets are the same, because only the owner of the contract can set the price.</p>
<p><em>AddTokens</em> is very similar to <em>SetPrice</em>.</p>
<p>For <em>Withdraw</em>, the second wallet attempts to withdraw a certain number of lovelace and a certain number tokens (respectively) from the token sale run by the first wallet. Again, this should
fail if the two wallets are not the same.</p>
<p>In <em>BuyTokens</em>, the second wallet will try to buy a certain number of tokens from the token sale run by the first wallet.</p>
<p>So, the <em>Action</em> type is the first ingredient.</p>
<p>The second ingredient is another associated datatype. For each instance of a contract that we are running, we want a key that identifies the instance.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="kr">where</span>
  <span class="kt">StartKey</span> <span class="ow">::</span> <span class="kt">Wallet</span>           <span class="ow">-&gt;</span> <span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema&#39;</span> <span class="kt">Text</span>
  <span class="kt">UseKey</span>   <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="nb">()</span>               <span class="kt">TSUseSchema</span>    <span class="kt">Text</span>
</pre></div>
</div>
<p>This is a generalised, algebraic datatype (GADT), so it’s a little different to usual data declarations in Haskell. Instead of just providing the constructors, you provide the
constructors with a type signature.</p>
<p>In <em>ContractInstanceKey</em>, we have a constructor <em>StartKey</em> that takes a <em>Wallet</em> as an argument and then produces something of type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema&#39;</span> <span class="kt">Text</span>
</pre></div>
</div>
<p>The point of GADTs is that with normal datatypes, the type parameters are the same for all constructors, for example, <em>Action TSModel</em> has five constructors, but the type
is always <em>TSModel</em>. But with GADTs, we are able to provide a more generalised type parameter - in this case <em>TSModel w s e</em>.</p>
<p>We need this feature in this case because our contracts can have different type parameters.</p>
<p>There are two types of instances. Recall we have the <em>start</em> contract and the <em>use</em> contract, which have different type signatures.</p>
<p><em>StartKey</em> returns a type that consists of our model and then the parameters that come from the contract itself - the state type, the schema, and the error type. We used the primed
version of <em>TSStartSchema</em> - <em>TSStartSchema’</em> because we don’t want to create the NFT, we want to pass it in ourselves because it makes it easier to write the test if
we know what NFT we will be using in advance.</p>
<p>We also provide a key for the use contract which takes two <em>Wallet</em>s as parameters. The first is the one that owns the token sale that we are interacting with and the second
is the one that actually runs the contract. As for the type parameters, there is no state parameter, and it uses a different schema - <em>TSUseSchema</em>, but the error type is
the same.</p>
<p>Next we need to provide the <em>instanceTag</em> method which, given an instance key and a wallet, will provide a so-called contract instance tag. As we already know the
wallet that runs the instance, because that was one of the arguments to the instance key constructor we can ignore it as an argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">instanceTag</span> <span class="n">key</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">fromString</span> <span class="o">$</span> <span class="s">&quot;instance tag for: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">key</span>
</pre></div>
</div>
<p>The <em>instanceTag</em> function doesn’t have an accessible constructor, but it implements the <em>IsString</em> class. We haven’t seen the <em>IsString</em> class explicitly but we have
used it when we used the <em>OverloadedStrings</em> GHC extension - it allows a type class that implements it to be represented by a string literal. In particular, it has a
method <em>fromString</em> which, given a string, will create an instance of the type.</p>
<p>The “instance tag for: ” literal in the function above isn’t necessary - all that is necessary is for the whole string to be unique for each instance that we will
ever run in our tests.</p>
<p>There is a default implementation for the <em>instanceTag</em> method of the <em>ContractModel</em> class, so you normally don’t have to implement it yourself. However, it only
works if you have at most one contract instance per wallet. This is not the case for us, as we will have three instances per wallet - one <em>start</em> instance and two
<em>use</em> instances (one for the own wallet’s token sale, and one for the other wallet’s token sale).</p>
<p>The next method that we need to implement is <em>arbitraryAction</em> which is how we tell the system how to generate a random action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arbitraryAction</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">oneof</span> <span class="o">$</span>
   <span class="p">(</span><span class="kt">Start</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span><span class="p">)</span> <span class="kt">:</span>
  <span class="p">[</span> <span class="kt">SetPrice</span>  <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>               <span class="o">++</span>
  <span class="p">[</span> <span class="kt">AddTokens</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>               <span class="o">++</span>
  <span class="p">[</span> <span class="kt">BuyTokens</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>               <span class="o">++</span>
  <span class="p">[</span> <span class="kt">Withdraw</span>  <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>
</pre></div>
</div>
<p>As an argument it gets the model state. We will come to this later, but we don’t need it here and so ignore it in the method declaration.</p>
<p>The function <em>oneof</em> is one of the combinators provided by QuickCheck. Given a list of arbitrary actions, it randomly picks one of those.</p>
<p>Here we are using something else that we have not seen before - the applicative style. Recall that when we looked at monads, we saw that <em>Monad</em> has <em>Applicative</em> as
a superclass. <em>Applicative</em> is often useful to write more compact monadic code.</p>
<p>First let’s look at the <em>genWallet</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">genWallet</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="kt">Wallet</span>
<span class="nf">genWallet</span> <span class="ow">=</span> <span class="n">elements</span> <span class="n">wallets</span>
</pre></div>
</div>
<p>In the random generation monad <em>Gen</em>, it generates a random wallet. It uses another combinator provided by QuickCheck, <em>elements</em>, which simply takes a list of the type
that we wish to generate, and randomly picks one of those elements.</p>
<p>This is using another helper function <em>wallets</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">wallets</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Wallet</span><span class="p">]</span>
<span class="nf">wallets</span> <span class="ow">=</span> <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">]</span>
</pre></div>
</div>
<p>Which, in turn, uses</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="ow">::</span> <span class="kt">Wallet</span>
<span class="nf">w1</span> <span class="ow">=</span> <span class="kt">Wallet</span> <span class="mi">1</span>
<span class="nf">w2</span> <span class="ow">=</span> <span class="kt">Wallet</span> <span class="mi">2</span>
</pre></div>
</div>
<p>So <em>genWallet</em> will randomly pick either Wallet 1 or Wallet 2.</p>
<p>Getting back to the <em>arbitraryAction</em> code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Start</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span>
</pre></div>
</div>
<p>What this means is that we first use <em>genWallet</em> to generate a random wallet and then return <em>Action Start w</em>, where <em>w</em> is the wallet we have just picked.</p>
<p>The right-hand side is of type <em>Gen Wallet</em> and <em>Start</em> takes a <em>Wallet</em> and returns an action. If we <em>fmap</em> (&lt;$&gt;) this, we get a type of <em>Gen Wallet -&gt; Gen Action</em>, which
is what we want.</p>
<p>For the other four actions, we use an additional helper function <em>genNonNeg</em> which generates a nonnegative number.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">genNonNeg</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="kt">Integer</span>
<span class="nf">genNonNeg</span> <span class="ow">=</span> <span class="n">getNonNegative</span> <span class="o">&lt;$&gt;</span> <span class="n">arbitrary</span>
</pre></div>
</div>
<p>Now, when we want to generate a random action for <em>SetPrice</em>, this is where the applicative style really shines.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">SetPrice</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span>
</pre></div>
</div>
<p>If we wanted to write this in a <em>do</em> block, we would do something like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">w1</span> <span class="ow">&lt;-</span> <span class="n">genWallet</span>
<span class="nf">w2</span> <span class="ow">&lt;-</span> <span class="n">genWallet</span>
<span class="nf">p</span>  <span class="ow">&lt;-</span> <span class="n">genNonNeg</span>
<span class="nf">return</span> <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">w1</span> <span class="n">w2</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>You can use the applicative style if the actions in the monad you are invoking don’t depend on the result of previous actions. In a <em>do</em> block, you could do inspect the
the result in <em>w1</em> and make some choice based upon it. This is not possible in <em>Applicative</em>, but often monadic code doesn’t make use of this power, and in these
situations, we have this more compact way of writing it.</p>
<p>We can try out the <em>arbitraryAction</em> function in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">(</span><span class="n">arbitraryAction</span> <span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="p">(</span><span class="kt">Action</span> <span class="kt">TSModel</span><span class="p">))</span>
<span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">3</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">12</span>
<span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">14</span> <span class="mi">3</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">9</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">18</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">17</span>
</pre></div>
</div>
<p>We see that is generates a sample of random actions with random arguments.</p>
<p>The next method to implement is <em>initialState</em> which, as the name suggests, is the initial state of our model.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">initialState</span> <span class="ow">=</span> <span class="kt">TSModel</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
</pre></div>
</div>
<p>Now comes the most complex function that we must implement to set this up. You will recall from when we looked at the diagram that we
must know what effect performing and action will have on the model. This is exactly what the <em>nextState</em> function does.</p>
<p>If we look at the type of <em>nextState</em>, we see that it takes an action and returns something in yet another monad, this time the <em>Spec</em> monad. The <em>Spec</em> monad
allows us to inspect the current state of our model, and also to transfer funds within our model.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span> <span class="kt">Action</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Spec</span> <span class="n">state</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Let’s look an example for <em>Start</em>. This should tell us the effect on our model if wallet <em>w</em> starts a token sale.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">nfts</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
    <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">at</span> <span class="n">w</span><span class="p">)</span> <span class="o">$=</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">TSState</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Here we see a function from the Spec monad called <em>withdraw</em>. Using <em>withdraw</em> means that some funds go from a wallet to a contract - it doesn’t matter which contract. So,
this says that the effect of <em>Start</em> will be that Wallet <em>w</em> loses the NFT.</p>
<p>The NFT is again something that is defined in a helper function. Let’s quickly look at the helper functions that define the NFTs and tradable tokens.</p>
<p>Each wallet will trade its own token and each wallet will have its own NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tokenCurrencies</span><span class="p">,</span> <span class="n">nftCurrencies</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">CurrencySymbol</span>
<span class="nf">tokenCurrencies</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">[</span><span class="s">&quot;aa&quot;</span><span class="p">,</span> <span class="s">&quot;bb&quot;</span><span class="p">]</span>
<span class="nf">nftCurrencies</span>   <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">[</span><span class="s">&quot;01&quot;</span><span class="p">,</span> <span class="s">&quot;02&quot;</span><span class="p">]</span>

<span class="nf">tokenNames</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">TokenName</span>
<span class="nf">tokenNames</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">]</span>

<span class="nf">tokens</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">AssetClass</span>
<span class="nf">tokens</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">tokenCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">tokenNames</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">))</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>

<span class="nf">nftAssets</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">AssetClass</span>
<span class="nf">nftAssets</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">nftCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">nftName</span><span class="p">))</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>

<span class="nf">nfts</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">Value</span>
<span class="nf">nfts</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">nftAssets</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>
</pre></div>
</div>
<p>Wallet 1 will trade the A token and Wallet 2 will trade the B token. Wallet one will have the 01 NFT and Wallet two will have the 02 NFT.</p>
<p>While we are here, we can look at the <em>tss</em> helper which exists alongside the above helper functions and maps the wallets to their <em>TokenSale</em> parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tss</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">TokenSale</span>
<span class="nf">tss</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
    <span class="p">[</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kt">TokenSale</span> <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">=</span>  <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="n">w</span>
                    <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">=</span>  <span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
                    <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">=</span>  <span class="n">nftAssets</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
                    <span class="p">})</span>
    <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Now, back to the <em>nextState</em> function. The first line of the <em>do</em> block says that the effect of calling Start will be that the wallet will loses the NFT to the contract. Remember that the NFT is locked in the
contract when we start the token sale.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">nfts</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
    <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">at</span> <span class="n">w</span><span class="p">)</span> <span class="o">$=</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">TSState</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Secondly, there will be an effect on the model state. Remember that the model state is a map from <em>Wallet</em> to <em>TSState</em>, where <em>TSState</em> is a triple of price, tokens and Ada.</p>
<p>The second line of the <em>do</em> block says that after the contract has started, there will be an entry in the map at key <em>w</em> with 0 price, 0 tokens and 0 Ada.</p>
<p>The left hand side of the expression is another example of an optic, this time allowing us to access the map <em>_tsModel</em> from <em>TSModel</em>. The <em>at</em> lens allows us to
reference a map entry at a given key. The type returned by this optic is a <em>Maybe</em> as the key may or may not be there.</p>
<p>The $= comes from the Spec monad and it takes a lens on the left-hand side and then a new value on the right-hand side.</p>
<p>The <em>wait</em> function comes from the Spec monad and says here that the <em>Start</em> will take one slot.</p>
<p>Now we do something similar for all the other operations. Firstly, <em>SetPrice</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">v</span> <span class="n">w</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">when</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">w</span><span class="p">)</span> <span class="o">$</span>
      <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssPrice</span><span class="p">)</span> <span class="o">$=</span> <span class="n">p</span>
  <span class="n">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>In this function, we only do something if the wallet that invokes <em>SetPrice</em> is the same as the wallet that is running the token sale. If it is then the funds
don’t move, but we must update the model.</p>
<p>We use a different optic - instead of <em>at</em> we use <em>ix</em> which is a <em>Traversal</em>. It is similar to <em>at</em>, but whereas <em>at</em> returned a <em>Maybe</em>, <em>ix</em> does not. It also uses the <em>tssPrice</em> lens to access the first element of the <em>TSState</em> triple, which it sets to the price.
In the event that <em>ix</em> does not find an entry, the line will have no effect.</p>
<p>Whether or not the wallets match, and whether or not the price update succeeds, we wait one slot.</p>
<p>The model state change for <em>AddTokens</em> is more complex.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">started</span> <span class="ow">&lt;-</span> <span class="n">hasStarted</span> <span class="n">v</span>                                     <span class="c1">-- has the token sale started?</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>First we check the the token sale for wallet <em>v</em> has actually started, and this is yet another helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getTSState&#39;</span> <span class="ow">::</span> <span class="kt">ModelState</span> <span class="kt">TSModel</span> <span class="ow">-&gt;</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">TSState</span>
<span class="nf">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">s</span> <span class="o">^.</span> <span class="n">contractState</span> <span class="o">.</span> <span class="n">tsModel</span> <span class="o">.</span> <span class="n">at</span> <span class="n">v</span>
</pre></div>
</div>
<p>Given a <em>ModelState</em> (which is of type <em>TSModel</em> but with additional information such as current funds and current time) and given a <em>Wallet</em>, we want to extract the
<em>TSState</em> which is the state of the token sale contract for that wallet, which may or may not have started yet.</p>
<p>This is again performed using optics. There is a lens called <em>contractState</em> which, here is the <em>TSModel</em> type. We then zoom into the map and use the <em>at</em> lens, which
will return <em>Nothing</em> if the wallet key <em>v</em> does not exist, or a <em>Just TSState</em> if it is there.</p>
<p>Using this, we can write a slight variety of this function which doesn’t have the first argument. Instead it takes just the <em>Wallet</em> argument, but then returns the
<em>Maybe TSState</em> in the Spec monad. In order to do that, we use a feature of the Spec monad, a function called <em>getModelState</em>, which will return the model state, which
we then pass to the primed version of the function along with the <em>Wallet</em> argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getTSState</span> <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Spec</span> <span class="kt">TSModel</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">TSState</span><span class="p">)</span>
<span class="nf">getTSState</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getModelState</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
</pre></div>
</div>
<p>And then another variation, this time called <em>hasStarted</em>, which will tells us, within the Spec monad, whether the token sale has stared or not.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hasStarted</span> <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Spec</span> <span class="kt">TSModel</span> <span class="kt">Bool</span>
<span class="nf">hasStarted</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">isJust</span> <span class="o">&lt;$&gt;</span> <span class="n">getTSState</span> <span class="n">v</span>
</pre></div>
</div>
<p>This just checks whether the return value from <em>getTSState v</em> is a <em>Just</em> or a <em>Nothing</em>. The <em>isJust</em> function returns True if it is a <em>Just</em>, and we need to use <em>fmap</em>
to lift it into the Spec monad.</p>
<p>Continuing the <em>nextState</em> function for <em>AddTokens</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">started</span> <span class="ow">&lt;-</span> <span class="n">hasStarted</span> <span class="n">v</span>
  <span class="n">when</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">started</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">bc</span> <span class="ow">&lt;-</span> <span class="n">askModelState</span> <span class="o">$</span> <span class="n">view</span> <span class="o">$</span> <span class="n">balanceChange</span> <span class="n">w</span>
</pre></div>
</div>
<p>If the token sale has not started, we don’t do anything because <em>AddTokens</em> shouldn’t have any effect in that case.</p>
<p>We also check that the number of tokens to be added is greater than zero. If not, again we do nothing. Otherwise, we continue.</p>
<p>We now see another function from the Spec monad called <em>askModelState</em>, which is similar to <em>getModelState</em> but it doesn’t return the complete model state but instead
takes a function and applies it to the the model state. The function <em>view</em> comes from the <em>lens</em> library and is just another name for the <em>^.</em> operator for viewing the
result of zooming into a lens.</p>
<p>And there is a <em>balanceChange w</em> lens which is a lens to the balance change of wallet <em>w</em>. The balance change refers to how much the funds of the wallet have changed
since the start of the simulation.</p>
<p>At this point we have the balance change bound to <em>bc</em>. The reason we are doing this is because we want to make sure that the wallet has enough funds to add the requested
number of tokens, which we now do. First we look up the token.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">token</span> <span class="ow">=</span> <span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span>
</pre></div>
</div>
<p>Then we check whether the wallet has enough of them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">when</span> <span class="p">(</span><span class="n">tokenAmt</span> <span class="o">+</span> <span class="n">assetClassValueOf</span> <span class="n">bc</span> <span class="n">token</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>  <span class="c1">-- does the wallet have the tokens to give?</span>
  <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="n">n</span>
  <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The number in <em>tokenAmt</em> is the number of tokens the wallet had at the start, so by adding this to the balance change for the token, we get the number of tokens
currently in the wallet.</p>
<p>If we have enough tokens, then we withdraw the correct number of tokens from the wallet, and we update the model to show that the tokens should now be in the contract. Note that
instead of using $= to set the value, we use the $~ function which applies a function to a value.</p>
<p>Again, we wait one slot.</p>
<p>Next, we write a <em>nextState</em> function for <em>BuyTokens</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">BuyTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">when</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">getTSState</span> <span class="n">v</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="n">t</span>
            <span class="o">|</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssToken</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssPrice</span>
                    <span class="n">l</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n</span>
                <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">lovelaceValueOf</span> <span class="n">l</span>
                <span class="n">deposit</span> <span class="n">w</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span><span class="p">)</span> <span class="n">n</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssLovelace</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="n">l</span><span class="p">)</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span>    <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span><span class="p">))</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>First we check the the number of tokens we are attempting to buy is positive.  If so, then we get the state of the token sale.</p>
<p>If the state is a <em>Just</em> then we know that the token sale has started.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">getTSState</span> <span class="n">v</span>
<span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="n">t</span>
</pre></div>
</div>
<p>If so, then we use optics to check that the number of tokens available in the contract is at least enough for us to buy what we are asking for.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">t</span> <span class="o">^.</span> <span class="n">tssToken</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
</pre></div>
</div>
<p>If we are still going, we then lookup the current price and calculate how much the requested number of tokens will cost.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssPrice</span>
<span class="nf">l</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n</span>
</pre></div>
</div>
<p>The effect should then be that our wallet loses that number of lovelace, and gains the tokens we buy. Here we see the <em>deposit</em> function for the first time. It is the opposite
of the <em>withdraw</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">lovelaceValueOf</span> <span class="n">l</span>
<span class="nf">deposit</span> <span class="n">w</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span><span class="p">)</span> <span class="n">n</span>
</pre></div>
</div>
<p>Finally we update the model state by adding the lovelace and removing the bought tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssLovelace</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="n">l</span><span class="p">)</span>
<span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span>    <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>And we wait for one slot.</p>
<p>Finally, the <em>Withdraw</em> action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">Withdraw</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">when</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">w</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">getTSState</span> <span class="n">v</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="n">t</span>
            <span class="o">|</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssToken</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssLovelace</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                <span class="n">deposit</span> <span class="n">w</span> <span class="o">$</span> <span class="n">lovelaceValueOf</span> <span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span> <span class="n">n</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssLovelace</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">l</span><span class="p">))</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span><span class="p">))</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This is only possible if the wallet wanting to withdraw is the same as the wallet running the sale. We check this first, then get the contract state.</p>
<p>We check both that there are enough tokens for us to withdraw the tokens that we are requesting, and also that there are enough lovelace for us to withdraw the lovelace that
we are requesting. If this is satisfied, the effect is that we add the lovelace and the tokens to the wallet, and the model is updated to reflect the fact that the
tokens and the lovelace have been removed.</p>
<p>That completes the <em>nextState</em> function declarations.</p>
<p>Right now, the model is just a conceptual model that has nothing to do with the contracts we wrote earlier. The names are suggestive because they have same names as
we used in the redeemer, but there is no link yet between the model and the actual contracts.</p>
<p>The link is provided by yet another method in the <em>ContractModel</em> class that we have to implement, and that’s the <em>perform</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">perform</span>
  <span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span>
    <span class="kt">HandleFun</span> <span class="n">state</span>
    <span class="ow">-&gt;</span> <span class="kt">ModelState</span> <span class="n">state</span>
    <span class="ow">-&gt;</span> <span class="kt">Action</span> <span class="n">state</span>
    <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">EmulatorTrace</span> <span class="nb">()</span>
</pre></div>
</div>
<p>It takes something called <em>HandleFun</em> and then it takes the <em>ModelState</em> and the <em>Action</em>.</p>
<p>The <em>HandleFun</em> parameter gives us access to the contract handles.</p>
<p>Let’s look at our implementation of this method. We don’t need access to the <em>ModelState</em> for this example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">perform</span> <span class="n">h</span> <span class="kr">_</span> <span class="n">cmd</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">cmd</span> <span class="kr">of</span>
  <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span>          <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">StartKey</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">nftCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">tokenCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">tokenNames</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">v</span> <span class="n">w</span> <span class="n">p</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;set price&quot;</span>  <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">p</span>                                                                    <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span>  <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;add tokens&quot;</span> <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">n</span>                                                                    <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">BuyTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span>  <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">n</span>                                                                    <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">Withdraw</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span> <span class="n">l</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;withdraw&quot;</span>   <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we are linking actions to contract endpoints. Recall that we wrote functions that create keys that uniquely identify contracts. The functions were called <em>StartKey</em>
and <em>UseKey</em>.</p>
<p>The <em>StartKey</em> function takes one <em>Wallet</em> as an argument, and you can see that we give that argument here in the first line of the body of the function.
Then we apply the function <em>h</em> to it. The function <em>h</em> is the <em>HandleFun</em> parameter and it is the job of this function to get a handle to the contract instance associated with a given key.</p>
<p>We also pass in the parameters. So in the example of the start action, we pass in a pre-computed values for the NFT, the token currencies and the token names.
We will say later how the <em>instanceSpec</em> function links the <em>StartKey</em> to <em>startEndpoint’</em>, the primed version of the function, which takes those three parameters.</p>
<p>The <em>delay</em> function used in <em>perform</em> is another simple helper function to wait for a number of slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">delay</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">delay</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">.</span> <span class="n">waitNSlots</span> <span class="o">.</span> <span class="n">fromIntegral</span>
</pre></div>
</div>
<p>All the other actions are very similar, but note that they all use <em>UseKey</em> instead of <em>StartKey</em>.</p>
<p>Finally, the last method we must provide for the <em>ContractModel</em> instance is <em>precondition</em>. This allows us to define the conditions under which it is acceptable
to provide each action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span> <span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span> <span class="kt">ModelState</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Action</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The precondition for <em>Start</em> is that the token sale has not yet started. It says that, given a certain state <em>s</em> and the <em>Start w</em> action, check that the return value
of <em>getTSState’ s w</em> is <em>Nothing</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span>          <span class="ow">=</span> <span class="n">isNothing</span> <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">w</span>
</pre></div>
</div>
<p>And for the others, we do the opposite. They are only possible if the token sale has started.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span>   <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
<span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
<span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">BuyTokens</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
<span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Withdraw</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
</pre></div>
</div>
<p>One last thing, we must link the keys to actual contracts. We do this with the <em>instanceSpec</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">instanceSpec</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="kt">TSModel</span><span class="p">]</span>
<span class="nf">instanceSpec</span> <span class="ow">=</span>
    <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="p">(</span><span class="kt">StartKey</span> <span class="n">w</span><span class="p">)</span> <span class="n">w</span> <span class="n">startEndpoint&#39;</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span> <span class="o">++</span>
    <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="p">(</span><span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">w</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="o">$</span> <span class="n">tss</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span> <span class="o">|</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">,</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>
</pre></div>
</div>
<p>The <em>instanceSpec</em> function returns a list of <em>ContractInstanceSpec</em> types.</p>
<p>A <em>ContractInstanceSpec</em> takes three arguments - the first is the key, the second is the wallet, and the third is the contract that is supposed to be invoked.</p>
<p>For the start endpoint, we generate a <em>ContractInstanceSpec</em> for each wallet.</p>
<p>For the use endpoint, we generate a <em>ContractInstanceSpec</em> for all combinations of two wallets. Note also that the <em>useEndpoints</em> function takes an argument of type
<em>TokenSale</em>, so we need to get this from Wallet <em>v</em> and pass it in.</p>
<p>And finally (honestly), we can define a QuickCheck property.</p>
<p>There’s a function in Plutus.Contract.Test called <em>propRunActionsWithOptions</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">propRunActionsWithOptions</span>
<span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span>
   <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">CheckOptions</span>
   <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="n">state</span><span class="p">]</span>
   <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">ModelState</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">TracePredicate</span><span class="p">)</span>
   <span class="ow">-&gt;</span> <span class="kt">Actions</span> <span class="n">state</span>
   <span class="ow">-&gt;</span> <span class="kt">Property</span>
</pre></div>
</div>
<p>First it takes the <em>CheckOptions</em> type that we have seen before when we did emulator trace testing. Next it takes the list of <em>ContractInstanceSpec</em>s that we defined above.
Then it takes a function from <em>ModelState</em> to <em>TracePredicate</em>, which allows us to insert additional tests. And finally, it produces a function from a list of <em>Action</em>s to
<em>Property</em>. <em>Property</em> is like a beefed-up <em>Bool</em>, which has additional capabilities, mostly for logging and debugging.</p>
<p>We use this in the <em>prop_TS</em> function. For options we use the same as before which allows us to specify the initial coin distributions. We give each wallet 1,000 Ada, the
wallet’s NFT and 1,000 of both tokens, <em>A</em> and <em>B</em>.</p>
<p>For the second argument we provide the <em>instanceSpec</em> function. For the third argument, we don’t add any additional checks.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_TS</span> <span class="ow">::</span> <span class="kt">Actions</span> <span class="kt">TSModel</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">prop_TS</span> <span class="ow">=</span> <span class="n">withMaxSuccess</span> <span class="mi">100</span> <span class="o">.</span> <span class="n">propRunActionsWithOptions</span>
    <span class="p">(</span><span class="n">defaultCheckOptions</span> <span class="o">&amp;</span> <span class="n">emulatorConfig</span> <span class="o">.~</span> <span class="kt">EmulatorConfig</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">instanceSpec</span>
    <span class="p">(</span><span class="n">const</span> <span class="o">$</span> <span class="n">pure</span> <span class="kt">True</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">d</span> <span class="ow">::</span> <span class="kt">InitialDistribution</span>
    <span class="n">d</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="p">[</span> <span class="p">(</span> <span class="n">w</span>
                         <span class="p">,</span> <span class="n">lovelaceValueOf</span> <span class="mi">1000_000_000</span> <span class="o">&lt;&gt;</span>
                           <span class="p">(</span><span class="n">nfts</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span>               <span class="o">&lt;&gt;</span>
                           <span class="n">mconcat</span> <span class="p">[</span><span class="n">assetClassValue</span> <span class="n">t</span> <span class="n">tokenAmt</span> <span class="o">|</span> <span class="n">t</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">elems</span> <span class="n">tokens</span><span class="p">])</span>
                       <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span>
                       <span class="p">]</span>
</pre></div>
</div>
<p>This results in a type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Actions</span> <span class="kt">TSModel</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
</pre></div>
</div>
<p>And this is something that QuickCheck can handle.</p>
<p>Let’s look at a sample of <em>Actions TSModel</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">(</span><span class="n">arbitrary</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="p">(</span><span class="kt">Actions</span> <span class="kt">TSModel</span><span class="p">))</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">8</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">7</span> <span class="mi">2</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">,</span>
  <span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">14</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">11</span> <span class="mi">7</span><span class="p">,</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">12</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">11</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">10</span> <span class="mi">6</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">13</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">8</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">6</span> <span class="mi">14</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">7</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">4</span><span class="p">,</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">10</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">14</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">20</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">15</span><span class="p">,</span>
  <span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">14</span> <span class="mi">1</span><span class="p">,</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">4</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">21</span> <span class="mi">2</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">8</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">15</span> <span class="mi">17</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>We notice here a similar pattern to before, where things start quite simply and get more complex as the list goes on.</p>
<p>So what will be tested? As we saw in the diagram back at the beginning, for all these randomly-generated action sequences, it will test that the properties we specified in the model -
how the funds flow - corresponds to what actually happens in the emulator. If there is a discrepancy, the test will fail.</p>
<p>Let’s use it!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">test</span>
<span class="p">(</span><span class="mi">21</span> <span class="n">tests</span><span class="p">)</span>
</pre></div>
</div>
<p>It takes quite a while.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">test</span>
<span class="p">(</span><span class="mi">27</span> <span class="n">tests</span><span class="p">)</span>
</pre></div>
</div>
<p>But it will run 100 if you let it complete.</p>
<p>What might be more interesting would be to implement a bug in the code and see if these tests will find it.</p>
<p>In the <em>transition</em> function of our <em>TokenSale</em> code, let’s forget to check that only the seller can change the price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TSRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="nf">transition</span> <span class="n">ts</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kt">SetPrice</span> <span class="n">p</span><span class="p">)</span>   <span class="o">|</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span> <span class="c1">-- Just ( Constraints.mustBeSignedBy (tsSeller ts)</span>
    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
      <span class="n">v</span> <span class="o">&lt;&gt;</span>
      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>We need to reload the code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude Test.QuickCheck Plutus.Contract.Test.ContractModel Spec.Model&gt; :l test/Spec/Model.hs
Ok, one module loaded.
Prelude Test.QuickCheck Plutus.Contract.Test.ContractModel Spec.Model&gt; test
*** Failed! Assertion failed (after 13 tests and 2 shrinks)...
</pre></div>
</div>
<p>You will see a whole bunch of output, but at the top, you will see clearly the action sequence that led to the bug.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Actions</span>
  <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
   <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">12</span><span class="p">,</span>
   <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">11</span><span class="p">,</span>
   <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
<span class="kt">Expected</span> <span class="n">funds</span> <span class="kr">of</span> <span class="kt">W2</span> <span class="n">to</span> <span class="n">change</span> <span class="n">by</span>
   <span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(</span><span class="mi">02</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;NFT&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]),(</span><span class="n">bb</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">)])])</span>
   <span class="p">(</span><span class="n">excluding</span> <span class="mi">29466</span> <span class="n">lovelace</span> <span class="kr">in</span> <span class="n">fees</span><span class="p">)</span>
<span class="nf">but</span> <span class="n">they</span> <span class="n">changed</span> <span class="n">to</span>
   <span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">)]),(</span><span class="mi">02</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;NFT&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]),(</span><span class="n">bb</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">)])])</span>
<span class="kt">Test</span> <span class="n">failed</span><span class="o">.</span>
</pre></div>
</div>
<p>And we see that Wallet 1 has tried to set the price of the token sale that was started by Wallet 2. This should result in no change, because Wallet 1 is not allowed to
do this.</p>
<p>The model believes that the price should still be zero, but in the emulator the price has been set to 12.</p>
<p>Then Wallet 2 adds 11 tokens, and then buys 1 token from itself.</p>
<p>According to the model, the tokens should be free. The model expects that the wallet loses the NFT, that the wallet also loses 10 “B” because it gave 11 and then bought 1 back,
and that there is no change in Ada in the wallet, because the token price is zero.</p>
<p>But in the emulator, setting the price did have an effect, and so it reports that the wallet lost 12 lovelace.</p>
<p>So the discrepancy in the flow of funds has been found, and QuickCheck reports the error.</p>
<p>By default this is all the QuickCheck test do. It only checks the flow of funds, whether the emulator and the model agree at each point. It is, however, possible to
add additional checks. And it is also possible to influence the action sequences so that we can specify certain flows of actions to steer the tests in certain
directions. That is called Dynamic Logic, and that is yet another monad.</p>
<p>Even though this is very powerful, it also has its limitations. For one, it only tests the contracts that we provide. It doesn’t test all possible off-chain code. It is
possible that some party could write their own off-chain code that would allow them to steal funds from our contract, and this QuickCheck model can’t test for that.</p>
<p>The second problem is concurrency. We added this delay of one slot to each action to make sure that everything is nicely sequenced. Of course, in a real blockchain or
in an emulator, wallets can have concurrent submissions of transactions. In principle we could try to do that with this model as well, but then we would need to
somehow specify in the model what should happen in each case and that could get very complicated.</p>
<p>We should quickly look at how this integrates with Tasty.</p>
<p>There is a function in the Tasty library called <em>testProperty</em> that takes, as one its arguments, a QuickCheck property.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">testProperty</span> <span class="s">&quot;token sale model&quot;</span> <span class="n">prop_TS</span>
</pre></div>
</div>
<p>You will see an additional stanza in this week’s cabal file</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span>
<span class="nb">type</span><span class="p">:</span> <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">Spec</span><span class="o">.</span><span class="n">hs</span>
<span class="o">...</span>
</pre></div>
</div>
<p>And, if we look at the referenced Spec.hs</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">defaultMain</span> <span class="n">tests</span>

<span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">testGroup</span> <span class="s">&quot;token sale&quot;</span>
    <span class="p">[</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="n">tests</span>
    <span class="p">,</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">.</span><span class="n">tests</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>We can see that it specifies a list of test modules. And these can be run from the command line with the following command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">test</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week9.html" class="btn btn-neutral float-right" title="1.9. Week 09 - Marlowe" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="week7.html" class="btn btn-neutral float-left" title="1.7. Week 07 - State Machines" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>